1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_01_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_01_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWK...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHas...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_01_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_01_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_02_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_02_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(1)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKe...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(1)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';                 }        ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_02_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_03_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_03_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(5==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANC...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(crypt...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(5==5)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';                 }     ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_03_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_04_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_04_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_TRUE)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NU...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen ...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_TRUE)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';          ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_04_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_05_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_05_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticTrue)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strle...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticTrue)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';                 ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_05_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_06_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_06_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FIVE==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv,...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLe...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FIVE==5)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';       ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_06_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_07_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_07_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticFive==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, ...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = str...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticFive==5)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';              ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_07_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_08_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_08_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticReturnsTrue())     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, ...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLe...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(staticReturnsTrue())     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';        ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_08_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_09_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_09_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_TRUE)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NU...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen ...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_TRUE)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';          ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_09_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_10_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_10_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalTrue)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strle...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalTrue)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';                 ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_10_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_11_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_11_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrue())     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, ...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLe...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrue())     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';        ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_11_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_12_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_12_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrueOrFalse())     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is  ...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrueOrFalse())     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';  ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_12_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_12_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_13_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_13_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FIVE==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv,...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLe...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FIVE==5)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';       ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_13_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_14_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_14_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalFive==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, ...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = str...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     if(globalFive==5)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';              ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_14_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_15_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_15_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     switch(6)     {     case 6:         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a ne...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     switch(6)     {     case 6:     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     break;     default:         /* INCIDENTAL: CWE ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_15_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_16_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_16_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     while(1)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);         break;     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, ...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     while(1)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';                 }      ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_16_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_16_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_17_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_17_bad() {     int i;     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     for(i = 0; i < 1; i++)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hC...
0	goodG2B	static void goodG2B() {     int h;     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     for(h = 0; h < 1; h++)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0'...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_17_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_17_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_18_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_18_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     goto source; source:     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV,...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     goto source; source:     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_18_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_18_good() {     goodG2B(); }
1	badSource	static char * badSource(char * cryptoKey) {     if(badStatic)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     return cryptoKey; }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_21_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_21_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     badStatic = 1; /* true */     cryptoKey = badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring...
0	goodG2B1Source	static char * goodG2B1Source(char * cryptoKey) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)             ...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     goodG2B1Static = 0; /* false */     cryptoKey = goodG2B1Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context"); ...
0	goodG2B2Source	static char * goodG2B2Source(char * cryptoKey) {     if(goodG2B2Static)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = '\0';                 }             }         }     }     return cryptoKey; }
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     goodG2B2Static = 1; /* true */     cryptoKey = goodG2B2Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");  ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_21_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_badGlobal = 1; /* true */     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED...
0	goodG2B1	static void goodG2B1() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B1Global = 0; /* false */     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B1Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT...
0	goodG2B2	static void goodG2B2() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B2Global = 1; /* true */     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B2Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_badSource	char * CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_badSource(char * cryptoKey) {     if(CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_badGlobal)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);     }     return cryptoKey; }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B1Source	char * CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B1Source(char * cryptoKey) {     if(CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */          ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B2Source	char * CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B2Source(char * cryptoKey) {     if(CWE321_Hard_Coded_Cryptographic_Key__w32_char_22_goodG2B2Global)     {         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_31_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_31_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     {         char * cryptoKeyCopy = cryptoKey;         char * cryptoKey = cryptoKeyCopy;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             char toBeEncrypted[] = "String to be encrypted";             DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypted, toBeEncrypted, encryptedLen);             /* Try to get a context with and without a new key set */             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANC...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     {         char * cryptoKeyCopy = cryptoKey;         char * cryptoKey = cryptoKey...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_31_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_31_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_32_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_32_bad() {     char * cryptoKey;     char * *cryptoKeyPtr1 = &cryptoKey;     char * *cryptoKeyPtr2 = &cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         char * cryptoKey = *cryptoKeyPtr1;         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         strcpy(cryptoKey, CRYPTO_KEY);         *cryptoKeyPtr1 = cryptoKey;     }     {         char * cryptoKey = *cryptoKeyPtr2;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             char toBeEncrypted[] = "String to be encrypted";             DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypted, toBeEncrypted, encryptedLe...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char * *cryptoKeyPtr1 = &cryptoKey;     char * *cryptoKeyPtr2 = &cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         char * cryptoKey = *cryptoKeyPtr1;         {             size_t cryptoKeyLen = strlen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgets() failed");                     /* Restore NUL terminator if fgets fails */                     cryptoKey[cryptoKeyLen] = '\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgets() */                 cryptoKeyLen = strlen(cryptoKey);                 if (cry...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_32_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_32_good() {     goodG2B(); }
1	bad	void bad() {     char * cryptoKey;     char * &cryptoKeyRef = cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     {         char * cryptoKey = cryptoKeyRef;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             char toBeEncrypted[] = "String to be encrypted";             DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypted, toBeEncrypted, encryptedLen);             /* Try to get a context with and without a new key set */             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))             {              ...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char * &cryptoKeyRef = cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     {         char * cryptoKey = cryptoKeyRef;...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_34_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_34_bad() {     char * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_34_unionType myUnion;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     myUnion.unionFirst = cryptoKey;     {         char * cryptoKey = myUnion.unionSecond;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             char toBeEncrypted[] = "String to be encrypted";             DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypted, toBeEncrypted, encryptedLen);             /* Try to get a context with and without a new key...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_34_unionType myUnion;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     myUnion....
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_34_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_34_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_badSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hCr...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_goodG2BSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_goodG2BSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_41_good() {     goodG2B(); }
1	badSource	static char * badSource(char * cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     return cryptoKey; }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_42_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_42_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     cryptoKey = badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");     ...
0	goodG2BSource	static char * goodG2BSource(char * cryptoKey) {     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     return cryptoKey; }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     cryptoKey = goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_42_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_42_good() {     goodG2B(); }
1	badSource	static void badSource(char * &cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY); }
1	bad	void bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Creat...
0	goodG2BSource	static void goodG2BSource(char * &cryptoKey) {     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     } }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }  ...
1	badSink	static void badSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))     ...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_44_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_44_bad() {     char * cryptoKey;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     /* use the function pointer */     funcPtr(cryptoKey); }
0	goodG2BSink	static void goodG2BSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash)) ...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     void (*funcPtr) (char *) = goodG2BSink;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     funcPtr(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_44_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     char * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_badData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         ...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_badData = cryptoKey;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_goodG2BData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */ ...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_goodG2BData = cryptoKey;     go...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_45_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_51_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_51_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_51b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_51b_goodG2BSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_51_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_51_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_51b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_51b_badSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hC...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_51b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_51b_goodG2BSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHas...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_52_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_52_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_52b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_52b_goodG2BSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_52_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_52_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_52b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_52b_badSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_52c_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_52b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_52b_goodG2BSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_52c_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_52c_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_52c_badSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hC...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_52c_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_52c_goodG2BSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHas...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_53b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_53b_goodG2BSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53b_badSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_53c_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53b_goodG2BSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_53c_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53c_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53c_badSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_53d_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53c_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53c_goodG2BSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_53d_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53d_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53d_badSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hC...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_53d_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_53d_goodG2BSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHas...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54b_goodG2BSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54b_badSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54c_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54b_goodG2BSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54c_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54c_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54c_badSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54d_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54c_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54c_goodG2BSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54d_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54d_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54d_badSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54e_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54d_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54d_goodG2BSink(char * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_char_54e_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54e_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54e_badSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hC...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_54e_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_54e_goodG2BSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHas...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_61_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_61_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_61b_badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_61b_goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_61_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_61_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_61b_badSource	char * CWE321_Hard_Coded_Cryptographic_Key__w32_char_61b_badSource(char * cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     return cryptoKey; }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_61b_goodG2BSource	char * CWE321_Hard_Coded_Cryptographic_Key__w32_char_61b_goodG2BSource(char * cryptoKey) {     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     return cryptoKey; }
1	bad	void bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Creat...
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }  ...
1	badSource	void badSource(char * &cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY); }
0	goodG2BSource	void goodG2BSource(char * &cryptoKey) {     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     } }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_63_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_63_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_63b_badSink(&cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_63b_goodG2BSink(&cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_63_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_63_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_63b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_63b_badSink(char * * cryptoKeyPtr) {     char * cryptoKey = *cryptoKeyPtr;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Ha...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_63b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_63b_goodG2BSink(char * * cryptoKeyPtr) {     char * cryptoKey = *cryptoKeyPtr;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Creat...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_64_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_64_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_64b_badSink(&cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_64b_goodG2BSink(&cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_64_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_64_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_64b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_64b_badSink(void * cryptoKeyVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * cryptoKeyPtr = (char * *)cryptoKeyVoidPtr;     /* dereference cryptoKeyPtr into cryptoKey */     char * cryptoKey = (*cryptoKeyPtr);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AE...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_64b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_64b_goodG2BSink(void * cryptoKeyVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * cryptoKeyPtr = (char * *)cryptoKeyVoidPtr;     /* dereference cryptoKeyPtr into cryptoKey */     char * cryptoKey = (*cryptoKeyPtr);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RS...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_65_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_65_bad() {     char * cryptoKey;     /* define a function pointer */     void (*funcPtr) (char *) = CWE321_Hard_Coded_Cryptographic_Key__w32_char_65b_badSink;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     /* use the function pointer */     funcPtr(cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     void (*funcPtr) (char *) = CWE321_Hard_Coded_Cryptographic_Key__w32_char_65b_goodG2BSink;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }       ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_65_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_65_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_65b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_65b_badSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hC...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_65b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_65b_goodG2BSink(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHas...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_66_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_66_bad() {     char * cryptoKey;     char * cryptoKeyArray[5];     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     /* put cryptoKey in array */     cryptoKeyArray[2] = cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_66b_badSink(cryptoKeyArray); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char * cryptoKeyArray[5];     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     cryptoKeyArray[2] = cryptoKey;     CWE321_Hard_Cod...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_66_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_66_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_66b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_66b_badSink(char * cryptoKeyArray[]) {     /* copy cryptoKey out of cryptoKeyArray */     char * cryptoKey = cryptoKeyArray[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_66b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_66b_goodG2BSink(char * cryptoKeyArray[]) {     char * cryptoKey = cryptoKeyArray[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /*...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_bad() {     char * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_structType myStruct;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     myStruct.structFirst = cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_structType myStruct;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     myStru...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_67b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_67b_badSink(CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_structType myStruct) {     char * cryptoKey = myStruct.structFirst;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_67b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_67b_goodG2BSink(CWE321_Hard_Coded_Cryptographic_Key__w32_char_67_structType myStruct) {     char * cryptoKey = myStruct.structFirst;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");            ...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_badData = cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_68b_badSink(); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_goodG2BData = cryptoKey;     CW...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_68b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_68b_badSink() {     char * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_badData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_68b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_68b_goodG2BSink() {     char * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_char_68_goodG2BData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             } ...
1	bad	void bad() {     char * cryptoKey;     vector<char *> cryptoKeyVector;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     /* Put cryptoKey in a vector */     cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);     cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);     cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);     badSink(cryptoKeyVector); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     vector<char *> cryptoKeyVector;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     /* Put cryptoKey in a vector */     cryptoKe...
1	badSink	void badSink(vector<char *> cryptoKeyVector) {     /* copy cryptoKey out of cryptoKeyVector */     char * cryptoKey = cryptoKeyVector[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         ...
0	goodG2BSink	void goodG2BSink(vector<char *> cryptoKeyVector) {     char * cryptoKey = cryptoKeyVector[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCr...
1	bad	void bad() {     char * cryptoKey;     list<char *> cryptoKeyList;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     /* Put cryptoKey in a list */     cryptoKeyList.push_back(cryptoKey);     cryptoKeyList.push_back(cryptoKey);     cryptoKeyList.push_back(cryptoKey);     badSink(cryptoKeyList); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     list<char *> cryptoKeyList;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     /* Put cryptoKey in a list */     cryptoKeyList....
1	badSink	void badSink(list<char *> cryptoKeyList) {     /* copy cryptoKey out of cryptoKeyList */     char * cryptoKey = cryptoKeyList.back();     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* C...
0	goodG2BSink	void goodG2BSink(list<char *> cryptoKeyList) {     char * cryptoKey = cryptoKeyList.back();     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCrea...
1	bad	void bad() {     char * cryptoKey;     map<int, char *> cryptoKeyMap;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     /* Put cryptoKey in a map */     cryptoKeyMap[0] = cryptoKey;     cryptoKeyMap[1] = cryptoKey;     cryptoKeyMap[2] = cryptoKey;     badSink(cryptoKeyMap); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     map<int, char *> cryptoKeyMap;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     /* Put cryptoKey in a map */     cryptoKeyMap...
1	badSink	void badSink(map<int, char *> cryptoKeyMap) {     /* copy cryptoKey out of cryptoKeyMap */     char * cryptoKey = cryptoKeyMap[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Crea...
0	goodG2BSink	void goodG2BSink(map<int, char *> cryptoKeyMap) {     char * cryptoKey = cryptoKeyMap[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreate...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_81_bad::action(char * cryptoKey) const {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCrea...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_81_goodG2B::action(char * cryptoKey) const {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Crypt...
1	bad	void bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     const CWE321_Hard_Coded_Cryptographic_Key__w32_char_81_base& baseObject = CWE321_Hard_Coded_Cryptographic_Key__w32_char_81_bad();     baseObject.action(cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     const CWE321_Hard_Coded_Cryptographic_Key__w32_char_81_base& baseObject = CWE321...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_82_bad::action(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_char_82_goodG2B::action(char * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreate...
1	bad	void bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_char_82_base* baseObject = new CWE321_Hard_Coded_Cryptographic_Key__w32_char_82_bad;     baseObject->action(cryptoKey);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_char_82_base* baseObject = new CWE321_H...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad::CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad(char * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY); }
1	~CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad::~CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */  ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_goodG2B::CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_goodG2B(char * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     } }
0	~CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_goodG2B::~CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_goodG2B() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash han...
1	bad	void bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad badObject(cryptoKey); }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_goodG2B goodG2BObject(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad::CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad(char * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     strcpy(cryptoKey, CRYPTO_KEY); }
1	~CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad::~CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */  ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B::CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B(char * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     {         size_t cryptoKeyLen = strlen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgets(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgets() failed");                 /* Restore NUL terminator if fgets fails */                 cryptoKey[cryptoKeyLen] = '\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgets() */             cryptoKeyLen = strlen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = '\0';             }         }     } }
0	~CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B::~CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         char toBeEncrypted[] = "String to be encrypted";         DWORD encryptedLen = strlen(toBeEncrypted)*sizeof(char);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash han...
1	bad	void bad() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad * badObject = new CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_bad(cryptoKey);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * cryptoKey;     char cryptoKeyBuffer[100] = "";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B * goodG2BObject =  new CWE321_Hard_Coded_Cryptographic_Key__w32_char_84_goodG2B(cryptoKey);     delete goodG2BObject; }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_01_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_01_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RS...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HC...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_01_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_01_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_02_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_02_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(1)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, N...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcs...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(1)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0';             ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_02_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_03_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_03_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(5==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = ...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(5==5)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0';          ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_03_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_04_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_04_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_TRUE)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContex...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 c...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_TRUE)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_04_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_05_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_05_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticTrue)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCry...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKe...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticTrue)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0';    ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_05_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_06_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_06_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FIVE==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireCon...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                ...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(STATIC_CONST_FIVE==5)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_06_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_07_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_07_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticFive==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&h...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 crypto...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticFive==5)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0'; ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_07_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_08_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_08_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticReturnsTrue())     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireCont...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                ...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(staticReturnsTrue())     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_08_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_09_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_09_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_TRUE)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContex...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 c...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_TRUE)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_09_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_10_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_10_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalTrue)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCry...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKe...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalTrue)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0';    ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_10_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_11_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_11_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrue())     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireCont...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                ...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrue())     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_11_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_12_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_12_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrueOrFalse())     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the st...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalReturnsTrueOrFalse())     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_12_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_12_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_13_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_13_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FIVE==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireCon...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                ...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(GLOBAL_CONST_FIVE==5)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_13_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_14_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_14_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalFive==5)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&h...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 crypto...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     if(globalFive==5)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0'; ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_14_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_15_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_15_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     switch(6)     {     case 6:         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (crypt...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     switch(6)     {     case 6:     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     break;     default:         /* INC...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_15_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_16_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_16_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     while(1)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);         break;     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireCont...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     while(1)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0';           ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_16_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_16_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_17_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_17_bad() {     int i;     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     for(i = 0; i < 1; i++)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptA...
0	goodG2B	static void goodG2B() {     int h;     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     for(h = 0; h < 1; h++)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyL...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_17_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_17_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_18_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_18_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     goto source; source:     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, ...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     goto source; source:     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     {         HCRYPTPROV hCryptProv;         H...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_18_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_18_good() {     goodG2B(); }
1	badSource	static wchar_t * badSource(wchar_t * cryptoKey) {     if(badStatic)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     return cryptoKey; }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_21_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_21_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     badStatic = 1; /* true */     cryptoKey = badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("E...
0	goodG2B1Source	static wchar_t * goodG2B1Source(wchar_t * cryptoKey) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)  ...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     goodG2B1Static = 0; /* false */     cryptoKey = goodG2B1Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptograph...
0	goodG2B2Source	static wchar_t * goodG2B2Source(wchar_t * cryptoKey) {     if(goodG2B2Static)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     cryptoKey[cryptoKeyLen-1] = L'\0';                 }             }         }     }     return cryptoKe...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     goodG2B2Static = 1; /* true */     cryptoKey = goodG2B2Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographi...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_21_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_badGlobal = 1; /* true */     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCrypt...
0	goodG2B1	static void goodG2B1() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B1Global = 0; /* false */     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B1Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV,...
0	goodG2B2	static void goodG2B2() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B2Global = 1; /* true */     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B2Source(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_badSource	wchar_t * CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_badSource(wchar_t * cryptoKey) {     if(CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_badGlobal)     {         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);     }     return cryptoKey; }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B1Source	wchar_t * CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B1Source(wchar_t * cryptoKey) {     if(CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fget...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B2Source	wchar_t * CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B2Source(wchar_t * cryptoKey) {     if(CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_22_goodG2B2Global)     {         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);                 if (cryptoKeyLen > 0)                 {                     crypt...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_31_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_31_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     {         wchar_t * cryptoKeyCopy = cryptoKey;         wchar_t * cryptoKey = cryptoKeyCopy;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             wchar_t toBeEncrypted[] = L"String to be encrypted";             DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypted, toBeEncrypted, encryptedLen);             /* Try to get a context with and without a new key set */             if(!CryptAcquireContext(&hCry...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     {         wchar_t * cryptoKeyCopy = cryptoKey;         wchar_t * cr...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_31_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_31_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_32_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_32_bad() {     wchar_t * cryptoKey;     wchar_t * *cryptoKeyPtr1 = &cryptoKey;     wchar_t * *cryptoKeyPtr2 = &cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         wchar_t * cryptoKey = *cryptoKeyPtr1;         /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */         wcscpy(cryptoKey, CRYPTO_KEY);         *cryptoKeyPtr1 = cryptoKey;     }     {         wchar_t * cryptoKey = *cryptoKeyPtr2;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             wchar_t toBeEncrypted[] = L"String to be encrypted";             DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypte...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t * *cryptoKeyPtr1 = &cryptoKey;     wchar_t * *cryptoKeyPtr2 = &cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         wchar_t * cryptoKey = *cryptoKeyPtr1;         {             size_t cryptoKeyLen = wcslen(cryptoKey);             /* if there is room in cryptoKey, read into it from the console */             if(100-cryptoKeyLen > 1)             {                 /* FIX: Obtain the hash input from the console */                 if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)                 {                     printLine("fgetws() failed");                     /* Restore NUL terminator if fgetws fails */                     cryptoKey[cryptoKeyLen] = L'\0';                 }                 /* The next 3 lines remove the carriage return from the string that is                  * inserted by fgetws() */                 cryptoKeyLen = wcslen(cryptoKey);   ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_32_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_32_good() {     goodG2B(); }
1	bad	void bad() {     wchar_t * cryptoKey;     wchar_t * &cryptoKeyRef = cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     {         wchar_t * cryptoKey = cryptoKeyRef;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             wchar_t toBeEncrypted[] = L"String to be encrypted";             DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypted, toBeEncrypted, encryptedLen);             /* Try to get a context with and without a new key set */             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))        ...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t * &cryptoKeyRef = cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     {         wchar_t * crypto...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_34_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_34_bad() {     wchar_t * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_34_unionType myUnion;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     myUnion.unionFirst = cryptoKey;     {         wchar_t * cryptoKey = myUnion.unionSecond;         {             HCRYPTPROV hCryptProv;             HCRYPTKEY hKey;             HCRYPTHASH hHash;             wchar_t toBeEncrypted[] = L"String to be encrypted";             DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);             BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */             /* Copy plaintext (without NUL terminator) into byte buffer */             memcpy(encrypted, toBeEncrypted, encryptedLen);             /* Try to get a context wit...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_34_unionType myUnion;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }   ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_34_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_34_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_badSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptC...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_goodG2BSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Cr...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_goodG2BSink(cry...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_41_good() {     goodG2B(); }
1	badSource	static wchar_t * badSource(wchar_t * cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     return cryptoKey; }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_42_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_42_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     cryptoKey = badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographi...
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * cryptoKey) {     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     return cryptoKey; }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     cryptoKey = goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_42_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_42_good() {     goodG2B(); }
1	badSource	static void badSource(wchar_t * &cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY); }
1	bad	void bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }   ...
0	goodG2BSource	static void goodG2BSource(wchar_t * &cryptoKey) {     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     } }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);            ...
1	badSink	static void badSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hH...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_44_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_44_bad() {     wchar_t * cryptoKey;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     /* use the function pointer */     funcPtr(cryptoKey); }
0	goodG2BSink	static void goodG2BSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0,...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     void (*funcPtr) (wchar_t *) = goodG2BSink;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     funcPtr(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_44_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     wchar_t * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_badData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handl...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_badData = cryptoKey;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_goodG2BData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Ha...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_goodG2BData = c...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_45_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51b_goodG2BSink(cr...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51b_badSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Crypt...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_51b_goodG2BSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!C...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52b_goodG2BSink(cr...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52b_badSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52c_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52b_goodG2BSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52c_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52c_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52c_badSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Crypt...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52c_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_52c_goodG2BSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!C...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53b_goodG2BSink(cr...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53b_badSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53c_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53b_goodG2BSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53c_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53c_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53c_badSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53d_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53c_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53c_goodG2BSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53d_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53d_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53d_badSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Crypt...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53d_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_53d_goodG2BSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!C...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54b_badSink(cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54b_goodG2BSink(cr...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54b_badSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54c_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54b_goodG2BSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54c_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54c_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54c_badSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54d_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54c_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54c_goodG2BSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54d_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54d_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54d_badSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54e_badSink(cryptoKey); }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54d_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54d_goodG2BSink(wchar_t * cryptoKey) {     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54e_goodG2BSink(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54e_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54e_badSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Crypt...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54e_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_54e_goodG2BSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!C...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61b_badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {      ...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61b_goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquir...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61b_badSource	wchar_t * CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61b_badSource(wchar_t * cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     return cryptoKey; }
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61b_goodG2BSource	wchar_t * CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_61b_goodG2BSource(wchar_t * cryptoKey) {     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     return cryptoKey; }
1	bad	void bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     badSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }   ...
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     goodG2BSource(cryptoKey);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);            ...
1	badSource	void badSource(wchar_t * &cryptoKey) {     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY); }
0	goodG2BSource	void goodG2BSource(wchar_t * &cryptoKey) {     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     } }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63b_badSink(&cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63b_goodG2BSink(&c...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63b_badSink(wchar_t * * cryptoKeyPtr) {     wchar_t * cryptoKey = *cryptoKeyPtr;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }     ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_63b_goodG2BSink(wchar_t * * cryptoKeyPtr) {     wchar_t * cryptoKey = *cryptoKeyPtr;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         } ...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64b_badSink(&cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64b_goodG2BSink(&c...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64b_badSink(void * cryptoKeyVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * cryptoKeyPtr = (wchar_t * *)cryptoKeyVoidPtr;     /* dereference cryptoKeyPtr into cryptoKey */     wchar_t * cryptoKey = (*cryptoKeyPtr);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCE...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_64b_goodG2BSink(void * cryptoKeyVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * cryptoKeyPtr = (wchar_t * *)cryptoKeyVoidPtr;     /* dereference cryptoKeyPtr into cryptoKey */     wchar_t * cryptoKey = (*cryptoKeyPtr);     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65_bad() {     wchar_t * cryptoKey;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65b_badSink;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     /* use the function pointer */     funcPtr(cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     void (*funcPtr) (wchar_t *) = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65b_goodG2BSink;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';  ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65b_badSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Crypt...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_65b_goodG2BSink(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!C...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66_bad() {     wchar_t * cryptoKey;     wchar_t * cryptoKeyArray[5];     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     /* put cryptoKey in array */     cryptoKeyArray[2] = cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66b_badSink(cryptoKeyArray); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t * cryptoKeyArray[5];     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     cryptoKeyArray[2] = cryptoKey;    ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66b_badSink(wchar_t * cryptoKeyArray[]) {     /* copy cryptoKey out of cryptoKeyArray */     wchar_t * cryptoKey = cryptoKeyArray[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context"); ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_66b_goodG2BSink(wchar_t * cryptoKeyArray[]) {     wchar_t * cryptoKey = cryptoKeyArray[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }     ...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_bad() {     wchar_t * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_structType myStruct;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     myStruct.structFirst = cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_structType myStruct;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         } ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67b_badSink(CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_structType myStruct) {     wchar_t * cryptoKey = myStruct.structFirst;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67b_goodG2BSink(CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_67_structType myStruct) {     wchar_t * cryptoKey = myStruct.structFirst;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic contex...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_bad	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_badData = cryptoKey;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68b_badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_goodG2BData = c...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_good	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_good() {     goodG2B(); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68b_badSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68b_badSink() {     wchar_t * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_badData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);       ...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68b_goodG2BSink	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68b_goodG2BSink() {     wchar_t * cryptoKey = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_68_goodG2BData;     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1)...
1	bad	void bad() {     wchar_t * cryptoKey;     vector<wchar_t *> cryptoKeyVector;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     /* Put cryptoKey in a vector */     cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);     cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);     cryptoKeyVector.insert(cryptoKeyVector.end(), 1, cryptoKey);     badSink(cryptoKeyVector); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     vector<wchar_t *> cryptoKeyVector;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     /* Put cryptoKey in a vector...
1	badSink	void badSink(vector<wchar_t *> cryptoKeyVector) {     /* copy cryptoKey out of cryptoKeyVector */     wchar_t * cryptoKey = cryptoKeyVector[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }      ...
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> cryptoKeyVector) {     wchar_t * cryptoKey = cryptoKeyVector[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */       ...
1	bad	void bad() {     wchar_t * cryptoKey;     list<wchar_t *> cryptoKeyList;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     /* Put cryptoKey in a list */     cryptoKeyList.push_back(cryptoKey);     cryptoKeyList.push_back(cryptoKey);     cryptoKeyList.push_back(cryptoKey);     badSink(cryptoKeyList); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     list<wchar_t *> cryptoKeyList;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     /* Put cryptoKey in a list */   ...
1	badSink	void badSink(list<wchar_t *> cryptoKeyList) {     /* copy cryptoKey out of cryptoKeyList */     wchar_t * cryptoKey = cryptoKeyList.back();     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }...
0	goodG2BSink	void goodG2BSink(list<wchar_t *> cryptoKeyList) {     wchar_t * cryptoKey = cryptoKeyList.back();     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         ...
1	bad	void bad() {     wchar_t * cryptoKey;     map<int, wchar_t *> cryptoKeyMap;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     /* Put cryptoKey in a map */     cryptoKeyMap[0] = cryptoKey;     cryptoKeyMap[1] = cryptoKey;     cryptoKeyMap[2] = cryptoKey;     badSink(cryptoKeyMap); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     map<int, wchar_t *> cryptoKeyMap;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     /* Put cryptoKey in a map */ ...
1	badSink	void badSink(map<int, wchar_t *> cryptoKeyMap) {     /* copy cryptoKey out of cryptoKeyMap */     wchar_t * cryptoKey = cryptoKeyMap[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }   ...
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> cryptoKeyMap) {     wchar_t * cryptoKey = cryptoKeyMap[2];     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_81_bad::action(wchar_t * cryptoKey) const {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         ...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_81_goodG2B::action(wchar_t * cryptoKey) const {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */     ...
1	bad	void bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     const CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_81_base& baseObject = CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_81_bad();     baseObject.action(cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     const CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_81_base& bas...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_82_bad::action(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if(!Cr...
0	action	void CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_82_goodG2B::action(wchar_t * cryptoKey) {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Hash handle */         if...
1	bad	void bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY);     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_82_base* baseObject = new CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_82_bad;     baseObject->action(cryptoKey);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     }     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_82_base* baseObjec...
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_bad::CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_bad(wchar_t * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY); }
1	~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_bad::~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_bad() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Has...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_goodG2B::CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_goodG2B(wchar_t * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     } }
0	~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_goodG2B::~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_goodG2B() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Cr...
1	bad	void bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_bad badObject(cryptoKey); }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_83_goodG2B goodG2BObject(cryptoKey); }
1	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad::CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad(wchar_t * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     /* FLAW: Use a hardcoded value for the hash input causing a hardcoded crypto key in the sink */     wcscpy(cryptoKey, CRYPTO_KEY); }
1	~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad::~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Create Has...
0	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B::CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B(wchar_t * cryptoKeyCopy) {     cryptoKey = cryptoKeyCopy;     {         size_t cryptoKeyLen = wcslen(cryptoKey);         /* if there is room in cryptoKey, read into it from the console */         if(100-cryptoKeyLen > 1)         {             /* FIX: Obtain the hash input from the console */             if (fgetws(cryptoKey+cryptoKeyLen, (int)(100-cryptoKeyLen), stdin) == NULL)             {                 printLine("fgetws() failed");                 /* Restore NUL terminator if fgetws fails */                 cryptoKey[cryptoKeyLen] = L'\0';             }             /* The next 3 lines remove the carriage return from the string that is              * inserted by fgetws() */             cryptoKeyLen = wcslen(cryptoKey);             if (cryptoKeyLen > 0)             {                 cryptoKey[cryptoKeyLen-1] = L'\0';             }         }     } }
0	~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B	CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B::~CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B() {     {         HCRYPTPROV hCryptProv;         HCRYPTKEY hKey;         HCRYPTHASH hHash;         wchar_t toBeEncrypted[] = L"String to be encrypted";         DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t);         BYTE encrypted[200];    /* buffer should be larger than toBeEncrypted to have room for IV and padding */         /* Copy plaintext (without NUL terminator) into byte buffer */         memcpy(encrypted, toBeEncrypted, encryptedLen);         /* Try to get a context with and without a new key set */         if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, 0))         {             if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET))             {                 printLine("Error in acquiring cryptographic context");                 exit(1);             }         }         /* Cr...
1	bad	void bad() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad * badObject = new CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_bad(cryptoKey);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * cryptoKey;     wchar_t cryptoKeyBuffer[100] = L"";     cryptoKey = cryptoKeyBuffer;     CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B * goodG2BObject =  new CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_84_goodG2B(cryptoKey);     delete goodG2BObject; }
0	action	virtual void action(wchar_t * cryptoKey) const = 0;