1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;         ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;      ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = A...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family =...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = A...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family =...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_f...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;      ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.si...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_po...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRESS);                 service.sin_port = hton...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 ser...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct ...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service....
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)       ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)     ...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSink	static void badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = i...
0	goodG2BSink	static void goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_51b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52c_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_52c_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54e_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_54e_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (stru...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)            ...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_badSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));            ...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_65b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port ...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             servic...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (stru...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct s...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struc...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_81_bad::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_81_goodG2B::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_bad::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_goodG2B::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);     ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);     ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;         ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;      ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = A...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family =...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = A...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family =...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_f...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_IN...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;      ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.si...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_po...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRESS);                 service.sin_port = hton...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 ser...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct ...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service....
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)       ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)     ...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = i...
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (stru...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)            ...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));            ...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port ...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             servic...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (stru...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct s...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struc...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);     ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);     ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;        ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;     ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_I...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_I...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             servic...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;     ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.s...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_p...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRESS);                 service.sin_port = hton...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 s...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct ...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             servic...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)       ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)     ...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = ...
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (str...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)            ...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));          ...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             serv...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (stru...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct s...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struc...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);   ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);   ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;        ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;     ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_I...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_I...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             servic...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;     ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.s...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_p...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = inet_addr(IP_ADDRESS);                 service.sin_port = hton...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 s...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET connectSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a connect socket */                 connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (connectSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct ...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             servic...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)       ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)     ...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = ...
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (str...
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)            ...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));          ...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             serv...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);   ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (stru...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct s...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struc...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);             service.sin_port = htons(TCP_PORT);             if (connect(connectSocket, (struct sockaddr*)&service, sizeo...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);   ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET connectSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a connect socket */             connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (connectSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = inet_addr(IP_ADDRESS);   ...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_01_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';  ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */    ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */ ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with d...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuff...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something wit...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataB...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with d...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuff...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */    ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something wit...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataB...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * data...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do some...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dat...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_badGlobal)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_31_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);  ...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (c...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSink	static void badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52c_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_52c_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53d_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_53d_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61b_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61b_goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61b_badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSource	void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_badSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65b_badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_65b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_bad::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_goodG2B::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_82_bad::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_82_goodG2B::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_01_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */       ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL termin...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */ ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL ter...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL term...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL termin...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */ ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL term...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion cou...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL ter...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a v...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL term...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /*...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badGlobal)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_31_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,        ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a ...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61b_badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_01_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */        ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */     ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL term...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate *...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL t...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminat...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL te...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL term...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate *...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL te...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion co...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL t...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminat...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL te...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; ...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badGlobal)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_31_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,       ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(des...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in ...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_01_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not alw...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy()...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does n...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncp...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() doe...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy()...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does n...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion co...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncp...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() doe...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; ...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(de...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badGlobal)     {         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         {             char inputBuffer[CHAR_ARRAY_SIZE] = "";             /* POTENTIAL FLAW: Read data from the console using fgets() */             if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)             {                 /* Convert to int */                 data = atoi(inputBuffer);             }             else             {                 printLine("fgets() failed.");             }         }         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,       ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in ...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61b_badSource(int data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65b_badSink;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     }     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad(int dataCopy) {     data = dataCopy;     {         char inputBuffer[CHAR_ARRAY_SIZE] = "";         /* POTENTIAL FLAW: Read data from the console using fgets() */         if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)         {             /* Convert to int */             data = atoi(inputBuffer);         }         else         {             printLine("fgets() failed.");         }     } }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dat...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuff...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSink	static void badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53d_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53d_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54e_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54e_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b_goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b_badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_badSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_68_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_81_bad::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_81_goodG2B::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_82_bad::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_82_goodG2B::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badGlobal)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_badGlobal)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b_badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_badGlobal)     {         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Read data from the console using fscanf() */         fscanf(stdin, "%d", &data);         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61b_badSource(int data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data);     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Read data from the console using fscanf() */     fscanf(stdin, "%d", &data); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));          ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));       ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(serv...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)); ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(se...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(serv...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)); ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(se...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, si...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = I...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));       ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0,...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_A...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = INADDR_ANY;     ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&servi...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;        ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.si...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(servic...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(se...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSink	static void badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET...
0	goodG2BSink	static void goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52c_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_52c_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53d_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_53d_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54e_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_54e_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61b_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61b_goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service))...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&s...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service....
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_68_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (:...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_bad::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_goodG2B::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_82_bad::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_82_goodG2B::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_a...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_a...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));          ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));       ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(serv...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)); ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(se...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(serv...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)); ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(se...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, si...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service)...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = I...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));       ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0,...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_A...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = INADDR_ANY;     ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&servi...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;        ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.si...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(servic...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(se...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET...
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service))...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&s...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service....
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (:...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_a...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_a...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));         ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));      ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(ser...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(ser...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));      ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = INADDR_ANY;     ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&ser...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;       ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service....
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(servic...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(se...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INE...
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             i...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service))...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             servic...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (:...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_01_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));         ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));      ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(ser...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(ser...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(s...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, s...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = ...
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));      ...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0...
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&service, 0, sizeof(service));                 service.sin_family = AF_INET;                 service.sin_addr.s_addr = INADDR_ANY;     ...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badGlobal)     {         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;                 }                 memset(&ser...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_31_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         { #ifdef _WIN32             WSADATA wsaData;             int wsaDataInit = 0; #endif             int recvResult;             struct sockaddr_in service;             SOCKET listenSocket = INVALID_SOCKET;             SOCKET acceptSocket = INVALID_SOCKET;             char inputBuffer[CHAR_ARRAY_SIZE];             do             { #ifdef _WIN32                 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)                 {                     break;                 }                 wsaDataInit = 1; #endif                 /* POTENTIAL FLAW: Read data using a listen socket */                 listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);                 if (listenSocket == INVALID_SOCKET)                 {                     break;       ...
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (...
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service....
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (bind(listenSocket, (struct sockaddr*)&service, sizeof(servic...
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(se...
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INE...
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61b_badSource(int data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             i...
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (struct sockaddr*)&service, sizeof(service))...
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_badSink;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(...
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY...
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             servic...
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68_bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service....
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             i...
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (:...
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if...
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin_addr.s_addr = INADDR_ANY;             service.sin_port = htons(TCP_PORT);             if (::bind(listenSocket, (str...
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad(int dataCopy) {     data = dataCopy;     { #ifdef _WIN32         WSADATA wsaData;         int wsaDataInit = 0; #endif         int recvResult;         struct sockaddr_in service;         SOCKET listenSocket = INVALID_SOCKET;         SOCKET acceptSocket = INVALID_SOCKET;         char inputBuffer[CHAR_ARRAY_SIZE];         do         { #ifdef _WIN32             if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)             {                 break;             }             wsaDataInit = 1; #endif             /* POTENTIAL FLAW: Read data using a listen socket */             listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);             if (listenSocket == INVALID_SOCKET)             {                 break;             }             memset(&service, 0, sizeof(service));             service.sin_family = AF_INET;             service.sin...
1	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_01_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FLAW: Use a negative number */         data = -1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FLAW: Use a negative number */         data = -1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FLAW: Use a negative number */         data = -1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* FLAW: Use a negative number */         data = -1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FLAW: Use a negative number */     data = -1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_badGlobal)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_31_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FLAW: Use a negative number */         data = -1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSink	static void badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_51b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52c_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_52c_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53d_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_53d_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54e_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_54e_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61b_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61b_goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61b_badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSource	void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63b_badSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65b_badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_65b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_68_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_81_bad::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_81_goodG2B::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_82_bad::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_82_goodG2B::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__negative_malloc_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_01_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FLAW: Use a negative number */         data = -1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FLAW: Use a negative number */         data = -1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FLAW: Use a negative number */         data = -1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FLAW: Use a negative number */     data = -1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badGlobal)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_31_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FLAW: Use a negative number */         data = -1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61b_badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65b_badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_01_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FLAW: Use a negative number */         data = -1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FLAW: Use a negative number */         data = -1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FLAW: Use a negative number */         data = -1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FLAW: Use a negative number */     data = -1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_badGlobal)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_31_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FLAW: Use a negative number */         data = -1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61b_badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65b_badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_01_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FLAW: Use a negative number */         data = -1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FLAW: Use a negative number */         data = -1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FLAW: Use a negative number */         data = -1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* FLAW: Use a negative number */         data = -1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FLAW: Use a negative number */     data = -1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badGlobal)     {         /* FLAW: Use a negative number */         data = -1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FLAW: Use a negative number */         data = -1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61b_badSource(int data) {     /* FLAW: Use a negative number */     data = -1;     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* FLAW: Use a negative number */     data = -1; }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_badSink;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* FLAW: Use a negative number */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad(int dataCopy) {     data = dataCopy;     /* FLAW: Use a negative number */     data = -1; }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B1Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B2Source(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         /* Assume we want to allocate a relatively small buffer */         if (data < 100)         {             /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,              * the conversion will cause malloc() to allocate a very large amount of data or fail */             char * dataBuffer = (char *)malloc(data);             if (dataBuffer == NULL) {exit(-1);}             /* Do something with dataBuffer */             memset(dataBuffer, 'A', data-1);             dataBuffer[data-1] = '\0';             printLine(dataBuffer);             free(dataBuffer);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSink	static void badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_51b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52c_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_52c_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53d_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_53d_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54e_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_54e_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61b_badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61b_goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61b_badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63b_badSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65b_badSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_65b_goodG2BSink(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_67_structType myStruct) {     int data = myStruct.structFirst;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_badData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_68_goodG2BData;     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_81_bad::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_81_goodG2B::action(int data) const {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_82_bad::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_82_goodG2B::action(int data) {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B() {     /* Assume we want to allocate a relatively small buffer */     if (data < 100)     {         /* POTENTIAL FLAW: malloc() takes a size_t (unsigned int) as input and therefore if it is negative,          * the conversion will cause malloc() to allocate a very large amount of data or fail */         char * dataBuffer = (char *)malloc(data);         if (dataBuffer == NULL) {exit(-1);}         /* Do something with dataBuffer */         memset(dataBuffer, 'A', data-1);         dataBuffer[data-1] = '\0';         printLine(dataBuffer);         free(dataBuffer);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badGlobal)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memcpy(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61b_badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memcpy(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_badGlobal)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 memmove(dest, source, data);                 dest[data] = '\0'; /* NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61b_badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             memmove(dest, source, data);             dest[data] = '\0'; /* NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B(data);     delete goodG2BObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_01_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_01_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_01_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_01_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_02_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_02_bad() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_02_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_02_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03_bad() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(5==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_04_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_04_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_04_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_04_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_05_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_05_bad() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_05_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_05_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_06_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_06_bad() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_06_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_06_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_07_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_07_bad() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_07_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_07_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_08_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_08_bad() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(staticReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_08_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_08_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_09_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_09_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_09_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_09_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_10_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_10_bad() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalTrue)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_10_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_10_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrue())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_12_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_12_bad() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_12_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_12_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_13_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_13_bad() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_13_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_13_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_14_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_14_bad() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     if(globalFive==5)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_14_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_14_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_15_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_15_bad() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     switch(6)     {     case 6:         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_15_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_15_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_16_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_16_bad() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     while(1)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         break;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_16_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_16_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_17_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_17_bad() {     int i;     int data;     /* Initialize data */     data = -1;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int h;     int data;     /* Initialize data */     data = -1;     for(h = 0; h < 1; h++)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_17_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_17_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_18_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_18_bad() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goto source; source:     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_18_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_18_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     if(badStatic)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_21_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_21_bad() {     int data;     /* Initialize data */     data = -1;     badStatic = 1; /* true */     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1Source	static int goodG2B1Source(int data) {     if(goodG2B1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     goodG2B1Static = 0; /* false */     data = goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2Source	static int goodG2B2Source(int data) {     if(goodG2B2Static)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     goodG2B2Static = 1; /* true */     data = goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_21_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_21_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_badGlobal = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B1	static void goodG2B1() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B1Global = 0; /* false */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B1Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B2	static void goodG2B2() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B2Global = 1; /* true */     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B2Source(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_good() {     goodG2B1();     goodG2B2(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_badSource(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_badGlobal)     {         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B1Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B1Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B2Source	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B2Source(int data) {     if(CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_22_goodG2B2Global)     {         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;     }     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_31_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_31_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int dataCopy = data;         int data = dataCopy;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_31_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_31_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_32_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_32_bad() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* POTENTIAL FLAW: Set data to a random value */         data = RAND32();         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int *dataPtr1 = &data;     int *dataPtr2 = &data;     /* Initialize data */     data = -1;     {         int data = *dataPtr1;         /* FIX: Use a positive integer less than &InitialDataSize&*/         data = 100-1;         *dataPtr1 = data;     }     {         int data = *dataPtr2;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_32_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_32_good() {     goodG2B(); }
1	bad	void bad() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     int &dataRef = data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     {         int data = dataRef;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_34_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_34_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_34_unionType myUnion;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myUnion.unionFirst = data;     {         int data = myUnion.unionSecond;         {             char source[100];             char dest[100] = "";             memset(source, 'A', 100-1);             source[100-1] = '\0';             if (data < 100)             {                 /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,                  * the sign conversion could result in a very large number */                 strncpy(dest, source, data);                 dest[data] = '\0'; /* strncpy() does not always NULL terminate */             }             printLine(dest);         }     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_34_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_34_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_41_good() {     goodG2B(); }
1	badSource	static int badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42_bad() {     int data;     /* Initialize data */     data = -1;     data = badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static int goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42_good() {     goodG2B(); }
1	badSource	static void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSource	static void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSink	static void badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_44_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_44_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_44_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_44_good() {     goodG2B(); }
1	badSink	static void badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_goodG2BData = data;     goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_45_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_51b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52c_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_52c_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53d_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_53d_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54b_goodG2BSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54b_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54c_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54b_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54c_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54c_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54c_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54d_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54c_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54c_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54d_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54d_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54d_badSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_badSink(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54d_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54d_goodG2BSink(int data) {     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_goodG2BSink(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61_bad() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61b_badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61b_goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61b_badSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61b_badSource(int data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     return data; }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61b_goodG2BSource	int CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_61b_goodG2BSource(int data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     return data; }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     badSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     goodG2BSource(data);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	badSource	void badSource(int &data) {     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
0	goodG2BSource	void goodG2BSource(int &data) {     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63b_badSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_63b_goodG2BSink(int * dataPtr) {     int data = *dataPtr;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64b_goodG2BSink(&data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * dataPtr = (int *)dataVoidPtr;     /* dereference dataPtr into data */     int data = (*dataPtr);     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65_bad() {     int data;     /* define a function pointer */     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65b_badSink;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int data;     void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65b_goodG2BSink;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     funcPtr(data); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65b_badSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_65b_goodG2BSink(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66_bad() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* put data in array */     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int data;     int dataArray[5];     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     dataArray[2] = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66b_goodG2BSink(dataArray); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66b_badSink(int dataArray[]) {     /* copy data out of dataArray */     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_66b_goodG2BSink(int dataArray[]) {     int data = dataArray[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_bad() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_structType myStruct;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     myStruct.structFirst = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67b_goodG2BSink(myStruct); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_67_structType myStruct) {     int data = myStruct.structFirst;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_bad	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_badData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_goodG2BData = data;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68b_goodG2BSink(); }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_good	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_good() {     goodG2B(); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68b_badSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68b_badSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_badData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68b_goodG2BSink	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68b_goodG2BSink() {     int data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_68_goodG2BData;     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int data;     vector<int> dataVector;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
1	badSink	void badSink(vector<int> dataVector) {     /* copy data out of dataVector */     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(vector<int> dataVector) {     int data = dataVector[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int data;     list<int> dataList;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
1	badSink	void badSink(list<int> dataList) {     /* copy data out of dataList */     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(list<int> dataList) {     int data = dataList.back();     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int data;     map<int, int> dataMap;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
1	badSink	void badSink(map<int, int> dataMap) {     /* copy data out of dataMap */     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	goodG2BSink	void goodG2BSink(map<int, int> dataMap) {     int data = dataMap[2];     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_81_bad::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_81_goodG2B::action(int data) const {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     const CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_81_goodG2B();     baseObject.action(data); }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_bad::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	action	void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_goodG2B::action(int data) {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32();     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_goodG2B;     baseObject->action(data);     delete baseObject; }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_83_goodG2B goodG2BObject(data); }
1	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad(int dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Set data to a random value */     data = RAND32(); }
1	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
0	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B::CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B(int dataCopy) {     data = dataCopy;     /* FIX: Use a positive integer less than &InitialDataSize&*/     data = 100-1; }
0	~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B	CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B() {     {         char source[100];         char dest[100] = "";         memset(source, 'A', 100-1);         source[100-1] = '\0';         if (data < 100)         {             /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative,              * the sign conversion could result in a very large number */             strncpy(dest, source, data);             dest[data] = '\0'; /* strncpy() does not always NULL terminate */         }         printLine(dest);     } }
1	bad	void bad() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad * badObject = new CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int data;     /* Initialize data */     data = -1;     CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B * goodG2BObject =  new CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_84_goodG2B(data);     delete goodG2BObject; }