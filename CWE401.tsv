1	CWE401_Memory_Leak__char_calloc_01_bad	void CWE401_Memory_Leak__char_calloc_01_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_calloc_01_good	void CWE401_Memory_Leak__char_calloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_02_bad	void CWE401_Memory_Leak__char_calloc_02_bad() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_02_good	void CWE401_Memory_Leak__char_calloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_03_bad	void CWE401_Memory_Leak__char_calloc_03_bad() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_03_good	void CWE401_Memory_Leak__char_calloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_04_bad	void CWE401_Memory_Leak__char_calloc_04_bad() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_04_good	void CWE401_Memory_Leak__char_calloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_05_bad	void CWE401_Memory_Leak__char_calloc_05_bad() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_05_good	void CWE401_Memory_Leak__char_calloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_06_bad	void CWE401_Memory_Leak__char_calloc_06_bad() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_06_good	void CWE401_Memory_Leak__char_calloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_07_bad	void CWE401_Memory_Leak__char_calloc_07_bad() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_07_good	void CWE401_Memory_Leak__char_calloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_08_bad	void CWE401_Memory_Leak__char_calloc_08_bad() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_08_good	void CWE401_Memory_Leak__char_calloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_09_bad	void CWE401_Memory_Leak__char_calloc_09_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_09_good	void CWE401_Memory_Leak__char_calloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_10_bad	void CWE401_Memory_Leak__char_calloc_10_bad() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_10_good	void CWE401_Memory_Leak__char_calloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_11_bad	void CWE401_Memory_Leak__char_calloc_11_bad() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_11_good	void CWE401_Memory_Leak__char_calloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_12_bad	void CWE401_Memory_Leak__char_calloc_12_bad() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_12_good	void CWE401_Memory_Leak__char_calloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_calloc_13_bad	void CWE401_Memory_Leak__char_calloc_13_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_13_good	void CWE401_Memory_Leak__char_calloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_14_bad	void CWE401_Memory_Leak__char_calloc_14_bad() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_14_good	void CWE401_Memory_Leak__char_calloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_15_bad	void CWE401_Memory_Leak__char_calloc_15_bad() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__char_calloc_15_good	void CWE401_Memory_Leak__char_calloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_calloc_16_bad	void CWE401_Memory_Leak__char_calloc_16_bad() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__char_calloc_16_good	void CWE401_Memory_Leak__char_calloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_calloc_17_bad	void CWE401_Memory_Leak__char_calloc_17_bad() {     int i,j;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_17_good	void CWE401_Memory_Leak__char_calloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_calloc_18_bad	void CWE401_Memory_Leak__char_calloc_18_bad() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_18_good	void CWE401_Memory_Leak__char_calloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__char_calloc_21_bad	void CWE401_Memory_Leak__char_calloc_21_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_21_good	void CWE401_Memory_Leak__char_calloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__char_calloc_22_bad	void CWE401_Memory_Leak__char_calloc_22_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__char_calloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__char_calloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__char_calloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__char_calloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_22_good	void CWE401_Memory_Leak__char_calloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__char_calloc_22_badSink	void CWE401_Memory_Leak__char_calloc_22_badSink(char * data) {     if(CWE401_Memory_Leak__char_calloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_calloc_22_goodB2G1Sink	void CWE401_Memory_Leak__char_calloc_22_goodB2G1Sink(char * data) {     if(CWE401_Memory_Leak__char_calloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_calloc_22_goodB2G2Sink	void CWE401_Memory_Leak__char_calloc_22_goodB2G2Sink(char * data) {     if(CWE401_Memory_Leak__char_calloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_calloc_22_goodG2BSink	void CWE401_Memory_Leak__char_calloc_22_goodG2BSink(char * data) {     if(CWE401_Memory_Leak__char_calloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__char_calloc_31_bad	void CWE401_Memory_Leak__char_calloc_31_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_calloc_31_good	void CWE401_Memory_Leak__char_calloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_32_bad	void CWE401_Memory_Leak__char_calloc_32_bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)calloc(100, sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_calloc_32_good	void CWE401_Memory_Leak__char_calloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__char_calloc_34_bad	void CWE401_Memory_Leak__char_calloc_34_bad() {     char * data;     CWE401_Memory_Leak__char_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__char_calloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__char_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_calloc_34_good	void CWE401_Memory_Leak__char_calloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_calloc_41_bad	void CWE401_Memory_Leak__char_calloc_41_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink(data); }
0	CWE401_Memory_Leak__char_calloc_41_good	void CWE401_Memory_Leak__char_calloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static char * badSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
1	CWE401_Memory_Leak__char_calloc_42_bad	void CWE401_Memory_Leak__char_calloc_42_bad() {     char * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static char * goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static char * goodB2GSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_calloc_42_good	void CWE401_Memory_Leak__char_calloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_calloc_44_bad	void CWE401_Memory_Leak__char_calloc_44_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__char_calloc_44_good	void CWE401_Memory_Leak__char_calloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     char * data = CWE401_Memory_Leak__char_calloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_calloc_45_bad	void CWE401_Memory_Leak__char_calloc_45_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = CWE401_Memory_Leak__char_calloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = CWE401_Memory_Leak__char_calloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__char_calloc_45_good	void CWE401_Memory_Leak__char_calloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_51_bad	void CWE401_Memory_Leak__char_calloc_51_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_calloc_51_good	void CWE401_Memory_Leak__char_calloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_51b_badSink	void CWE401_Memory_Leak__char_calloc_51b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_51b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_51b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_51b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_51b_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_52_bad	void CWE401_Memory_Leak__char_calloc_52_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_calloc_52_good	void CWE401_Memory_Leak__char_calloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_52b_badSink	void CWE401_Memory_Leak__char_calloc_52b_badSink(char * data) {     CWE401_Memory_Leak__char_calloc_52c_badSink(data); }
0	CWE401_Memory_Leak__char_calloc_52b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_52b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_calloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_52b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_52b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_calloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_calloc_52c_badSink	void CWE401_Memory_Leak__char_calloc_52c_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_52c_goodG2BSink	void CWE401_Memory_Leak__char_calloc_52c_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_52c_goodB2GSink	void CWE401_Memory_Leak__char_calloc_52c_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_53_bad	void CWE401_Memory_Leak__char_calloc_53_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_calloc_53_good	void CWE401_Memory_Leak__char_calloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_53b_badSink	void CWE401_Memory_Leak__char_calloc_53b_badSink(char * data) {     CWE401_Memory_Leak__char_calloc_53c_badSink(data); }
0	CWE401_Memory_Leak__char_calloc_53b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_53b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_calloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_53b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_53b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_calloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_calloc_53c_badSink	void CWE401_Memory_Leak__char_calloc_53c_badSink(char * data) {     CWE401_Memory_Leak__char_calloc_53d_badSink(data); }
0	CWE401_Memory_Leak__char_calloc_53c_goodG2BSink	void CWE401_Memory_Leak__char_calloc_53c_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_calloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_53c_goodB2GSink	void CWE401_Memory_Leak__char_calloc_53c_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_calloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_calloc_53d_badSink	void CWE401_Memory_Leak__char_calloc_53d_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_53d_goodG2BSink	void CWE401_Memory_Leak__char_calloc_53d_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_53d_goodB2GSink	void CWE401_Memory_Leak__char_calloc_53d_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_54_bad	void CWE401_Memory_Leak__char_calloc_54_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_calloc_54_good	void CWE401_Memory_Leak__char_calloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_54b_badSink	void CWE401_Memory_Leak__char_calloc_54b_badSink(char * data) {     CWE401_Memory_Leak__char_calloc_54c_badSink(data); }
0	CWE401_Memory_Leak__char_calloc_54b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_54b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_calloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_54b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_54b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_calloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_calloc_54c_badSink	void CWE401_Memory_Leak__char_calloc_54c_badSink(char * data) {     CWE401_Memory_Leak__char_calloc_54d_badSink(data); }
0	CWE401_Memory_Leak__char_calloc_54c_goodG2BSink	void CWE401_Memory_Leak__char_calloc_54c_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_calloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_54c_goodB2GSink	void CWE401_Memory_Leak__char_calloc_54c_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_calloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_calloc_54d_badSink	void CWE401_Memory_Leak__char_calloc_54d_badSink(char * data) {     CWE401_Memory_Leak__char_calloc_54e_badSink(data); }
0	CWE401_Memory_Leak__char_calloc_54d_goodG2BSink	void CWE401_Memory_Leak__char_calloc_54d_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_calloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_calloc_54d_goodB2GSink	void CWE401_Memory_Leak__char_calloc_54d_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_calloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_calloc_54e_badSink	void CWE401_Memory_Leak__char_calloc_54e_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_54e_goodG2BSink	void CWE401_Memory_Leak__char_calloc_54e_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_54e_goodB2GSink	void CWE401_Memory_Leak__char_calloc_54e_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_61_bad	void CWE401_Memory_Leak__char_calloc_61_bad() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_calloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_calloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_calloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_calloc_61_good	void CWE401_Memory_Leak__char_calloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_61b_badSource	char * CWE401_Memory_Leak__char_calloc_61b_badSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	CWE401_Memory_Leak__char_calloc_61b_goodG2BSource	char * CWE401_Memory_Leak__char_calloc_61b_goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	CWE401_Memory_Leak__char_calloc_61b_goodB2GSource	char * CWE401_Memory_Leak__char_calloc_61b_goodB2GSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodG2BSource	void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodB2GSource	void goodB2GSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	CWE401_Memory_Leak__char_calloc_63_bad	void CWE401_Memory_Leak__char_calloc_63_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__char_calloc_63_good	void CWE401_Memory_Leak__char_calloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_63b_badSink	void CWE401_Memory_Leak__char_calloc_63b_badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_63b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_63b_goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_63b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_63b_goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_64_bad	void CWE401_Memory_Leak__char_calloc_64_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__char_calloc_64_good	void CWE401_Memory_Leak__char_calloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_64b_badSink	void CWE401_Memory_Leak__char_calloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_64b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_64b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_65_bad	void CWE401_Memory_Leak__char_calloc_65_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__char_calloc_65_good	void CWE401_Memory_Leak__char_calloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_65b_badSink	void CWE401_Memory_Leak__char_calloc_65b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_65b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_65b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_65b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_65b_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_66_bad	void CWE401_Memory_Leak__char_calloc_66_bad() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__char_calloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__char_calloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__char_calloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__char_calloc_66_good	void CWE401_Memory_Leak__char_calloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_66b_badSink	void CWE401_Memory_Leak__char_calloc_66b_badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_66b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_66b_goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_66b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_66b_goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_67_bad	void CWE401_Memory_Leak__char_calloc_67_bad() {     char * data;     CWE401_Memory_Leak__char_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_calloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__char_calloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_calloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__char_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_calloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__char_calloc_67_good	void CWE401_Memory_Leak__char_calloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_67b_badSink	void CWE401_Memory_Leak__char_calloc_67b_badSink(CWE401_Memory_Leak__char_calloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_67b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_67b_goodG2BSink(CWE401_Memory_Leak__char_calloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_67b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_67b_goodB2GSink(CWE401_Memory_Leak__char_calloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_calloc_68_bad	void CWE401_Memory_Leak__char_calloc_68_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_68_badData = data;     CWE401_Memory_Leak__char_calloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_68_goodG2BData = data;     CWE401_Memory_Leak__char_calloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_68_goodB2GData = data;     CWE401_Memory_Leak__char_calloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__char_calloc_68_good	void CWE401_Memory_Leak__char_calloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_calloc_68b_badSink	void CWE401_Memory_Leak__char_calloc_68b_badSink() {     char * data = CWE401_Memory_Leak__char_calloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_68b_goodG2BSink	void CWE401_Memory_Leak__char_calloc_68b_goodG2BSink() {     char * data = CWE401_Memory_Leak__char_calloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_68b_goodB2GSink	void CWE401_Memory_Leak__char_calloc_68b_goodB2GSink() {     char * data = CWE401_Memory_Leak__char_calloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_calloc_81_bad::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__char_calloc_81_goodB2G::action(char * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_calloc_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_calloc_81_base& baseObject = CWE401_Memory_Leak__char_calloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_calloc_81_base& baseObject = CWE401_Memory_Leak__char_calloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_calloc_81_base& baseObject = CWE401_Memory_Leak__char_calloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__char_calloc_82_bad::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__char_calloc_82_goodB2G::action(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_calloc_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_82_base* baseObject = new CWE401_Memory_Leak__char_calloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_82_base* baseObject = new CWE401_Memory_Leak__char_calloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_calloc_82_base* baseObject = new CWE401_Memory_Leak__char_calloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__char_calloc_83_bad	CWE401_Memory_Leak__char_calloc_83_bad::CWE401_Memory_Leak__char_calloc_83_bad(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	~CWE401_Memory_Leak__char_calloc_83_bad	CWE401_Memory_Leak__char_calloc_83_bad::~CWE401_Memory_Leak__char_calloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_83_goodB2G	CWE401_Memory_Leak__char_calloc_83_goodB2G::CWE401_Memory_Leak__char_calloc_83_goodB2G(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_calloc_83_goodB2G	CWE401_Memory_Leak__char_calloc_83_goodB2G::~CWE401_Memory_Leak__char_calloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_calloc_83_goodG2B	CWE401_Memory_Leak__char_calloc_83_goodG2B::CWE401_Memory_Leak__char_calloc_83_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_calloc_83_goodG2B	CWE401_Memory_Leak__char_calloc_83_goodG2B::~CWE401_Memory_Leak__char_calloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_calloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_calloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_calloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__char_calloc_84_bad	CWE401_Memory_Leak__char_calloc_84_bad::CWE401_Memory_Leak__char_calloc_84_bad(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	~CWE401_Memory_Leak__char_calloc_84_bad	CWE401_Memory_Leak__char_calloc_84_bad::~CWE401_Memory_Leak__char_calloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_calloc_84_goodB2G	CWE401_Memory_Leak__char_calloc_84_goodB2G::CWE401_Memory_Leak__char_calloc_84_goodB2G(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)calloc(100, sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_calloc_84_goodB2G	CWE401_Memory_Leak__char_calloc_84_goodB2G::~CWE401_Memory_Leak__char_calloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_calloc_84_goodG2B	CWE401_Memory_Leak__char_calloc_84_goodG2B::CWE401_Memory_Leak__char_calloc_84_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_calloc_84_goodG2B	CWE401_Memory_Leak__char_calloc_84_goodG2B::~CWE401_Memory_Leak__char_calloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_calloc_84_bad * badObject = new CWE401_Memory_Leak__char_calloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_calloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__char_calloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_calloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__char_calloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__char_malloc_01_bad	void CWE401_Memory_Leak__char_malloc_01_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_malloc_01_good	void CWE401_Memory_Leak__char_malloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_02_bad	void CWE401_Memory_Leak__char_malloc_02_bad() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_02_good	void CWE401_Memory_Leak__char_malloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_03_bad	void CWE401_Memory_Leak__char_malloc_03_bad() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_03_good	void CWE401_Memory_Leak__char_malloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_04_bad	void CWE401_Memory_Leak__char_malloc_04_bad() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_04_good	void CWE401_Memory_Leak__char_malloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_05_bad	void CWE401_Memory_Leak__char_malloc_05_bad() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_05_good	void CWE401_Memory_Leak__char_malloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_06_bad	void CWE401_Memory_Leak__char_malloc_06_bad() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_06_good	void CWE401_Memory_Leak__char_malloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_07_bad	void CWE401_Memory_Leak__char_malloc_07_bad() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_07_good	void CWE401_Memory_Leak__char_malloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_08_bad	void CWE401_Memory_Leak__char_malloc_08_bad() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_08_good	void CWE401_Memory_Leak__char_malloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_09_bad	void CWE401_Memory_Leak__char_malloc_09_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_09_good	void CWE401_Memory_Leak__char_malloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_10_bad	void CWE401_Memory_Leak__char_malloc_10_bad() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_10_good	void CWE401_Memory_Leak__char_malloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_11_bad	void CWE401_Memory_Leak__char_malloc_11_bad() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_11_good	void CWE401_Memory_Leak__char_malloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_12_bad	void CWE401_Memory_Leak__char_malloc_12_bad() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_12_good	void CWE401_Memory_Leak__char_malloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_malloc_13_bad	void CWE401_Memory_Leak__char_malloc_13_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_13_good	void CWE401_Memory_Leak__char_malloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_14_bad	void CWE401_Memory_Leak__char_malloc_14_bad() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_14_good	void CWE401_Memory_Leak__char_malloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_15_bad	void CWE401_Memory_Leak__char_malloc_15_bad() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__char_malloc_15_good	void CWE401_Memory_Leak__char_malloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_malloc_16_bad	void CWE401_Memory_Leak__char_malloc_16_bad() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__char_malloc_16_good	void CWE401_Memory_Leak__char_malloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_malloc_17_bad	void CWE401_Memory_Leak__char_malloc_17_bad() {     int i,j;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_17_good	void CWE401_Memory_Leak__char_malloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_malloc_18_bad	void CWE401_Memory_Leak__char_malloc_18_bad() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_18_good	void CWE401_Memory_Leak__char_malloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__char_malloc_21_bad	void CWE401_Memory_Leak__char_malloc_21_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_21_good	void CWE401_Memory_Leak__char_malloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__char_malloc_22_bad	void CWE401_Memory_Leak__char_malloc_22_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__char_malloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__char_malloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__char_malloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__char_malloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_22_good	void CWE401_Memory_Leak__char_malloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__char_malloc_22_badSink	void CWE401_Memory_Leak__char_malloc_22_badSink(char * data) {     if(CWE401_Memory_Leak__char_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_malloc_22_goodB2G1Sink	void CWE401_Memory_Leak__char_malloc_22_goodB2G1Sink(char * data) {     if(CWE401_Memory_Leak__char_malloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_malloc_22_goodB2G2Sink	void CWE401_Memory_Leak__char_malloc_22_goodB2G2Sink(char * data) {     if(CWE401_Memory_Leak__char_malloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_malloc_22_goodG2BSink	void CWE401_Memory_Leak__char_malloc_22_goodG2BSink(char * data) {     if(CWE401_Memory_Leak__char_malloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__char_malloc_31_bad	void CWE401_Memory_Leak__char_malloc_31_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_malloc_31_good	void CWE401_Memory_Leak__char_malloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_32_bad	void CWE401_Memory_Leak__char_malloc_32_bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_malloc_32_good	void CWE401_Memory_Leak__char_malloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__char_malloc_34_bad	void CWE401_Memory_Leak__char_malloc_34_bad() {     char * data;     CWE401_Memory_Leak__char_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__char_malloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__char_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_malloc_34_good	void CWE401_Memory_Leak__char_malloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_malloc_41_bad	void CWE401_Memory_Leak__char_malloc_41_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink(data); }
0	CWE401_Memory_Leak__char_malloc_41_good	void CWE401_Memory_Leak__char_malloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static char * badSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
1	CWE401_Memory_Leak__char_malloc_42_bad	void CWE401_Memory_Leak__char_malloc_42_bad() {     char * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static char * goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static char * goodB2GSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_malloc_42_good	void CWE401_Memory_Leak__char_malloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_malloc_44_bad	void CWE401_Memory_Leak__char_malloc_44_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__char_malloc_44_good	void CWE401_Memory_Leak__char_malloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     char * data = CWE401_Memory_Leak__char_malloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_malloc_45_bad	void CWE401_Memory_Leak__char_malloc_45_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = CWE401_Memory_Leak__char_malloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = CWE401_Memory_Leak__char_malloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__char_malloc_45_good	void CWE401_Memory_Leak__char_malloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_51_bad	void CWE401_Memory_Leak__char_malloc_51_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_malloc_51_good	void CWE401_Memory_Leak__char_malloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_51b_badSink	void CWE401_Memory_Leak__char_malloc_51b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_51b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_51b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_51b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_51b_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_52_bad	void CWE401_Memory_Leak__char_malloc_52_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_malloc_52_good	void CWE401_Memory_Leak__char_malloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_52b_badSink	void CWE401_Memory_Leak__char_malloc_52b_badSink(char * data) {     CWE401_Memory_Leak__char_malloc_52c_badSink(data); }
0	CWE401_Memory_Leak__char_malloc_52b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_52b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_malloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_52b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_52b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_malloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_malloc_52c_badSink	void CWE401_Memory_Leak__char_malloc_52c_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_52c_goodG2BSink	void CWE401_Memory_Leak__char_malloc_52c_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_52c_goodB2GSink	void CWE401_Memory_Leak__char_malloc_52c_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_53_bad	void CWE401_Memory_Leak__char_malloc_53_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_malloc_53_good	void CWE401_Memory_Leak__char_malloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_53b_badSink	void CWE401_Memory_Leak__char_malloc_53b_badSink(char * data) {     CWE401_Memory_Leak__char_malloc_53c_badSink(data); }
0	CWE401_Memory_Leak__char_malloc_53b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_53b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_malloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_53b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_53b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_malloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_malloc_53c_badSink	void CWE401_Memory_Leak__char_malloc_53c_badSink(char * data) {     CWE401_Memory_Leak__char_malloc_53d_badSink(data); }
0	CWE401_Memory_Leak__char_malloc_53c_goodG2BSink	void CWE401_Memory_Leak__char_malloc_53c_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_malloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_53c_goodB2GSink	void CWE401_Memory_Leak__char_malloc_53c_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_malloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_malloc_53d_badSink	void CWE401_Memory_Leak__char_malloc_53d_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_53d_goodG2BSink	void CWE401_Memory_Leak__char_malloc_53d_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_53d_goodB2GSink	void CWE401_Memory_Leak__char_malloc_53d_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_54_bad	void CWE401_Memory_Leak__char_malloc_54_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_malloc_54_good	void CWE401_Memory_Leak__char_malloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_54b_badSink	void CWE401_Memory_Leak__char_malloc_54b_badSink(char * data) {     CWE401_Memory_Leak__char_malloc_54c_badSink(data); }
0	CWE401_Memory_Leak__char_malloc_54b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_54b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_malloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_54b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_54b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_malloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_malloc_54c_badSink	void CWE401_Memory_Leak__char_malloc_54c_badSink(char * data) {     CWE401_Memory_Leak__char_malloc_54d_badSink(data); }
0	CWE401_Memory_Leak__char_malloc_54c_goodG2BSink	void CWE401_Memory_Leak__char_malloc_54c_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_malloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_54c_goodB2GSink	void CWE401_Memory_Leak__char_malloc_54c_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_malloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_malloc_54d_badSink	void CWE401_Memory_Leak__char_malloc_54d_badSink(char * data) {     CWE401_Memory_Leak__char_malloc_54e_badSink(data); }
0	CWE401_Memory_Leak__char_malloc_54d_goodG2BSink	void CWE401_Memory_Leak__char_malloc_54d_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_malloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_malloc_54d_goodB2GSink	void CWE401_Memory_Leak__char_malloc_54d_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_malloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_malloc_54e_badSink	void CWE401_Memory_Leak__char_malloc_54e_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_54e_goodG2BSink	void CWE401_Memory_Leak__char_malloc_54e_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_54e_goodB2GSink	void CWE401_Memory_Leak__char_malloc_54e_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_61_bad	void CWE401_Memory_Leak__char_malloc_61_bad() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_malloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_malloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_malloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_malloc_61_good	void CWE401_Memory_Leak__char_malloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_61b_badSource	char * CWE401_Memory_Leak__char_malloc_61b_badSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	CWE401_Memory_Leak__char_malloc_61b_goodG2BSource	char * CWE401_Memory_Leak__char_malloc_61b_goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	CWE401_Memory_Leak__char_malloc_61b_goodB2GSource	char * CWE401_Memory_Leak__char_malloc_61b_goodB2GSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodG2BSource	void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodB2GSource	void goodB2GSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	CWE401_Memory_Leak__char_malloc_63_bad	void CWE401_Memory_Leak__char_malloc_63_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__char_malloc_63_good	void CWE401_Memory_Leak__char_malloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_63b_badSink	void CWE401_Memory_Leak__char_malloc_63b_badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_63b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_63b_goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_63b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_63b_goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_64_bad	void CWE401_Memory_Leak__char_malloc_64_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__char_malloc_64_good	void CWE401_Memory_Leak__char_malloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_64b_badSink	void CWE401_Memory_Leak__char_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_64b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_64b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_65_bad	void CWE401_Memory_Leak__char_malloc_65_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_malloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_malloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_malloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__char_malloc_65_good	void CWE401_Memory_Leak__char_malloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_65b_badSink	void CWE401_Memory_Leak__char_malloc_65b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_65b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_65b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_65b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_65b_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_66_bad	void CWE401_Memory_Leak__char_malloc_66_bad() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__char_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__char_malloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__char_malloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__char_malloc_66_good	void CWE401_Memory_Leak__char_malloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_66b_badSink	void CWE401_Memory_Leak__char_malloc_66b_badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_66b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_66b_goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_66b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_66b_goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_67_bad	void CWE401_Memory_Leak__char_malloc_67_bad() {     char * data;     CWE401_Memory_Leak__char_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__char_malloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_malloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__char_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_malloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__char_malloc_67_good	void CWE401_Memory_Leak__char_malloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_67b_badSink	void CWE401_Memory_Leak__char_malloc_67b_badSink(CWE401_Memory_Leak__char_malloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_67b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_67b_goodG2BSink(CWE401_Memory_Leak__char_malloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_67b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_67b_goodB2GSink(CWE401_Memory_Leak__char_malloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_malloc_68_bad	void CWE401_Memory_Leak__char_malloc_68_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_68_badData = data;     CWE401_Memory_Leak__char_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_68_goodG2BData = data;     CWE401_Memory_Leak__char_malloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_68_goodB2GData = data;     CWE401_Memory_Leak__char_malloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__char_malloc_68_good	void CWE401_Memory_Leak__char_malloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_malloc_68b_badSink	void CWE401_Memory_Leak__char_malloc_68b_badSink() {     char * data = CWE401_Memory_Leak__char_malloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_68b_goodG2BSink	void CWE401_Memory_Leak__char_malloc_68b_goodG2BSink() {     char * data = CWE401_Memory_Leak__char_malloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_68b_goodB2GSink	void CWE401_Memory_Leak__char_malloc_68b_goodB2GSink() {     char * data = CWE401_Memory_Leak__char_malloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_malloc_81_bad::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__char_malloc_81_goodB2G::action(char * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_malloc_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_malloc_81_base& baseObject = CWE401_Memory_Leak__char_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_malloc_81_base& baseObject = CWE401_Memory_Leak__char_malloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_malloc_81_base& baseObject = CWE401_Memory_Leak__char_malloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__char_malloc_82_bad::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__char_malloc_82_goodB2G::action(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_malloc_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_82_base* baseObject = new CWE401_Memory_Leak__char_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_82_base* baseObject = new CWE401_Memory_Leak__char_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_malloc_82_base* baseObject = new CWE401_Memory_Leak__char_malloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__char_malloc_83_bad	CWE401_Memory_Leak__char_malloc_83_bad::CWE401_Memory_Leak__char_malloc_83_bad(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	~CWE401_Memory_Leak__char_malloc_83_bad	CWE401_Memory_Leak__char_malloc_83_bad::~CWE401_Memory_Leak__char_malloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_83_goodB2G	CWE401_Memory_Leak__char_malloc_83_goodB2G::CWE401_Memory_Leak__char_malloc_83_goodB2G(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_malloc_83_goodB2G	CWE401_Memory_Leak__char_malloc_83_goodB2G::~CWE401_Memory_Leak__char_malloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_malloc_83_goodG2B	CWE401_Memory_Leak__char_malloc_83_goodG2B::CWE401_Memory_Leak__char_malloc_83_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_malloc_83_goodG2B	CWE401_Memory_Leak__char_malloc_83_goodG2B::~CWE401_Memory_Leak__char_malloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_malloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_malloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__char_malloc_84_bad	CWE401_Memory_Leak__char_malloc_84_bad::CWE401_Memory_Leak__char_malloc_84_bad(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	~CWE401_Memory_Leak__char_malloc_84_bad	CWE401_Memory_Leak__char_malloc_84_bad::~CWE401_Memory_Leak__char_malloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_malloc_84_goodB2G	CWE401_Memory_Leak__char_malloc_84_goodB2G::CWE401_Memory_Leak__char_malloc_84_goodB2G(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_malloc_84_goodB2G	CWE401_Memory_Leak__char_malloc_84_goodB2G::~CWE401_Memory_Leak__char_malloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_malloc_84_goodG2B	CWE401_Memory_Leak__char_malloc_84_goodG2B::CWE401_Memory_Leak__char_malloc_84_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_malloc_84_goodG2B	CWE401_Memory_Leak__char_malloc_84_goodG2B::~CWE401_Memory_Leak__char_malloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_malloc_84_bad * badObject = new CWE401_Memory_Leak__char_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_malloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__char_malloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_malloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__char_malloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__char_realloc_01_bad	void CWE401_Memory_Leak__char_realloc_01_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_realloc_01_good	void CWE401_Memory_Leak__char_realloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_02_bad	void CWE401_Memory_Leak__char_realloc_02_bad() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_02_good	void CWE401_Memory_Leak__char_realloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_03_bad	void CWE401_Memory_Leak__char_realloc_03_bad() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_03_good	void CWE401_Memory_Leak__char_realloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_04_bad	void CWE401_Memory_Leak__char_realloc_04_bad() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_04_good	void CWE401_Memory_Leak__char_realloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_05_bad	void CWE401_Memory_Leak__char_realloc_05_bad() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_05_good	void CWE401_Memory_Leak__char_realloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_06_bad	void CWE401_Memory_Leak__char_realloc_06_bad() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_06_good	void CWE401_Memory_Leak__char_realloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_07_bad	void CWE401_Memory_Leak__char_realloc_07_bad() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_07_good	void CWE401_Memory_Leak__char_realloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_08_bad	void CWE401_Memory_Leak__char_realloc_08_bad() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_08_good	void CWE401_Memory_Leak__char_realloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_09_bad	void CWE401_Memory_Leak__char_realloc_09_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_09_good	void CWE401_Memory_Leak__char_realloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_10_bad	void CWE401_Memory_Leak__char_realloc_10_bad() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_10_good	void CWE401_Memory_Leak__char_realloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_11_bad	void CWE401_Memory_Leak__char_realloc_11_bad() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_11_good	void CWE401_Memory_Leak__char_realloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_12_bad	void CWE401_Memory_Leak__char_realloc_12_bad() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_12_good	void CWE401_Memory_Leak__char_realloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_realloc_13_bad	void CWE401_Memory_Leak__char_realloc_13_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_13_good	void CWE401_Memory_Leak__char_realloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_14_bad	void CWE401_Memory_Leak__char_realloc_14_bad() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_14_good	void CWE401_Memory_Leak__char_realloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_15_bad	void CWE401_Memory_Leak__char_realloc_15_bad() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__char_realloc_15_good	void CWE401_Memory_Leak__char_realloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__char_realloc_16_bad	void CWE401_Memory_Leak__char_realloc_16_bad() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__char_realloc_16_good	void CWE401_Memory_Leak__char_realloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_realloc_17_bad	void CWE401_Memory_Leak__char_realloc_17_bad() {     int i,j;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_17_good	void CWE401_Memory_Leak__char_realloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__char_realloc_18_bad	void CWE401_Memory_Leak__char_realloc_18_bad() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_18_good	void CWE401_Memory_Leak__char_realloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__char_realloc_21_bad	void CWE401_Memory_Leak__char_realloc_21_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_21_good	void CWE401_Memory_Leak__char_realloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__char_realloc_22_bad	void CWE401_Memory_Leak__char_realloc_22_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__char_realloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__char_realloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__char_realloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__char_realloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_22_good	void CWE401_Memory_Leak__char_realloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__char_realloc_22_badSink	void CWE401_Memory_Leak__char_realloc_22_badSink(char * data) {     if(CWE401_Memory_Leak__char_realloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__char_realloc_22_goodB2G1Sink	void CWE401_Memory_Leak__char_realloc_22_goodB2G1Sink(char * data) {     if(CWE401_Memory_Leak__char_realloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_realloc_22_goodB2G2Sink	void CWE401_Memory_Leak__char_realloc_22_goodB2G2Sink(char * data) {     if(CWE401_Memory_Leak__char_realloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_realloc_22_goodG2BSink	void CWE401_Memory_Leak__char_realloc_22_goodG2BSink(char * data) {     if(CWE401_Memory_Leak__char_realloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__char_realloc_31_bad	void CWE401_Memory_Leak__char_realloc_31_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_realloc_31_good	void CWE401_Memory_Leak__char_realloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_32_bad	void CWE401_Memory_Leak__char_realloc_32_bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (char *)realloc(data, 100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_realloc_32_good	void CWE401_Memory_Leak__char_realloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__char_realloc_34_bad	void CWE401_Memory_Leak__char_realloc_34_bad() {     char * data;     CWE401_Memory_Leak__char_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__char_realloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__char_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__char_realloc_34_good	void CWE401_Memory_Leak__char_realloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_realloc_41_bad	void CWE401_Memory_Leak__char_realloc_41_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink(data); }
0	CWE401_Memory_Leak__char_realloc_41_good	void CWE401_Memory_Leak__char_realloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static char * badSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
1	CWE401_Memory_Leak__char_realloc_42_bad	void CWE401_Memory_Leak__char_realloc_42_bad() {     char * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static char * goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static char * goodB2GSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_realloc_42_good	void CWE401_Memory_Leak__char_realloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_realloc_44_bad	void CWE401_Memory_Leak__char_realloc_44_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__char_realloc_44_good	void CWE401_Memory_Leak__char_realloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     char * data = CWE401_Memory_Leak__char_realloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__char_realloc_45_bad	void CWE401_Memory_Leak__char_realloc_45_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = CWE401_Memory_Leak__char_realloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = CWE401_Memory_Leak__char_realloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__char_realloc_45_good	void CWE401_Memory_Leak__char_realloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_51_bad	void CWE401_Memory_Leak__char_realloc_51_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_realloc_51_good	void CWE401_Memory_Leak__char_realloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_51b_badSink	void CWE401_Memory_Leak__char_realloc_51b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_51b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_51b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_51b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_51b_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_52_bad	void CWE401_Memory_Leak__char_realloc_52_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_realloc_52_good	void CWE401_Memory_Leak__char_realloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_52b_badSink	void CWE401_Memory_Leak__char_realloc_52b_badSink(char * data) {     CWE401_Memory_Leak__char_realloc_52c_badSink(data); }
0	CWE401_Memory_Leak__char_realloc_52b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_52b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_realloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_52b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_52b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_realloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_realloc_52c_badSink	void CWE401_Memory_Leak__char_realloc_52c_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_52c_goodG2BSink	void CWE401_Memory_Leak__char_realloc_52c_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_52c_goodB2GSink	void CWE401_Memory_Leak__char_realloc_52c_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_53_bad	void CWE401_Memory_Leak__char_realloc_53_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_realloc_53_good	void CWE401_Memory_Leak__char_realloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_53b_badSink	void CWE401_Memory_Leak__char_realloc_53b_badSink(char * data) {     CWE401_Memory_Leak__char_realloc_53c_badSink(data); }
0	CWE401_Memory_Leak__char_realloc_53b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_53b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_realloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_53b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_53b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_realloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_realloc_53c_badSink	void CWE401_Memory_Leak__char_realloc_53c_badSink(char * data) {     CWE401_Memory_Leak__char_realloc_53d_badSink(data); }
0	CWE401_Memory_Leak__char_realloc_53c_goodG2BSink	void CWE401_Memory_Leak__char_realloc_53c_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_realloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_53c_goodB2GSink	void CWE401_Memory_Leak__char_realloc_53c_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_realloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_realloc_53d_badSink	void CWE401_Memory_Leak__char_realloc_53d_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_53d_goodG2BSink	void CWE401_Memory_Leak__char_realloc_53d_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_53d_goodB2GSink	void CWE401_Memory_Leak__char_realloc_53d_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_54_bad	void CWE401_Memory_Leak__char_realloc_54_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__char_realloc_54_good	void CWE401_Memory_Leak__char_realloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_54b_badSink	void CWE401_Memory_Leak__char_realloc_54b_badSink(char * data) {     CWE401_Memory_Leak__char_realloc_54c_badSink(data); }
0	CWE401_Memory_Leak__char_realloc_54b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_54b_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_realloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_54b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_54b_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_realloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_realloc_54c_badSink	void CWE401_Memory_Leak__char_realloc_54c_badSink(char * data) {     CWE401_Memory_Leak__char_realloc_54d_badSink(data); }
0	CWE401_Memory_Leak__char_realloc_54c_goodG2BSink	void CWE401_Memory_Leak__char_realloc_54c_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_realloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_54c_goodB2GSink	void CWE401_Memory_Leak__char_realloc_54c_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_realloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_realloc_54d_badSink	void CWE401_Memory_Leak__char_realloc_54d_badSink(char * data) {     CWE401_Memory_Leak__char_realloc_54e_badSink(data); }
0	CWE401_Memory_Leak__char_realloc_54d_goodG2BSink	void CWE401_Memory_Leak__char_realloc_54d_goodG2BSink(char * data) {     CWE401_Memory_Leak__char_realloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__char_realloc_54d_goodB2GSink	void CWE401_Memory_Leak__char_realloc_54d_goodB2GSink(char * data) {     CWE401_Memory_Leak__char_realloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__char_realloc_54e_badSink	void CWE401_Memory_Leak__char_realloc_54e_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_54e_goodG2BSink	void CWE401_Memory_Leak__char_realloc_54e_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_54e_goodB2GSink	void CWE401_Memory_Leak__char_realloc_54e_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_61_bad	void CWE401_Memory_Leak__char_realloc_61_bad() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_realloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_realloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__char_realloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_realloc_61_good	void CWE401_Memory_Leak__char_realloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_61b_badSource	char * CWE401_Memory_Leak__char_realloc_61b_badSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	CWE401_Memory_Leak__char_realloc_61b_goodG2BSource	char * CWE401_Memory_Leak__char_realloc_61b_goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
0	CWE401_Memory_Leak__char_realloc_61b_goodB2GSource	char * CWE401_Memory_Leak__char_realloc_61b_goodB2GSource(char * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     return data; }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodG2BSource	void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	goodB2GSource	void goodB2GSource(char * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	CWE401_Memory_Leak__char_realloc_63_bad	void CWE401_Memory_Leak__char_realloc_63_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__char_realloc_63_good	void CWE401_Memory_Leak__char_realloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_63b_badSink	void CWE401_Memory_Leak__char_realloc_63b_badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_63b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_63b_goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_63b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_63b_goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_64_bad	void CWE401_Memory_Leak__char_realloc_64_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__char_realloc_64_good	void CWE401_Memory_Leak__char_realloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_64b_badSink	void CWE401_Memory_Leak__char_realloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_64b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_64b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_65_bad	void CWE401_Memory_Leak__char_realloc_65_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_realloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_realloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__char_realloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__char_realloc_65_good	void CWE401_Memory_Leak__char_realloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_65b_badSink	void CWE401_Memory_Leak__char_realloc_65b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_65b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_65b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_65b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_65b_goodB2GSink(char * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_66_bad	void CWE401_Memory_Leak__char_realloc_66_bad() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__char_realloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__char_realloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__char_realloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__char_realloc_66_good	void CWE401_Memory_Leak__char_realloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_66b_badSink	void CWE401_Memory_Leak__char_realloc_66b_badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_66b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_66b_goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_66b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_66b_goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_67_bad	void CWE401_Memory_Leak__char_realloc_67_bad() {     char * data;     CWE401_Memory_Leak__char_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_realloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__char_realloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_realloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__char_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__char_realloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__char_realloc_67_good	void CWE401_Memory_Leak__char_realloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_67b_badSink	void CWE401_Memory_Leak__char_realloc_67b_badSink(CWE401_Memory_Leak__char_realloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_67b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_67b_goodG2BSink(CWE401_Memory_Leak__char_realloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_67b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_67b_goodB2GSink(CWE401_Memory_Leak__char_realloc_67_structType myStruct) {     char * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__char_realloc_68_bad	void CWE401_Memory_Leak__char_realloc_68_bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_68_badData = data;     CWE401_Memory_Leak__char_realloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_68_goodG2BData = data;     CWE401_Memory_Leak__char_realloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_68_goodB2GData = data;     CWE401_Memory_Leak__char_realloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__char_realloc_68_good	void CWE401_Memory_Leak__char_realloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__char_realloc_68b_badSink	void CWE401_Memory_Leak__char_realloc_68b_badSink() {     char * data = CWE401_Memory_Leak__char_realloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_68b_goodG2BSink	void CWE401_Memory_Leak__char_realloc_68b_goodG2BSink() {     char * data = CWE401_Memory_Leak__char_realloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_68b_goodB2GSink	void CWE401_Memory_Leak__char_realloc_68b_goodB2GSink() {     char * data = CWE401_Memory_Leak__char_realloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_realloc_81_bad::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__char_realloc_81_goodB2G::action(char * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_realloc_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_realloc_81_base& baseObject = CWE401_Memory_Leak__char_realloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_realloc_81_base& baseObject = CWE401_Memory_Leak__char_realloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__char_realloc_81_base& baseObject = CWE401_Memory_Leak__char_realloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__char_realloc_82_bad::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__char_realloc_82_goodB2G::action(char * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__char_realloc_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_82_base* baseObject = new CWE401_Memory_Leak__char_realloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_82_base* baseObject = new CWE401_Memory_Leak__char_realloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__char_realloc_82_base* baseObject = new CWE401_Memory_Leak__char_realloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__char_realloc_83_bad	CWE401_Memory_Leak__char_realloc_83_bad::CWE401_Memory_Leak__char_realloc_83_bad(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	~CWE401_Memory_Leak__char_realloc_83_bad	CWE401_Memory_Leak__char_realloc_83_bad::~CWE401_Memory_Leak__char_realloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_83_goodB2G	CWE401_Memory_Leak__char_realloc_83_goodB2G::CWE401_Memory_Leak__char_realloc_83_goodB2G(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_realloc_83_goodB2G	CWE401_Memory_Leak__char_realloc_83_goodB2G::~CWE401_Memory_Leak__char_realloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_realloc_83_goodG2B	CWE401_Memory_Leak__char_realloc_83_goodG2B::CWE401_Memory_Leak__char_realloc_83_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_realloc_83_goodG2B	CWE401_Memory_Leak__char_realloc_83_goodG2B::~CWE401_Memory_Leak__char_realloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_realloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_realloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_realloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__char_realloc_84_bad	CWE401_Memory_Leak__char_realloc_84_bad::CWE401_Memory_Leak__char_realloc_84_bad(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
1	~CWE401_Memory_Leak__char_realloc_84_bad	CWE401_Memory_Leak__char_realloc_84_bad::~CWE401_Memory_Leak__char_realloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__char_realloc_84_goodB2G	CWE401_Memory_Leak__char_realloc_84_goodB2G::CWE401_Memory_Leak__char_realloc_84_goodB2G(char * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (char *)realloc(data, 100*sizeof(char));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_realloc_84_goodB2G	CWE401_Memory_Leak__char_realloc_84_goodB2G::~CWE401_Memory_Leak__char_realloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__char_realloc_84_goodG2B	CWE401_Memory_Leak__char_realloc_84_goodG2B::CWE401_Memory_Leak__char_realloc_84_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data); }
0	~CWE401_Memory_Leak__char_realloc_84_goodG2B	CWE401_Memory_Leak__char_realloc_84_goodG2B::~CWE401_Memory_Leak__char_realloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_realloc_84_bad * badObject = new CWE401_Memory_Leak__char_realloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_realloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__char_realloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__char_realloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__char_realloc_84_goodB2G(data);     delete goodB2GObject; }
0	BadClass	BadClass(const char * name)         {             if (name)             {                 this->name = new char[strlen(name) + 1];                 strcpy(this->name, name);             }             else             {                 this->name = new char[1];                 *(this->name) = '\0';             }         }
0	~BadClass	~BadClass()         {             /* FLAW: Don't deallocate memory in the destructor that was allocated in the constructor */         }
0	BadClass	BadClass(BadClass &badClassObject)         {              this->name = new char[strlen(badClassObject.name) + 1];             strcpy(this->name, badClassObject.name);         }
0	=	BadClass& operator=(const BadClass &badClassObject)          {              if (&badClassObject != this)              {                  this->name = new char[strlen(badClassObject.name) + 1];                 strcpy(this->name, badClassObject.name);             }              return *this;          }
0	printName	void printName()         {             printLine(name);         }
1	bad	void bad() {     BadClass badClassObject ("BadClass");      badClassObject.printName(); }
0	GoodClass	GoodClass(const char * name)         {                     if (name)             {                 this->name = new char[strlen(name) + 1];                 strcpy(this->name, name);             }             else             {                 this->name = new char[1];                 *(this->name) = '\0';             }         }
0	~GoodClass	~GoodClass()         {             /* FIX: Deallocate memory in the destructor that was allocated in the constructor */             delete [] name;         }
0	GoodClass	GoodClass(GoodClass &goodClassObject)         {              this->name = new char[strlen(goodClassObject.name) + 1];             strcpy(this->name, goodClassObject.name);         }
0	=	GoodClass& operator=(const GoodClass &goodClassObject)          {              if (&goodClassObject != this)              {                  this->name = new char[strlen(goodClassObject.name) + 1];                 strcpy(this->name, goodClassObject.name);             }              return *this;          }
0	printName	void printName()         {             printLine(name);         }
0	good1	static void good1() {     GoodClass goodClassObject ("GoodClass");      goodClassObject.printName(); }
1	CWE401_Memory_Leak__int64_t_calloc_01_bad	void CWE401_Memory_Leak__int64_t_calloc_01_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_calloc_01_good	void CWE401_Memory_Leak__int64_t_calloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_02_bad	void CWE401_Memory_Leak__int64_t_calloc_02_bad() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_02_good	void CWE401_Memory_Leak__int64_t_calloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_03_bad	void CWE401_Memory_Leak__int64_t_calloc_03_bad() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_03_good	void CWE401_Memory_Leak__int64_t_calloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_04_bad	void CWE401_Memory_Leak__int64_t_calloc_04_bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_04_good	void CWE401_Memory_Leak__int64_t_calloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_05_bad	void CWE401_Memory_Leak__int64_t_calloc_05_bad() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_05_good	void CWE401_Memory_Leak__int64_t_calloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_06_bad	void CWE401_Memory_Leak__int64_t_calloc_06_bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_06_good	void CWE401_Memory_Leak__int64_t_calloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_07_bad	void CWE401_Memory_Leak__int64_t_calloc_07_bad() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_07_good	void CWE401_Memory_Leak__int64_t_calloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_08_bad	void CWE401_Memory_Leak__int64_t_calloc_08_bad() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_08_good	void CWE401_Memory_Leak__int64_t_calloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_09_bad	void CWE401_Memory_Leak__int64_t_calloc_09_bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_09_good	void CWE401_Memory_Leak__int64_t_calloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_10_bad	void CWE401_Memory_Leak__int64_t_calloc_10_bad() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_10_good	void CWE401_Memory_Leak__int64_t_calloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_11_bad	void CWE401_Memory_Leak__int64_t_calloc_11_bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_11_good	void CWE401_Memory_Leak__int64_t_calloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_12_bad	void CWE401_Memory_Leak__int64_t_calloc_12_bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_12_good	void CWE401_Memory_Leak__int64_t_calloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_calloc_13_bad	void CWE401_Memory_Leak__int64_t_calloc_13_bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_13_good	void CWE401_Memory_Leak__int64_t_calloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_14_bad	void CWE401_Memory_Leak__int64_t_calloc_14_bad() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_14_good	void CWE401_Memory_Leak__int64_t_calloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_15_bad	void CWE401_Memory_Leak__int64_t_calloc_15_bad() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__int64_t_calloc_15_good	void CWE401_Memory_Leak__int64_t_calloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_calloc_16_bad	void CWE401_Memory_Leak__int64_t_calloc_16_bad() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__int64_t_calloc_16_good	void CWE401_Memory_Leak__int64_t_calloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_calloc_17_bad	void CWE401_Memory_Leak__int64_t_calloc_17_bad() {     int i,j;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_17_good	void CWE401_Memory_Leak__int64_t_calloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_calloc_18_bad	void CWE401_Memory_Leak__int64_t_calloc_18_bad() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_18_good	void CWE401_Memory_Leak__int64_t_calloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int64_t_calloc_21_bad	void CWE401_Memory_Leak__int64_t_calloc_21_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_21_good	void CWE401_Memory_Leak__int64_t_calloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_calloc_22_bad	void CWE401_Memory_Leak__int64_t_calloc_22_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__int64_t_calloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__int64_t_calloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__int64_t_calloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__int64_t_calloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_22_good	void CWE401_Memory_Leak__int64_t_calloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_calloc_22_badSink	void CWE401_Memory_Leak__int64_t_calloc_22_badSink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_calloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_calloc_22_goodB2G1Sink	void CWE401_Memory_Leak__int64_t_calloc_22_goodB2G1Sink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_calloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_calloc_22_goodB2G2Sink	void CWE401_Memory_Leak__int64_t_calloc_22_goodB2G2Sink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_calloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_calloc_22_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_22_goodG2BSink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_calloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int64_t_calloc_31_bad	void CWE401_Memory_Leak__int64_t_calloc_31_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_calloc_31_good	void CWE401_Memory_Leak__int64_t_calloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_32_bad	void CWE401_Memory_Leak__int64_t_calloc_32_bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)calloc(100, sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_calloc_32_good	void CWE401_Memory_Leak__int64_t_calloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__int64_t_calloc_34_bad	void CWE401_Memory_Leak__int64_t_calloc_34_bad() {     int64_t * data;     CWE401_Memory_Leak__int64_t_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE401_Memory_Leak__int64_t_calloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE401_Memory_Leak__int64_t_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_calloc_34_good	void CWE401_Memory_Leak__int64_t_calloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_calloc_41_bad	void CWE401_Memory_Leak__int64_t_calloc_41_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_41_good	void CWE401_Memory_Leak__int64_t_calloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int64_t * badSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
1	CWE401_Memory_Leak__int64_t_calloc_42_bad	void CWE401_Memory_Leak__int64_t_calloc_42_bad() {     int64_t * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static int64_t * goodG2BSource(int64_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static int64_t * goodB2GSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_calloc_42_good	void CWE401_Memory_Leak__int64_t_calloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	bad	void bad() {     int64_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(int64_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_calloc_44_bad	void CWE401_Memory_Leak__int64_t_calloc_44_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int64_t_calloc_44_good	void CWE401_Memory_Leak__int64_t_calloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_calloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_calloc_45_bad	void CWE401_Memory_Leak__int64_t_calloc_45_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_calloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_calloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__int64_t_calloc_45_good	void CWE401_Memory_Leak__int64_t_calloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_51_bad	void CWE401_Memory_Leak__int64_t_calloc_51_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_51_good	void CWE401_Memory_Leak__int64_t_calloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_51b_badSink	void CWE401_Memory_Leak__int64_t_calloc_51b_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_51b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_51b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_51b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_51b_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_52_bad	void CWE401_Memory_Leak__int64_t_calloc_52_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_52_good	void CWE401_Memory_Leak__int64_t_calloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_52b_badSink	void CWE401_Memory_Leak__int64_t_calloc_52b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_52c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_52b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_52b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_52b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_52b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_calloc_52c_badSink	void CWE401_Memory_Leak__int64_t_calloc_52c_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_52c_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_52c_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_52c_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_52c_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_53_bad	void CWE401_Memory_Leak__int64_t_calloc_53_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_53_good	void CWE401_Memory_Leak__int64_t_calloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_53b_badSink	void CWE401_Memory_Leak__int64_t_calloc_53b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_53c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_53b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_53b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_53b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_53b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_calloc_53c_badSink	void CWE401_Memory_Leak__int64_t_calloc_53c_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_53d_badSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_53c_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_53c_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_53c_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_53c_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_calloc_53d_badSink	void CWE401_Memory_Leak__int64_t_calloc_53d_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_53d_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_53d_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_53d_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_53d_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_54_bad	void CWE401_Memory_Leak__int64_t_calloc_54_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_54_good	void CWE401_Memory_Leak__int64_t_calloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_54b_badSink	void CWE401_Memory_Leak__int64_t_calloc_54b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_54b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_54b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_54b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_54b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_calloc_54c_badSink	void CWE401_Memory_Leak__int64_t_calloc_54c_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54d_badSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_54c_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_54c_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_54c_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_54c_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_calloc_54d_badSink	void CWE401_Memory_Leak__int64_t_calloc_54d_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54e_badSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_54d_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_54d_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_calloc_54d_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_54d_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_calloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_calloc_54e_badSink	void CWE401_Memory_Leak__int64_t_calloc_54e_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_54e_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_54e_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_54e_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_54e_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_61_bad	void CWE401_Memory_Leak__int64_t_calloc_61_bad() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_calloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_calloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_calloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_calloc_61_good	void CWE401_Memory_Leak__int64_t_calloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_61b_badSource	int64_t * CWE401_Memory_Leak__int64_t_calloc_61b_badSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int64_t_calloc_61b_goodG2BSource	int64_t * CWE401_Memory_Leak__int64_t_calloc_61b_goodG2BSource(int64_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int64_t_calloc_61b_goodB2GSource	int64_t * CWE401_Memory_Leak__int64_t_calloc_61b_goodB2GSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodG2BSource	void goodG2BSource(int64_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodB2GSource	void goodB2GSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	CWE401_Memory_Leak__int64_t_calloc_63_bad	void CWE401_Memory_Leak__int64_t_calloc_63_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int64_t_calloc_63_good	void CWE401_Memory_Leak__int64_t_calloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_63b_badSink	void CWE401_Memory_Leak__int64_t_calloc_63b_badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_63b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_63b_goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_63b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_63b_goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_64_bad	void CWE401_Memory_Leak__int64_t_calloc_64_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int64_t_calloc_64_good	void CWE401_Memory_Leak__int64_t_calloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_64b_badSink	void CWE401_Memory_Leak__int64_t_calloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_64b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_64b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_65_bad	void CWE401_Memory_Leak__int64_t_calloc_65_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_calloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_calloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_calloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int64_t_calloc_65_good	void CWE401_Memory_Leak__int64_t_calloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_65b_badSink	void CWE401_Memory_Leak__int64_t_calloc_65b_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_65b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_65b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_65b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_65b_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_66_bad	void CWE401_Memory_Leak__int64_t_calloc_66_bad() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_calloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_calloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_calloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__int64_t_calloc_66_good	void CWE401_Memory_Leak__int64_t_calloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_66b_badSink	void CWE401_Memory_Leak__int64_t_calloc_66b_badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_66b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_66b_goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_66b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_66b_goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_67_bad	void CWE401_Memory_Leak__int64_t_calloc_67_bad() {     int64_t * data;     CWE401_Memory_Leak__int64_t_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_calloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE401_Memory_Leak__int64_t_calloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_calloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE401_Memory_Leak__int64_t_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_calloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__int64_t_calloc_67_good	void CWE401_Memory_Leak__int64_t_calloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_67b_badSink	void CWE401_Memory_Leak__int64_t_calloc_67b_badSink(CWE401_Memory_Leak__int64_t_calloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_67b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_67b_goodG2BSink(CWE401_Memory_Leak__int64_t_calloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_67b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_67b_goodB2GSink(CWE401_Memory_Leak__int64_t_calloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_calloc_68_bad	void CWE401_Memory_Leak__int64_t_calloc_68_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_68_badData = data;     CWE401_Memory_Leak__int64_t_calloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_68_goodG2BData = data;     CWE401_Memory_Leak__int64_t_calloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_68_goodB2GData = data;     CWE401_Memory_Leak__int64_t_calloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__int64_t_calloc_68_good	void CWE401_Memory_Leak__int64_t_calloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_calloc_68b_badSink	void CWE401_Memory_Leak__int64_t_calloc_68b_badSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_calloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_68b_goodG2BSink	void CWE401_Memory_Leak__int64_t_calloc_68b_goodG2BSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_calloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_68b_goodB2GSink	void CWE401_Memory_Leak__int64_t_calloc_68b_goodB2GSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_calloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_calloc_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int64_t_calloc_81_goodB2G::action(int64_t * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_calloc_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_calloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_calloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_calloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_calloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_calloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_calloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__int64_t_calloc_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int64_t_calloc_82_goodB2G::action(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_calloc_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_calloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_calloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_calloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_calloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__int64_t_calloc_83_bad	CWE401_Memory_Leak__int64_t_calloc_83_bad::CWE401_Memory_Leak__int64_t_calloc_83_bad(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	~CWE401_Memory_Leak__int64_t_calloc_83_bad	CWE401_Memory_Leak__int64_t_calloc_83_bad::~CWE401_Memory_Leak__int64_t_calloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_83_goodB2G	CWE401_Memory_Leak__int64_t_calloc_83_goodB2G::CWE401_Memory_Leak__int64_t_calloc_83_goodB2G(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_calloc_83_goodB2G	CWE401_Memory_Leak__int64_t_calloc_83_goodB2G::~CWE401_Memory_Leak__int64_t_calloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_calloc_83_goodG2B	CWE401_Memory_Leak__int64_t_calloc_83_goodG2B::CWE401_Memory_Leak__int64_t_calloc_83_goodG2B(int64_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_calloc_83_goodG2B	CWE401_Memory_Leak__int64_t_calloc_83_goodG2B::~CWE401_Memory_Leak__int64_t_calloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_calloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_calloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_calloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__int64_t_calloc_84_bad	CWE401_Memory_Leak__int64_t_calloc_84_bad::CWE401_Memory_Leak__int64_t_calloc_84_bad(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	~CWE401_Memory_Leak__int64_t_calloc_84_bad	CWE401_Memory_Leak__int64_t_calloc_84_bad::~CWE401_Memory_Leak__int64_t_calloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_calloc_84_goodB2G	CWE401_Memory_Leak__int64_t_calloc_84_goodB2G::CWE401_Memory_Leak__int64_t_calloc_84_goodB2G(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)calloc(100, sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_calloc_84_goodB2G	CWE401_Memory_Leak__int64_t_calloc_84_goodB2G::~CWE401_Memory_Leak__int64_t_calloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_calloc_84_goodG2B	CWE401_Memory_Leak__int64_t_calloc_84_goodG2B::CWE401_Memory_Leak__int64_t_calloc_84_goodG2B(int64_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_calloc_84_goodG2B	CWE401_Memory_Leak__int64_t_calloc_84_goodG2B::~CWE401_Memory_Leak__int64_t_calloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_calloc_84_bad * badObject = new CWE401_Memory_Leak__int64_t_calloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_calloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__int64_t_calloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_calloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__int64_t_calloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__int64_t_malloc_01_bad	void CWE401_Memory_Leak__int64_t_malloc_01_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_malloc_01_good	void CWE401_Memory_Leak__int64_t_malloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_02_bad	void CWE401_Memory_Leak__int64_t_malloc_02_bad() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_02_good	void CWE401_Memory_Leak__int64_t_malloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_03_bad	void CWE401_Memory_Leak__int64_t_malloc_03_bad() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_03_good	void CWE401_Memory_Leak__int64_t_malloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_04_bad	void CWE401_Memory_Leak__int64_t_malloc_04_bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_04_good	void CWE401_Memory_Leak__int64_t_malloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_05_bad	void CWE401_Memory_Leak__int64_t_malloc_05_bad() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_05_good	void CWE401_Memory_Leak__int64_t_malloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_06_bad	void CWE401_Memory_Leak__int64_t_malloc_06_bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_06_good	void CWE401_Memory_Leak__int64_t_malloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_07_bad	void CWE401_Memory_Leak__int64_t_malloc_07_bad() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_07_good	void CWE401_Memory_Leak__int64_t_malloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_08_bad	void CWE401_Memory_Leak__int64_t_malloc_08_bad() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_08_good	void CWE401_Memory_Leak__int64_t_malloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_09_bad	void CWE401_Memory_Leak__int64_t_malloc_09_bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_09_good	void CWE401_Memory_Leak__int64_t_malloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_10_bad	void CWE401_Memory_Leak__int64_t_malloc_10_bad() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_10_good	void CWE401_Memory_Leak__int64_t_malloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_11_bad	void CWE401_Memory_Leak__int64_t_malloc_11_bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_11_good	void CWE401_Memory_Leak__int64_t_malloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_12_bad	void CWE401_Memory_Leak__int64_t_malloc_12_bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_12_good	void CWE401_Memory_Leak__int64_t_malloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_malloc_13_bad	void CWE401_Memory_Leak__int64_t_malloc_13_bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_13_good	void CWE401_Memory_Leak__int64_t_malloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_14_bad	void CWE401_Memory_Leak__int64_t_malloc_14_bad() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_14_good	void CWE401_Memory_Leak__int64_t_malloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_15_bad	void CWE401_Memory_Leak__int64_t_malloc_15_bad() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__int64_t_malloc_15_good	void CWE401_Memory_Leak__int64_t_malloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_malloc_16_bad	void CWE401_Memory_Leak__int64_t_malloc_16_bad() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__int64_t_malloc_16_good	void CWE401_Memory_Leak__int64_t_malloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_malloc_17_bad	void CWE401_Memory_Leak__int64_t_malloc_17_bad() {     int i,j;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_17_good	void CWE401_Memory_Leak__int64_t_malloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_malloc_18_bad	void CWE401_Memory_Leak__int64_t_malloc_18_bad() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_18_good	void CWE401_Memory_Leak__int64_t_malloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int64_t_malloc_21_bad	void CWE401_Memory_Leak__int64_t_malloc_21_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_21_good	void CWE401_Memory_Leak__int64_t_malloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_malloc_22_bad	void CWE401_Memory_Leak__int64_t_malloc_22_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__int64_t_malloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__int64_t_malloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__int64_t_malloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__int64_t_malloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_22_good	void CWE401_Memory_Leak__int64_t_malloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_malloc_22_badSink	void CWE401_Memory_Leak__int64_t_malloc_22_badSink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_malloc_22_goodB2G1Sink	void CWE401_Memory_Leak__int64_t_malloc_22_goodB2G1Sink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_malloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_malloc_22_goodB2G2Sink	void CWE401_Memory_Leak__int64_t_malloc_22_goodB2G2Sink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_malloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_malloc_22_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_22_goodG2BSink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_malloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int64_t_malloc_31_bad	void CWE401_Memory_Leak__int64_t_malloc_31_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_malloc_31_good	void CWE401_Memory_Leak__int64_t_malloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_32_bad	void CWE401_Memory_Leak__int64_t_malloc_32_bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_malloc_32_good	void CWE401_Memory_Leak__int64_t_malloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__int64_t_malloc_34_bad	void CWE401_Memory_Leak__int64_t_malloc_34_bad() {     int64_t * data;     CWE401_Memory_Leak__int64_t_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE401_Memory_Leak__int64_t_malloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE401_Memory_Leak__int64_t_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_malloc_34_good	void CWE401_Memory_Leak__int64_t_malloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_malloc_41_bad	void CWE401_Memory_Leak__int64_t_malloc_41_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_41_good	void CWE401_Memory_Leak__int64_t_malloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int64_t * badSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
1	CWE401_Memory_Leak__int64_t_malloc_42_bad	void CWE401_Memory_Leak__int64_t_malloc_42_bad() {     int64_t * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static int64_t * goodG2BSource(int64_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static int64_t * goodB2GSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_malloc_42_good	void CWE401_Memory_Leak__int64_t_malloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	bad	void bad() {     int64_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(int64_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_malloc_44_bad	void CWE401_Memory_Leak__int64_t_malloc_44_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int64_t_malloc_44_good	void CWE401_Memory_Leak__int64_t_malloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_malloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_malloc_45_bad	void CWE401_Memory_Leak__int64_t_malloc_45_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_malloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_malloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__int64_t_malloc_45_good	void CWE401_Memory_Leak__int64_t_malloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_51_bad	void CWE401_Memory_Leak__int64_t_malloc_51_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_51_good	void CWE401_Memory_Leak__int64_t_malloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_51b_badSink	void CWE401_Memory_Leak__int64_t_malloc_51b_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_51b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_51b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_51b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_51b_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_52_bad	void CWE401_Memory_Leak__int64_t_malloc_52_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_52_good	void CWE401_Memory_Leak__int64_t_malloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_52b_badSink	void CWE401_Memory_Leak__int64_t_malloc_52b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_52c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_52b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_52b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_52b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_52b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_malloc_52c_badSink	void CWE401_Memory_Leak__int64_t_malloc_52c_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_52c_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_52c_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_52c_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_52c_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_53_bad	void CWE401_Memory_Leak__int64_t_malloc_53_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_53_good	void CWE401_Memory_Leak__int64_t_malloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_53b_badSink	void CWE401_Memory_Leak__int64_t_malloc_53b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_53c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_53b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_53b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_53b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_53b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_malloc_53c_badSink	void CWE401_Memory_Leak__int64_t_malloc_53c_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_53d_badSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_53c_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_53c_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_53c_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_53c_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_malloc_53d_badSink	void CWE401_Memory_Leak__int64_t_malloc_53d_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_53d_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_53d_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_53d_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_53d_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_54_bad	void CWE401_Memory_Leak__int64_t_malloc_54_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_54_good	void CWE401_Memory_Leak__int64_t_malloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_54b_badSink	void CWE401_Memory_Leak__int64_t_malloc_54b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_54b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_54b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_54b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_54b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_malloc_54c_badSink	void CWE401_Memory_Leak__int64_t_malloc_54c_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54d_badSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_54c_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_54c_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_54c_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_54c_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_malloc_54d_badSink	void CWE401_Memory_Leak__int64_t_malloc_54d_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54e_badSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_54d_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_54d_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_malloc_54d_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_54d_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_malloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_malloc_54e_badSink	void CWE401_Memory_Leak__int64_t_malloc_54e_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_54e_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_54e_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_54e_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_54e_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_61_bad	void CWE401_Memory_Leak__int64_t_malloc_61_bad() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_malloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_malloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_malloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_malloc_61_good	void CWE401_Memory_Leak__int64_t_malloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_61b_badSource	int64_t * CWE401_Memory_Leak__int64_t_malloc_61b_badSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int64_t_malloc_61b_goodG2BSource	int64_t * CWE401_Memory_Leak__int64_t_malloc_61b_goodG2BSource(int64_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int64_t_malloc_61b_goodB2GSource	int64_t * CWE401_Memory_Leak__int64_t_malloc_61b_goodB2GSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodG2BSource	void goodG2BSource(int64_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodB2GSource	void goodB2GSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	CWE401_Memory_Leak__int64_t_malloc_63_bad	void CWE401_Memory_Leak__int64_t_malloc_63_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int64_t_malloc_63_good	void CWE401_Memory_Leak__int64_t_malloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_63b_badSink	void CWE401_Memory_Leak__int64_t_malloc_63b_badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_63b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_63b_goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_63b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_63b_goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_64_bad	void CWE401_Memory_Leak__int64_t_malloc_64_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int64_t_malloc_64_good	void CWE401_Memory_Leak__int64_t_malloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_64b_badSink	void CWE401_Memory_Leak__int64_t_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_64b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_64b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_65_bad	void CWE401_Memory_Leak__int64_t_malloc_65_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_malloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_malloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_malloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int64_t_malloc_65_good	void CWE401_Memory_Leak__int64_t_malloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_65b_badSink	void CWE401_Memory_Leak__int64_t_malloc_65b_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_65b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_65b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_65b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_65b_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_66_bad	void CWE401_Memory_Leak__int64_t_malloc_66_bad() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_malloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_malloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__int64_t_malloc_66_good	void CWE401_Memory_Leak__int64_t_malloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_66b_badSink	void CWE401_Memory_Leak__int64_t_malloc_66b_badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_66b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_66b_goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_66b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_66b_goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_67_bad	void CWE401_Memory_Leak__int64_t_malloc_67_bad() {     int64_t * data;     CWE401_Memory_Leak__int64_t_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE401_Memory_Leak__int64_t_malloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_malloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE401_Memory_Leak__int64_t_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_malloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__int64_t_malloc_67_good	void CWE401_Memory_Leak__int64_t_malloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_67b_badSink	void CWE401_Memory_Leak__int64_t_malloc_67b_badSink(CWE401_Memory_Leak__int64_t_malloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_67b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_67b_goodG2BSink(CWE401_Memory_Leak__int64_t_malloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_67b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_67b_goodB2GSink(CWE401_Memory_Leak__int64_t_malloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_malloc_68_bad	void CWE401_Memory_Leak__int64_t_malloc_68_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_68_badData = data;     CWE401_Memory_Leak__int64_t_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_68_goodG2BData = data;     CWE401_Memory_Leak__int64_t_malloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_68_goodB2GData = data;     CWE401_Memory_Leak__int64_t_malloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__int64_t_malloc_68_good	void CWE401_Memory_Leak__int64_t_malloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_malloc_68b_badSink	void CWE401_Memory_Leak__int64_t_malloc_68b_badSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_malloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_68b_goodG2BSink	void CWE401_Memory_Leak__int64_t_malloc_68b_goodG2BSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_malloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_68b_goodB2GSink	void CWE401_Memory_Leak__int64_t_malloc_68b_goodB2GSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_malloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_malloc_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int64_t_malloc_81_goodB2G::action(int64_t * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_malloc_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_malloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_malloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_malloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_malloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_malloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__int64_t_malloc_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int64_t_malloc_82_goodB2G::action(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_malloc_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_malloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_malloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__int64_t_malloc_83_bad	CWE401_Memory_Leak__int64_t_malloc_83_bad::CWE401_Memory_Leak__int64_t_malloc_83_bad(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	~CWE401_Memory_Leak__int64_t_malloc_83_bad	CWE401_Memory_Leak__int64_t_malloc_83_bad::~CWE401_Memory_Leak__int64_t_malloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_83_goodB2G	CWE401_Memory_Leak__int64_t_malloc_83_goodB2G::CWE401_Memory_Leak__int64_t_malloc_83_goodB2G(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_malloc_83_goodB2G	CWE401_Memory_Leak__int64_t_malloc_83_goodB2G::~CWE401_Memory_Leak__int64_t_malloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_malloc_83_goodG2B	CWE401_Memory_Leak__int64_t_malloc_83_goodG2B::CWE401_Memory_Leak__int64_t_malloc_83_goodG2B(int64_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_malloc_83_goodG2B	CWE401_Memory_Leak__int64_t_malloc_83_goodG2B::~CWE401_Memory_Leak__int64_t_malloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_malloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_malloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__int64_t_malloc_84_bad	CWE401_Memory_Leak__int64_t_malloc_84_bad::CWE401_Memory_Leak__int64_t_malloc_84_bad(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	~CWE401_Memory_Leak__int64_t_malloc_84_bad	CWE401_Memory_Leak__int64_t_malloc_84_bad::~CWE401_Memory_Leak__int64_t_malloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_malloc_84_goodB2G	CWE401_Memory_Leak__int64_t_malloc_84_goodB2G::CWE401_Memory_Leak__int64_t_malloc_84_goodB2G(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_malloc_84_goodB2G	CWE401_Memory_Leak__int64_t_malloc_84_goodB2G::~CWE401_Memory_Leak__int64_t_malloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_malloc_84_goodG2B	CWE401_Memory_Leak__int64_t_malloc_84_goodG2B::CWE401_Memory_Leak__int64_t_malloc_84_goodG2B(int64_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_malloc_84_goodG2B	CWE401_Memory_Leak__int64_t_malloc_84_goodG2B::~CWE401_Memory_Leak__int64_t_malloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_malloc_84_bad * badObject = new CWE401_Memory_Leak__int64_t_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_malloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__int64_t_malloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_malloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__int64_t_malloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__int64_t_realloc_01_bad	void CWE401_Memory_Leak__int64_t_realloc_01_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_realloc_01_good	void CWE401_Memory_Leak__int64_t_realloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_02_bad	void CWE401_Memory_Leak__int64_t_realloc_02_bad() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_02_good	void CWE401_Memory_Leak__int64_t_realloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_03_bad	void CWE401_Memory_Leak__int64_t_realloc_03_bad() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_03_good	void CWE401_Memory_Leak__int64_t_realloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_04_bad	void CWE401_Memory_Leak__int64_t_realloc_04_bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_04_good	void CWE401_Memory_Leak__int64_t_realloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_05_bad	void CWE401_Memory_Leak__int64_t_realloc_05_bad() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_05_good	void CWE401_Memory_Leak__int64_t_realloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_06_bad	void CWE401_Memory_Leak__int64_t_realloc_06_bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_06_good	void CWE401_Memory_Leak__int64_t_realloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_07_bad	void CWE401_Memory_Leak__int64_t_realloc_07_bad() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_07_good	void CWE401_Memory_Leak__int64_t_realloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_08_bad	void CWE401_Memory_Leak__int64_t_realloc_08_bad() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_08_good	void CWE401_Memory_Leak__int64_t_realloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_09_bad	void CWE401_Memory_Leak__int64_t_realloc_09_bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_09_good	void CWE401_Memory_Leak__int64_t_realloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_10_bad	void CWE401_Memory_Leak__int64_t_realloc_10_bad() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_10_good	void CWE401_Memory_Leak__int64_t_realloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_11_bad	void CWE401_Memory_Leak__int64_t_realloc_11_bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_11_good	void CWE401_Memory_Leak__int64_t_realloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_12_bad	void CWE401_Memory_Leak__int64_t_realloc_12_bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_12_good	void CWE401_Memory_Leak__int64_t_realloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_realloc_13_bad	void CWE401_Memory_Leak__int64_t_realloc_13_bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_13_good	void CWE401_Memory_Leak__int64_t_realloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_14_bad	void CWE401_Memory_Leak__int64_t_realloc_14_bad() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_14_good	void CWE401_Memory_Leak__int64_t_realloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_15_bad	void CWE401_Memory_Leak__int64_t_realloc_15_bad() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__int64_t_realloc_15_good	void CWE401_Memory_Leak__int64_t_realloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int64_t_realloc_16_bad	void CWE401_Memory_Leak__int64_t_realloc_16_bad() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__int64_t_realloc_16_good	void CWE401_Memory_Leak__int64_t_realloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_realloc_17_bad	void CWE401_Memory_Leak__int64_t_realloc_17_bad() {     int i,j;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_17_good	void CWE401_Memory_Leak__int64_t_realloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_realloc_18_bad	void CWE401_Memory_Leak__int64_t_realloc_18_bad() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_18_good	void CWE401_Memory_Leak__int64_t_realloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int64_t_realloc_21_bad	void CWE401_Memory_Leak__int64_t_realloc_21_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_21_good	void CWE401_Memory_Leak__int64_t_realloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_realloc_22_bad	void CWE401_Memory_Leak__int64_t_realloc_22_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__int64_t_realloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__int64_t_realloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__int64_t_realloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__int64_t_realloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_22_good	void CWE401_Memory_Leak__int64_t_realloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int64_t_realloc_22_badSink	void CWE401_Memory_Leak__int64_t_realloc_22_badSink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_realloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int64_t_realloc_22_goodB2G1Sink	void CWE401_Memory_Leak__int64_t_realloc_22_goodB2G1Sink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_realloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_realloc_22_goodB2G2Sink	void CWE401_Memory_Leak__int64_t_realloc_22_goodB2G2Sink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_realloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_realloc_22_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_22_goodG2BSink(int64_t * data) {     if(CWE401_Memory_Leak__int64_t_realloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int64_t_realloc_31_bad	void CWE401_Memory_Leak__int64_t_realloc_31_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_realloc_31_good	void CWE401_Memory_Leak__int64_t_realloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_32_bad	void CWE401_Memory_Leak__int64_t_realloc_32_bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int64_t *)ALLOCA(100*sizeof(int64_t));         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int64_t *)realloc(data, 100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_realloc_32_good	void CWE401_Memory_Leak__int64_t_realloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__int64_t_realloc_34_bad	void CWE401_Memory_Leak__int64_t_realloc_34_bad() {     int64_t * data;     CWE401_Memory_Leak__int64_t_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE401_Memory_Leak__int64_t_realloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE401_Memory_Leak__int64_t_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int64_t_realloc_34_good	void CWE401_Memory_Leak__int64_t_realloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_realloc_41_bad	void CWE401_Memory_Leak__int64_t_realloc_41_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_41_good	void CWE401_Memory_Leak__int64_t_realloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int64_t * badSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
1	CWE401_Memory_Leak__int64_t_realloc_42_bad	void CWE401_Memory_Leak__int64_t_realloc_42_bad() {     int64_t * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static int64_t * goodG2BSource(int64_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static int64_t * goodB2GSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_realloc_42_good	void CWE401_Memory_Leak__int64_t_realloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	bad	void bad() {     int64_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(int64_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_realloc_44_bad	void CWE401_Memory_Leak__int64_t_realloc_44_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int64_t_realloc_44_good	void CWE401_Memory_Leak__int64_t_realloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_realloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int64_t_realloc_45_bad	void CWE401_Memory_Leak__int64_t_realloc_45_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_realloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_realloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__int64_t_realloc_45_good	void CWE401_Memory_Leak__int64_t_realloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_51_bad	void CWE401_Memory_Leak__int64_t_realloc_51_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_51_good	void CWE401_Memory_Leak__int64_t_realloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_51b_badSink	void CWE401_Memory_Leak__int64_t_realloc_51b_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_51b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_51b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_51b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_51b_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_52_bad	void CWE401_Memory_Leak__int64_t_realloc_52_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_52_good	void CWE401_Memory_Leak__int64_t_realloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_52b_badSink	void CWE401_Memory_Leak__int64_t_realloc_52b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_52c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_52b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_52b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_52b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_52b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_realloc_52c_badSink	void CWE401_Memory_Leak__int64_t_realloc_52c_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_52c_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_52c_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_52c_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_52c_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_53_bad	void CWE401_Memory_Leak__int64_t_realloc_53_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_53_good	void CWE401_Memory_Leak__int64_t_realloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_53b_badSink	void CWE401_Memory_Leak__int64_t_realloc_53b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_53c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_53b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_53b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_53b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_53b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_realloc_53c_badSink	void CWE401_Memory_Leak__int64_t_realloc_53c_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_53d_badSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_53c_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_53c_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_53c_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_53c_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_realloc_53d_badSink	void CWE401_Memory_Leak__int64_t_realloc_53d_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_53d_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_53d_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_53d_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_53d_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_54_bad	void CWE401_Memory_Leak__int64_t_realloc_54_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_54_good	void CWE401_Memory_Leak__int64_t_realloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_54b_badSink	void CWE401_Memory_Leak__int64_t_realloc_54b_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54c_badSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_54b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_54b_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_54b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_54b_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_realloc_54c_badSink	void CWE401_Memory_Leak__int64_t_realloc_54c_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54d_badSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_54c_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_54c_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_54c_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_54c_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_realloc_54d_badSink	void CWE401_Memory_Leak__int64_t_realloc_54d_badSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54e_badSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_54d_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_54d_goodG2BSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__int64_t_realloc_54d_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_54d_goodB2GSink(int64_t * data) {     CWE401_Memory_Leak__int64_t_realloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__int64_t_realloc_54e_badSink	void CWE401_Memory_Leak__int64_t_realloc_54e_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_54e_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_54e_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_54e_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_54e_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_61_bad	void CWE401_Memory_Leak__int64_t_realloc_61_bad() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_realloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_realloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     data = CWE401_Memory_Leak__int64_t_realloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_realloc_61_good	void CWE401_Memory_Leak__int64_t_realloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_61b_badSource	int64_t * CWE401_Memory_Leak__int64_t_realloc_61b_badSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int64_t_realloc_61b_goodG2BSource	int64_t * CWE401_Memory_Leak__int64_t_realloc_61b_goodG2BSource(int64_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int64_t_realloc_61b_goodB2GSource	int64_t * CWE401_Memory_Leak__int64_t_realloc_61b_goodB2GSource(int64_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     return data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodG2BSource	void goodG2BSource(int64_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	goodB2GSource	void goodB2GSource(int64_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	CWE401_Memory_Leak__int64_t_realloc_63_bad	void CWE401_Memory_Leak__int64_t_realloc_63_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int64_t_realloc_63_good	void CWE401_Memory_Leak__int64_t_realloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_63b_badSink	void CWE401_Memory_Leak__int64_t_realloc_63b_badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_63b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_63b_goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_63b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_63b_goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_64_bad	void CWE401_Memory_Leak__int64_t_realloc_64_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int64_t_realloc_64_good	void CWE401_Memory_Leak__int64_t_realloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_64b_badSink	void CWE401_Memory_Leak__int64_t_realloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_64b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_64b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_65_bad	void CWE401_Memory_Leak__int64_t_realloc_65_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_realloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_realloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE401_Memory_Leak__int64_t_realloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int64_t_realloc_65_good	void CWE401_Memory_Leak__int64_t_realloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_65b_badSink	void CWE401_Memory_Leak__int64_t_realloc_65b_badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_65b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_65b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_65b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_65b_goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_66_bad	void CWE401_Memory_Leak__int64_t_realloc_66_bad() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_realloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_realloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int64_t_realloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__int64_t_realloc_66_good	void CWE401_Memory_Leak__int64_t_realloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_66b_badSink	void CWE401_Memory_Leak__int64_t_realloc_66b_badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_66b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_66b_goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_66b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_66b_goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_67_bad	void CWE401_Memory_Leak__int64_t_realloc_67_bad() {     int64_t * data;     CWE401_Memory_Leak__int64_t_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_realloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE401_Memory_Leak__int64_t_realloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_realloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE401_Memory_Leak__int64_t_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int64_t_realloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__int64_t_realloc_67_good	void CWE401_Memory_Leak__int64_t_realloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_67b_badSink	void CWE401_Memory_Leak__int64_t_realloc_67b_badSink(CWE401_Memory_Leak__int64_t_realloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_67b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_67b_goodG2BSink(CWE401_Memory_Leak__int64_t_realloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_67b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_67b_goodB2GSink(CWE401_Memory_Leak__int64_t_realloc_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int64_t_realloc_68_bad	void CWE401_Memory_Leak__int64_t_realloc_68_bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_68_badData = data;     CWE401_Memory_Leak__int64_t_realloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_68_goodG2BData = data;     CWE401_Memory_Leak__int64_t_realloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_68_goodB2GData = data;     CWE401_Memory_Leak__int64_t_realloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__int64_t_realloc_68_good	void CWE401_Memory_Leak__int64_t_realloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int64_t_realloc_68b_badSink	void CWE401_Memory_Leak__int64_t_realloc_68b_badSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_realloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_68b_goodG2BSink	void CWE401_Memory_Leak__int64_t_realloc_68b_goodG2BSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_realloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_68b_goodB2GSink	void CWE401_Memory_Leak__int64_t_realloc_68b_goodB2GSink() {     int64_t * data = CWE401_Memory_Leak__int64_t_realloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_realloc_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int64_t_realloc_81_goodB2G::action(int64_t * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_realloc_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_realloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_realloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_realloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_realloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__int64_t_realloc_81_base& baseObject = CWE401_Memory_Leak__int64_t_realloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__int64_t_realloc_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int64_t_realloc_82_goodB2G::action(int64_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int64_t_realloc_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_realloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_realloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__int64_t_realloc_82_base* baseObject = new CWE401_Memory_Leak__int64_t_realloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__int64_t_realloc_83_bad	CWE401_Memory_Leak__int64_t_realloc_83_bad::CWE401_Memory_Leak__int64_t_realloc_83_bad(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	~CWE401_Memory_Leak__int64_t_realloc_83_bad	CWE401_Memory_Leak__int64_t_realloc_83_bad::~CWE401_Memory_Leak__int64_t_realloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_83_goodB2G	CWE401_Memory_Leak__int64_t_realloc_83_goodB2G::CWE401_Memory_Leak__int64_t_realloc_83_goodB2G(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_realloc_83_goodB2G	CWE401_Memory_Leak__int64_t_realloc_83_goodB2G::~CWE401_Memory_Leak__int64_t_realloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_realloc_83_goodG2B	CWE401_Memory_Leak__int64_t_realloc_83_goodG2B::CWE401_Memory_Leak__int64_t_realloc_83_goodG2B(int64_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_realloc_83_goodG2B	CWE401_Memory_Leak__int64_t_realloc_83_goodG2B::~CWE401_Memory_Leak__int64_t_realloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_realloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_realloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_realloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__int64_t_realloc_84_bad	CWE401_Memory_Leak__int64_t_realloc_84_bad::CWE401_Memory_Leak__int64_t_realloc_84_bad(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
1	~CWE401_Memory_Leak__int64_t_realloc_84_bad	CWE401_Memory_Leak__int64_t_realloc_84_bad::~CWE401_Memory_Leak__int64_t_realloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int64_t_realloc_84_goodB2G	CWE401_Memory_Leak__int64_t_realloc_84_goodB2G::CWE401_Memory_Leak__int64_t_realloc_84_goodB2G(int64_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int64_t *)realloc(data, 100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_realloc_84_goodB2G	CWE401_Memory_Leak__int64_t_realloc_84_goodB2G::~CWE401_Memory_Leak__int64_t_realloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int64_t_realloc_84_goodG2B	CWE401_Memory_Leak__int64_t_realloc_84_goodG2B::CWE401_Memory_Leak__int64_t_realloc_84_goodG2B(int64_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int64_t *)ALLOCA(100*sizeof(int64_t));     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]); }
0	~CWE401_Memory_Leak__int64_t_realloc_84_goodG2B	CWE401_Memory_Leak__int64_t_realloc_84_goodG2B::~CWE401_Memory_Leak__int64_t_realloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_realloc_84_bad * badObject = new CWE401_Memory_Leak__int64_t_realloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_realloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__int64_t_realloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     CWE401_Memory_Leak__int64_t_realloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__int64_t_realloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__int_calloc_01_bad	void CWE401_Memory_Leak__int_calloc_01_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_calloc_01_good	void CWE401_Memory_Leak__int_calloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_02_bad	void CWE401_Memory_Leak__int_calloc_02_bad() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_02_good	void CWE401_Memory_Leak__int_calloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_03_bad	void CWE401_Memory_Leak__int_calloc_03_bad() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_03_good	void CWE401_Memory_Leak__int_calloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_04_bad	void CWE401_Memory_Leak__int_calloc_04_bad() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_04_good	void CWE401_Memory_Leak__int_calloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_05_bad	void CWE401_Memory_Leak__int_calloc_05_bad() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_05_good	void CWE401_Memory_Leak__int_calloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_06_bad	void CWE401_Memory_Leak__int_calloc_06_bad() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_06_good	void CWE401_Memory_Leak__int_calloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_07_bad	void CWE401_Memory_Leak__int_calloc_07_bad() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_07_good	void CWE401_Memory_Leak__int_calloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_08_bad	void CWE401_Memory_Leak__int_calloc_08_bad() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_08_good	void CWE401_Memory_Leak__int_calloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_09_bad	void CWE401_Memory_Leak__int_calloc_09_bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_09_good	void CWE401_Memory_Leak__int_calloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_10_bad	void CWE401_Memory_Leak__int_calloc_10_bad() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_10_good	void CWE401_Memory_Leak__int_calloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_11_bad	void CWE401_Memory_Leak__int_calloc_11_bad() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_11_good	void CWE401_Memory_Leak__int_calloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_12_bad	void CWE401_Memory_Leak__int_calloc_12_bad() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_12_good	void CWE401_Memory_Leak__int_calloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_calloc_13_bad	void CWE401_Memory_Leak__int_calloc_13_bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_13_good	void CWE401_Memory_Leak__int_calloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_14_bad	void CWE401_Memory_Leak__int_calloc_14_bad() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_14_good	void CWE401_Memory_Leak__int_calloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_15_bad	void CWE401_Memory_Leak__int_calloc_15_bad() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__int_calloc_15_good	void CWE401_Memory_Leak__int_calloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_calloc_16_bad	void CWE401_Memory_Leak__int_calloc_16_bad() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__int_calloc_16_good	void CWE401_Memory_Leak__int_calloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_calloc_17_bad	void CWE401_Memory_Leak__int_calloc_17_bad() {     int i,j;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_17_good	void CWE401_Memory_Leak__int_calloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_calloc_18_bad	void CWE401_Memory_Leak__int_calloc_18_bad() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_18_good	void CWE401_Memory_Leak__int_calloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int_calloc_21_bad	void CWE401_Memory_Leak__int_calloc_21_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_21_good	void CWE401_Memory_Leak__int_calloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int_calloc_22_bad	void CWE401_Memory_Leak__int_calloc_22_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__int_calloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__int_calloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__int_calloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__int_calloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_22_good	void CWE401_Memory_Leak__int_calloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int_calloc_22_badSink	void CWE401_Memory_Leak__int_calloc_22_badSink(int * data) {     if(CWE401_Memory_Leak__int_calloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_calloc_22_goodB2G1Sink	void CWE401_Memory_Leak__int_calloc_22_goodB2G1Sink(int * data) {     if(CWE401_Memory_Leak__int_calloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_calloc_22_goodB2G2Sink	void CWE401_Memory_Leak__int_calloc_22_goodB2G2Sink(int * data) {     if(CWE401_Memory_Leak__int_calloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_calloc_22_goodG2BSink	void CWE401_Memory_Leak__int_calloc_22_goodG2BSink(int * data) {     if(CWE401_Memory_Leak__int_calloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int_calloc_31_bad	void CWE401_Memory_Leak__int_calloc_31_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_calloc_31_good	void CWE401_Memory_Leak__int_calloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_32_bad	void CWE401_Memory_Leak__int_calloc_32_bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)calloc(100, sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_calloc_32_good	void CWE401_Memory_Leak__int_calloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__int_calloc_34_bad	void CWE401_Memory_Leak__int_calloc_34_bad() {     int * data;     CWE401_Memory_Leak__int_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     CWE401_Memory_Leak__int_calloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     CWE401_Memory_Leak__int_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_calloc_34_good	void CWE401_Memory_Leak__int_calloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_calloc_41_bad	void CWE401_Memory_Leak__int_calloc_41_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__int_calloc_41_good	void CWE401_Memory_Leak__int_calloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int * badSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
1	CWE401_Memory_Leak__int_calloc_42_bad	void CWE401_Memory_Leak__int_calloc_42_bad() {     int * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static int * goodG2BSource(int * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static int * goodB2GSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_calloc_42_good	void CWE401_Memory_Leak__int_calloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	bad	void bad() {     int * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(int * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_calloc_44_bad	void CWE401_Memory_Leak__int_calloc_44_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int_calloc_44_good	void CWE401_Memory_Leak__int_calloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int * data = CWE401_Memory_Leak__int_calloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_calloc_45_bad	void CWE401_Memory_Leak__int_calloc_45_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = CWE401_Memory_Leak__int_calloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = CWE401_Memory_Leak__int_calloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__int_calloc_45_good	void CWE401_Memory_Leak__int_calloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_51_bad	void CWE401_Memory_Leak__int_calloc_51_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_calloc_51_good	void CWE401_Memory_Leak__int_calloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_51b_badSink	void CWE401_Memory_Leak__int_calloc_51b_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_51b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_51b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_51b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_51b_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_52_bad	void CWE401_Memory_Leak__int_calloc_52_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_calloc_52_good	void CWE401_Memory_Leak__int_calloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_52b_badSink	void CWE401_Memory_Leak__int_calloc_52b_badSink(int * data) {     CWE401_Memory_Leak__int_calloc_52c_badSink(data); }
0	CWE401_Memory_Leak__int_calloc_52b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_52b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_calloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_52b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_52b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_calloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_calloc_52c_badSink	void CWE401_Memory_Leak__int_calloc_52c_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_52c_goodG2BSink	void CWE401_Memory_Leak__int_calloc_52c_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_52c_goodB2GSink	void CWE401_Memory_Leak__int_calloc_52c_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_53_bad	void CWE401_Memory_Leak__int_calloc_53_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_calloc_53_good	void CWE401_Memory_Leak__int_calloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_53b_badSink	void CWE401_Memory_Leak__int_calloc_53b_badSink(int * data) {     CWE401_Memory_Leak__int_calloc_53c_badSink(data); }
0	CWE401_Memory_Leak__int_calloc_53b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_53b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_calloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_53b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_53b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_calloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_calloc_53c_badSink	void CWE401_Memory_Leak__int_calloc_53c_badSink(int * data) {     CWE401_Memory_Leak__int_calloc_53d_badSink(data); }
0	CWE401_Memory_Leak__int_calloc_53c_goodG2BSink	void CWE401_Memory_Leak__int_calloc_53c_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_calloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_53c_goodB2GSink	void CWE401_Memory_Leak__int_calloc_53c_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_calloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_calloc_53d_badSink	void CWE401_Memory_Leak__int_calloc_53d_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_53d_goodG2BSink	void CWE401_Memory_Leak__int_calloc_53d_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_53d_goodB2GSink	void CWE401_Memory_Leak__int_calloc_53d_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_54_bad	void CWE401_Memory_Leak__int_calloc_54_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_calloc_54_good	void CWE401_Memory_Leak__int_calloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_54b_badSink	void CWE401_Memory_Leak__int_calloc_54b_badSink(int * data) {     CWE401_Memory_Leak__int_calloc_54c_badSink(data); }
0	CWE401_Memory_Leak__int_calloc_54b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_54b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_calloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_54b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_54b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_calloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_calloc_54c_badSink	void CWE401_Memory_Leak__int_calloc_54c_badSink(int * data) {     CWE401_Memory_Leak__int_calloc_54d_badSink(data); }
0	CWE401_Memory_Leak__int_calloc_54c_goodG2BSink	void CWE401_Memory_Leak__int_calloc_54c_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_calloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_54c_goodB2GSink	void CWE401_Memory_Leak__int_calloc_54c_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_calloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_calloc_54d_badSink	void CWE401_Memory_Leak__int_calloc_54d_badSink(int * data) {     CWE401_Memory_Leak__int_calloc_54e_badSink(data); }
0	CWE401_Memory_Leak__int_calloc_54d_goodG2BSink	void CWE401_Memory_Leak__int_calloc_54d_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_calloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_calloc_54d_goodB2GSink	void CWE401_Memory_Leak__int_calloc_54d_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_calloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_calloc_54e_badSink	void CWE401_Memory_Leak__int_calloc_54e_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_54e_goodG2BSink	void CWE401_Memory_Leak__int_calloc_54e_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_54e_goodB2GSink	void CWE401_Memory_Leak__int_calloc_54e_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_61_bad	void CWE401_Memory_Leak__int_calloc_61_bad() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_calloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_calloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_calloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_calloc_61_good	void CWE401_Memory_Leak__int_calloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_61b_badSource	int * CWE401_Memory_Leak__int_calloc_61b_badSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int_calloc_61b_goodG2BSource	int * CWE401_Memory_Leak__int_calloc_61b_goodG2BSource(int * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int_calloc_61b_goodB2GSource	int * CWE401_Memory_Leak__int_calloc_61b_goodB2GSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
1	bad	void bad() {     int * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodG2BSource	void goodG2BSource(int * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodB2GSource	void goodB2GSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	CWE401_Memory_Leak__int_calloc_63_bad	void CWE401_Memory_Leak__int_calloc_63_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int_calloc_63_good	void CWE401_Memory_Leak__int_calloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_63b_badSink	void CWE401_Memory_Leak__int_calloc_63b_badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_63b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_63b_goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_63b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_63b_goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_64_bad	void CWE401_Memory_Leak__int_calloc_64_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int_calloc_64_good	void CWE401_Memory_Leak__int_calloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_64b_badSink	void CWE401_Memory_Leak__int_calloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_64b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_64b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_65_bad	void CWE401_Memory_Leak__int_calloc_65_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_calloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_calloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_calloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int_calloc_65_good	void CWE401_Memory_Leak__int_calloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_65b_badSink	void CWE401_Memory_Leak__int_calloc_65b_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_65b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_65b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_65b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_65b_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_66_bad	void CWE401_Memory_Leak__int_calloc_66_bad() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__int_calloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int_calloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int_calloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__int_calloc_66_good	void CWE401_Memory_Leak__int_calloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_66b_badSink	void CWE401_Memory_Leak__int_calloc_66b_badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_66b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_66b_goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_66b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_66b_goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_67_bad	void CWE401_Memory_Leak__int_calloc_67_bad() {     int * data;     CWE401_Memory_Leak__int_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_calloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     CWE401_Memory_Leak__int_calloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_calloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     CWE401_Memory_Leak__int_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_calloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__int_calloc_67_good	void CWE401_Memory_Leak__int_calloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_67b_badSink	void CWE401_Memory_Leak__int_calloc_67b_badSink(CWE401_Memory_Leak__int_calloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_67b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_67b_goodG2BSink(CWE401_Memory_Leak__int_calloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_67b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_67b_goodB2GSink(CWE401_Memory_Leak__int_calloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_calloc_68_bad	void CWE401_Memory_Leak__int_calloc_68_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_68_badData = data;     CWE401_Memory_Leak__int_calloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_68_goodG2BData = data;     CWE401_Memory_Leak__int_calloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_68_goodB2GData = data;     CWE401_Memory_Leak__int_calloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__int_calloc_68_good	void CWE401_Memory_Leak__int_calloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_calloc_68b_badSink	void CWE401_Memory_Leak__int_calloc_68b_badSink() {     int * data = CWE401_Memory_Leak__int_calloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_68b_goodG2BSink	void CWE401_Memory_Leak__int_calloc_68b_goodG2BSink() {     int * data = CWE401_Memory_Leak__int_calloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_68b_goodB2GSink	void CWE401_Memory_Leak__int_calloc_68b_goodB2GSink() {     int * data = CWE401_Memory_Leak__int_calloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_calloc_81_bad::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int_calloc_81_goodB2G::action(int * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_calloc_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_calloc_81_base& baseObject = CWE401_Memory_Leak__int_calloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_calloc_81_base& baseObject = CWE401_Memory_Leak__int_calloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_calloc_81_base& baseObject = CWE401_Memory_Leak__int_calloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__int_calloc_82_bad::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int_calloc_82_goodB2G::action(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_calloc_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_82_base* baseObject = new CWE401_Memory_Leak__int_calloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_82_base* baseObject = new CWE401_Memory_Leak__int_calloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_calloc_82_base* baseObject = new CWE401_Memory_Leak__int_calloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__int_calloc_83_bad	CWE401_Memory_Leak__int_calloc_83_bad::CWE401_Memory_Leak__int_calloc_83_bad(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	~CWE401_Memory_Leak__int_calloc_83_bad	CWE401_Memory_Leak__int_calloc_83_bad::~CWE401_Memory_Leak__int_calloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_83_goodB2G	CWE401_Memory_Leak__int_calloc_83_goodB2G::CWE401_Memory_Leak__int_calloc_83_goodB2G(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_calloc_83_goodB2G	CWE401_Memory_Leak__int_calloc_83_goodB2G::~CWE401_Memory_Leak__int_calloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_calloc_83_goodG2B	CWE401_Memory_Leak__int_calloc_83_goodG2B::CWE401_Memory_Leak__int_calloc_83_goodG2B(int * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_calloc_83_goodG2B	CWE401_Memory_Leak__int_calloc_83_goodG2B::~CWE401_Memory_Leak__int_calloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_calloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_calloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_calloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__int_calloc_84_bad	CWE401_Memory_Leak__int_calloc_84_bad::CWE401_Memory_Leak__int_calloc_84_bad(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	~CWE401_Memory_Leak__int_calloc_84_bad	CWE401_Memory_Leak__int_calloc_84_bad::~CWE401_Memory_Leak__int_calloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_calloc_84_goodB2G	CWE401_Memory_Leak__int_calloc_84_goodB2G::CWE401_Memory_Leak__int_calloc_84_goodB2G(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)calloc(100, sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_calloc_84_goodB2G	CWE401_Memory_Leak__int_calloc_84_goodB2G::~CWE401_Memory_Leak__int_calloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_calloc_84_goodG2B	CWE401_Memory_Leak__int_calloc_84_goodG2B::CWE401_Memory_Leak__int_calloc_84_goodG2B(int * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_calloc_84_goodG2B	CWE401_Memory_Leak__int_calloc_84_goodG2B::~CWE401_Memory_Leak__int_calloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_calloc_84_bad * badObject = new CWE401_Memory_Leak__int_calloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_calloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__int_calloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_calloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__int_calloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__int_malloc_01_bad	void CWE401_Memory_Leak__int_malloc_01_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_malloc_01_good	void CWE401_Memory_Leak__int_malloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_02_bad	void CWE401_Memory_Leak__int_malloc_02_bad() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_02_good	void CWE401_Memory_Leak__int_malloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_03_bad	void CWE401_Memory_Leak__int_malloc_03_bad() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_03_good	void CWE401_Memory_Leak__int_malloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_04_bad	void CWE401_Memory_Leak__int_malloc_04_bad() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_04_good	void CWE401_Memory_Leak__int_malloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_05_bad	void CWE401_Memory_Leak__int_malloc_05_bad() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_05_good	void CWE401_Memory_Leak__int_malloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_06_bad	void CWE401_Memory_Leak__int_malloc_06_bad() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_06_good	void CWE401_Memory_Leak__int_malloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_07_bad	void CWE401_Memory_Leak__int_malloc_07_bad() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_07_good	void CWE401_Memory_Leak__int_malloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_08_bad	void CWE401_Memory_Leak__int_malloc_08_bad() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_08_good	void CWE401_Memory_Leak__int_malloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_09_bad	void CWE401_Memory_Leak__int_malloc_09_bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_09_good	void CWE401_Memory_Leak__int_malloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_10_bad	void CWE401_Memory_Leak__int_malloc_10_bad() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_10_good	void CWE401_Memory_Leak__int_malloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_11_bad	void CWE401_Memory_Leak__int_malloc_11_bad() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_11_good	void CWE401_Memory_Leak__int_malloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_12_bad	void CWE401_Memory_Leak__int_malloc_12_bad() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_12_good	void CWE401_Memory_Leak__int_malloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_malloc_13_bad	void CWE401_Memory_Leak__int_malloc_13_bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_13_good	void CWE401_Memory_Leak__int_malloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_14_bad	void CWE401_Memory_Leak__int_malloc_14_bad() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_14_good	void CWE401_Memory_Leak__int_malloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_15_bad	void CWE401_Memory_Leak__int_malloc_15_bad() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__int_malloc_15_good	void CWE401_Memory_Leak__int_malloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_malloc_16_bad	void CWE401_Memory_Leak__int_malloc_16_bad() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__int_malloc_16_good	void CWE401_Memory_Leak__int_malloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_malloc_17_bad	void CWE401_Memory_Leak__int_malloc_17_bad() {     int i,j;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_17_good	void CWE401_Memory_Leak__int_malloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_malloc_18_bad	void CWE401_Memory_Leak__int_malloc_18_bad() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_18_good	void CWE401_Memory_Leak__int_malloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int_malloc_21_bad	void CWE401_Memory_Leak__int_malloc_21_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_21_good	void CWE401_Memory_Leak__int_malloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int_malloc_22_bad	void CWE401_Memory_Leak__int_malloc_22_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__int_malloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__int_malloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__int_malloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__int_malloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_22_good	void CWE401_Memory_Leak__int_malloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int_malloc_22_badSink	void CWE401_Memory_Leak__int_malloc_22_badSink(int * data) {     if(CWE401_Memory_Leak__int_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_malloc_22_goodB2G1Sink	void CWE401_Memory_Leak__int_malloc_22_goodB2G1Sink(int * data) {     if(CWE401_Memory_Leak__int_malloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_malloc_22_goodB2G2Sink	void CWE401_Memory_Leak__int_malloc_22_goodB2G2Sink(int * data) {     if(CWE401_Memory_Leak__int_malloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_malloc_22_goodG2BSink	void CWE401_Memory_Leak__int_malloc_22_goodG2BSink(int * data) {     if(CWE401_Memory_Leak__int_malloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int_malloc_31_bad	void CWE401_Memory_Leak__int_malloc_31_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_malloc_31_good	void CWE401_Memory_Leak__int_malloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_32_bad	void CWE401_Memory_Leak__int_malloc_32_bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_malloc_32_good	void CWE401_Memory_Leak__int_malloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__int_malloc_34_bad	void CWE401_Memory_Leak__int_malloc_34_bad() {     int * data;     CWE401_Memory_Leak__int_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     CWE401_Memory_Leak__int_malloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     CWE401_Memory_Leak__int_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_malloc_34_good	void CWE401_Memory_Leak__int_malloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_malloc_41_bad	void CWE401_Memory_Leak__int_malloc_41_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__int_malloc_41_good	void CWE401_Memory_Leak__int_malloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int * badSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
1	CWE401_Memory_Leak__int_malloc_42_bad	void CWE401_Memory_Leak__int_malloc_42_bad() {     int * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static int * goodG2BSource(int * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static int * goodB2GSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_malloc_42_good	void CWE401_Memory_Leak__int_malloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	bad	void bad() {     int * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(int * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_malloc_44_bad	void CWE401_Memory_Leak__int_malloc_44_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int_malloc_44_good	void CWE401_Memory_Leak__int_malloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int * data = CWE401_Memory_Leak__int_malloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_malloc_45_bad	void CWE401_Memory_Leak__int_malloc_45_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = CWE401_Memory_Leak__int_malloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = CWE401_Memory_Leak__int_malloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__int_malloc_45_good	void CWE401_Memory_Leak__int_malloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_51_bad	void CWE401_Memory_Leak__int_malloc_51_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_malloc_51_good	void CWE401_Memory_Leak__int_malloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_51b_badSink	void CWE401_Memory_Leak__int_malloc_51b_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_51b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_51b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_51b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_51b_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_52_bad	void CWE401_Memory_Leak__int_malloc_52_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_malloc_52_good	void CWE401_Memory_Leak__int_malloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_52b_badSink	void CWE401_Memory_Leak__int_malloc_52b_badSink(int * data) {     CWE401_Memory_Leak__int_malloc_52c_badSink(data); }
0	CWE401_Memory_Leak__int_malloc_52b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_52b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_malloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_52b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_52b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_malloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_malloc_52c_badSink	void CWE401_Memory_Leak__int_malloc_52c_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_52c_goodG2BSink	void CWE401_Memory_Leak__int_malloc_52c_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_52c_goodB2GSink	void CWE401_Memory_Leak__int_malloc_52c_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_53_bad	void CWE401_Memory_Leak__int_malloc_53_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_malloc_53_good	void CWE401_Memory_Leak__int_malloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_53b_badSink	void CWE401_Memory_Leak__int_malloc_53b_badSink(int * data) {     CWE401_Memory_Leak__int_malloc_53c_badSink(data); }
0	CWE401_Memory_Leak__int_malloc_53b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_53b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_malloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_53b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_53b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_malloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_malloc_53c_badSink	void CWE401_Memory_Leak__int_malloc_53c_badSink(int * data) {     CWE401_Memory_Leak__int_malloc_53d_badSink(data); }
0	CWE401_Memory_Leak__int_malloc_53c_goodG2BSink	void CWE401_Memory_Leak__int_malloc_53c_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_malloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_53c_goodB2GSink	void CWE401_Memory_Leak__int_malloc_53c_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_malloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_malloc_53d_badSink	void CWE401_Memory_Leak__int_malloc_53d_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_53d_goodG2BSink	void CWE401_Memory_Leak__int_malloc_53d_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_53d_goodB2GSink	void CWE401_Memory_Leak__int_malloc_53d_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_54_bad	void CWE401_Memory_Leak__int_malloc_54_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_malloc_54_good	void CWE401_Memory_Leak__int_malloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_54b_badSink	void CWE401_Memory_Leak__int_malloc_54b_badSink(int * data) {     CWE401_Memory_Leak__int_malloc_54c_badSink(data); }
0	CWE401_Memory_Leak__int_malloc_54b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_54b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_malloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_54b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_54b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_malloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_malloc_54c_badSink	void CWE401_Memory_Leak__int_malloc_54c_badSink(int * data) {     CWE401_Memory_Leak__int_malloc_54d_badSink(data); }
0	CWE401_Memory_Leak__int_malloc_54c_goodG2BSink	void CWE401_Memory_Leak__int_malloc_54c_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_malloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_54c_goodB2GSink	void CWE401_Memory_Leak__int_malloc_54c_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_malloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_malloc_54d_badSink	void CWE401_Memory_Leak__int_malloc_54d_badSink(int * data) {     CWE401_Memory_Leak__int_malloc_54e_badSink(data); }
0	CWE401_Memory_Leak__int_malloc_54d_goodG2BSink	void CWE401_Memory_Leak__int_malloc_54d_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_malloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_malloc_54d_goodB2GSink	void CWE401_Memory_Leak__int_malloc_54d_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_malloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_malloc_54e_badSink	void CWE401_Memory_Leak__int_malloc_54e_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_54e_goodG2BSink	void CWE401_Memory_Leak__int_malloc_54e_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_54e_goodB2GSink	void CWE401_Memory_Leak__int_malloc_54e_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_61_bad	void CWE401_Memory_Leak__int_malloc_61_bad() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_malloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_malloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_malloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_malloc_61_good	void CWE401_Memory_Leak__int_malloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_61b_badSource	int * CWE401_Memory_Leak__int_malloc_61b_badSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int_malloc_61b_goodG2BSource	int * CWE401_Memory_Leak__int_malloc_61b_goodG2BSource(int * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int_malloc_61b_goodB2GSource	int * CWE401_Memory_Leak__int_malloc_61b_goodB2GSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
1	bad	void bad() {     int * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodG2BSource	void goodG2BSource(int * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodB2GSource	void goodB2GSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	CWE401_Memory_Leak__int_malloc_63_bad	void CWE401_Memory_Leak__int_malloc_63_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int_malloc_63_good	void CWE401_Memory_Leak__int_malloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_63b_badSink	void CWE401_Memory_Leak__int_malloc_63b_badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_63b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_63b_goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_63b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_63b_goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_64_bad	void CWE401_Memory_Leak__int_malloc_64_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int_malloc_64_good	void CWE401_Memory_Leak__int_malloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_64b_badSink	void CWE401_Memory_Leak__int_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_64b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_64b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_65_bad	void CWE401_Memory_Leak__int_malloc_65_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_malloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_malloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_malloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int_malloc_65_good	void CWE401_Memory_Leak__int_malloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_65b_badSink	void CWE401_Memory_Leak__int_malloc_65b_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_65b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_65b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_65b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_65b_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_66_bad	void CWE401_Memory_Leak__int_malloc_66_bad() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__int_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int_malloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int_malloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__int_malloc_66_good	void CWE401_Memory_Leak__int_malloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_66b_badSink	void CWE401_Memory_Leak__int_malloc_66b_badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_66b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_66b_goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_66b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_66b_goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_67_bad	void CWE401_Memory_Leak__int_malloc_67_bad() {     int * data;     CWE401_Memory_Leak__int_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     CWE401_Memory_Leak__int_malloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_malloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     CWE401_Memory_Leak__int_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_malloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__int_malloc_67_good	void CWE401_Memory_Leak__int_malloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_67b_badSink	void CWE401_Memory_Leak__int_malloc_67b_badSink(CWE401_Memory_Leak__int_malloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_67b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_67b_goodG2BSink(CWE401_Memory_Leak__int_malloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_67b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_67b_goodB2GSink(CWE401_Memory_Leak__int_malloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_malloc_68_bad	void CWE401_Memory_Leak__int_malloc_68_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_68_badData = data;     CWE401_Memory_Leak__int_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_68_goodG2BData = data;     CWE401_Memory_Leak__int_malloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_68_goodB2GData = data;     CWE401_Memory_Leak__int_malloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__int_malloc_68_good	void CWE401_Memory_Leak__int_malloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_malloc_68b_badSink	void CWE401_Memory_Leak__int_malloc_68b_badSink() {     int * data = CWE401_Memory_Leak__int_malloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_68b_goodG2BSink	void CWE401_Memory_Leak__int_malloc_68b_goodG2BSink() {     int * data = CWE401_Memory_Leak__int_malloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_68b_goodB2GSink	void CWE401_Memory_Leak__int_malloc_68b_goodB2GSink() {     int * data = CWE401_Memory_Leak__int_malloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_malloc_81_bad::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int_malloc_81_goodB2G::action(int * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_malloc_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_malloc_81_base& baseObject = CWE401_Memory_Leak__int_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_malloc_81_base& baseObject = CWE401_Memory_Leak__int_malloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_malloc_81_base& baseObject = CWE401_Memory_Leak__int_malloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__int_malloc_82_bad::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int_malloc_82_goodB2G::action(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_malloc_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_82_base* baseObject = new CWE401_Memory_Leak__int_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_82_base* baseObject = new CWE401_Memory_Leak__int_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_malloc_82_base* baseObject = new CWE401_Memory_Leak__int_malloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__int_malloc_83_bad	CWE401_Memory_Leak__int_malloc_83_bad::CWE401_Memory_Leak__int_malloc_83_bad(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	~CWE401_Memory_Leak__int_malloc_83_bad	CWE401_Memory_Leak__int_malloc_83_bad::~CWE401_Memory_Leak__int_malloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_83_goodB2G	CWE401_Memory_Leak__int_malloc_83_goodB2G::CWE401_Memory_Leak__int_malloc_83_goodB2G(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_malloc_83_goodB2G	CWE401_Memory_Leak__int_malloc_83_goodB2G::~CWE401_Memory_Leak__int_malloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_malloc_83_goodG2B	CWE401_Memory_Leak__int_malloc_83_goodG2B::CWE401_Memory_Leak__int_malloc_83_goodG2B(int * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_malloc_83_goodG2B	CWE401_Memory_Leak__int_malloc_83_goodG2B::~CWE401_Memory_Leak__int_malloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_malloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_malloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__int_malloc_84_bad	CWE401_Memory_Leak__int_malloc_84_bad::CWE401_Memory_Leak__int_malloc_84_bad(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	~CWE401_Memory_Leak__int_malloc_84_bad	CWE401_Memory_Leak__int_malloc_84_bad::~CWE401_Memory_Leak__int_malloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_malloc_84_goodB2G	CWE401_Memory_Leak__int_malloc_84_goodB2G::CWE401_Memory_Leak__int_malloc_84_goodB2G(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_malloc_84_goodB2G	CWE401_Memory_Leak__int_malloc_84_goodB2G::~CWE401_Memory_Leak__int_malloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_malloc_84_goodG2B	CWE401_Memory_Leak__int_malloc_84_goodG2B::CWE401_Memory_Leak__int_malloc_84_goodG2B(int * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_malloc_84_goodG2B	CWE401_Memory_Leak__int_malloc_84_goodG2B::~CWE401_Memory_Leak__int_malloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_malloc_84_bad * badObject = new CWE401_Memory_Leak__int_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_malloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__int_malloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_malloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__int_malloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__int_realloc_01_bad	void CWE401_Memory_Leak__int_realloc_01_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_realloc_01_good	void CWE401_Memory_Leak__int_realloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_02_bad	void CWE401_Memory_Leak__int_realloc_02_bad() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_02_good	void CWE401_Memory_Leak__int_realloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_03_bad	void CWE401_Memory_Leak__int_realloc_03_bad() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_03_good	void CWE401_Memory_Leak__int_realloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_04_bad	void CWE401_Memory_Leak__int_realloc_04_bad() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_04_good	void CWE401_Memory_Leak__int_realloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_05_bad	void CWE401_Memory_Leak__int_realloc_05_bad() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_05_good	void CWE401_Memory_Leak__int_realloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_06_bad	void CWE401_Memory_Leak__int_realloc_06_bad() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_06_good	void CWE401_Memory_Leak__int_realloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_07_bad	void CWE401_Memory_Leak__int_realloc_07_bad() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_07_good	void CWE401_Memory_Leak__int_realloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_08_bad	void CWE401_Memory_Leak__int_realloc_08_bad() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_08_good	void CWE401_Memory_Leak__int_realloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_09_bad	void CWE401_Memory_Leak__int_realloc_09_bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_09_good	void CWE401_Memory_Leak__int_realloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_10_bad	void CWE401_Memory_Leak__int_realloc_10_bad() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_10_good	void CWE401_Memory_Leak__int_realloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_11_bad	void CWE401_Memory_Leak__int_realloc_11_bad() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_11_good	void CWE401_Memory_Leak__int_realloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_12_bad	void CWE401_Memory_Leak__int_realloc_12_bad() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_12_good	void CWE401_Memory_Leak__int_realloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_realloc_13_bad	void CWE401_Memory_Leak__int_realloc_13_bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_13_good	void CWE401_Memory_Leak__int_realloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_14_bad	void CWE401_Memory_Leak__int_realloc_14_bad() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_14_good	void CWE401_Memory_Leak__int_realloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_15_bad	void CWE401_Memory_Leak__int_realloc_15_bad() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__int_realloc_15_good	void CWE401_Memory_Leak__int_realloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__int_realloc_16_bad	void CWE401_Memory_Leak__int_realloc_16_bad() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__int_realloc_16_good	void CWE401_Memory_Leak__int_realloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_realloc_17_bad	void CWE401_Memory_Leak__int_realloc_17_bad() {     int i,j;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_17_good	void CWE401_Memory_Leak__int_realloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__int_realloc_18_bad	void CWE401_Memory_Leak__int_realloc_18_bad() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_18_good	void CWE401_Memory_Leak__int_realloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int_realloc_21_bad	void CWE401_Memory_Leak__int_realloc_21_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_21_good	void CWE401_Memory_Leak__int_realloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int_realloc_22_bad	void CWE401_Memory_Leak__int_realloc_22_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__int_realloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__int_realloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__int_realloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__int_realloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_22_good	void CWE401_Memory_Leak__int_realloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__int_realloc_22_badSink	void CWE401_Memory_Leak__int_realloc_22_badSink(int * data) {     if(CWE401_Memory_Leak__int_realloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__int_realloc_22_goodB2G1Sink	void CWE401_Memory_Leak__int_realloc_22_goodB2G1Sink(int * data) {     if(CWE401_Memory_Leak__int_realloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_realloc_22_goodB2G2Sink	void CWE401_Memory_Leak__int_realloc_22_goodB2G2Sink(int * data) {     if(CWE401_Memory_Leak__int_realloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_realloc_22_goodG2BSink	void CWE401_Memory_Leak__int_realloc_22_goodG2BSink(int * data) {     if(CWE401_Memory_Leak__int_realloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__int_realloc_31_bad	void CWE401_Memory_Leak__int_realloc_31_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_realloc_31_good	void CWE401_Memory_Leak__int_realloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_32_bad	void CWE401_Memory_Leak__int_realloc_32_bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (int *)ALLOCA(100*sizeof(int));         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (int *)realloc(data, 100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_realloc_32_good	void CWE401_Memory_Leak__int_realloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__int_realloc_34_bad	void CWE401_Memory_Leak__int_realloc_34_bad() {     int * data;     CWE401_Memory_Leak__int_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     CWE401_Memory_Leak__int_realloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     CWE401_Memory_Leak__int_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__int_realloc_34_good	void CWE401_Memory_Leak__int_realloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_realloc_41_bad	void CWE401_Memory_Leak__int_realloc_41_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__int_realloc_41_good	void CWE401_Memory_Leak__int_realloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int * badSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
1	CWE401_Memory_Leak__int_realloc_42_bad	void CWE401_Memory_Leak__int_realloc_42_bad() {     int * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static int * goodG2BSource(int * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static int * goodB2GSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_realloc_42_good	void CWE401_Memory_Leak__int_realloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	bad	void bad() {     int * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(int * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_realloc_44_bad	void CWE401_Memory_Leak__int_realloc_44_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int_realloc_44_good	void CWE401_Memory_Leak__int_realloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int * data = CWE401_Memory_Leak__int_realloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__int_realloc_45_bad	void CWE401_Memory_Leak__int_realloc_45_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = CWE401_Memory_Leak__int_realloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = CWE401_Memory_Leak__int_realloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__int_realloc_45_good	void CWE401_Memory_Leak__int_realloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_51_bad	void CWE401_Memory_Leak__int_realloc_51_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_realloc_51_good	void CWE401_Memory_Leak__int_realloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_51b_badSink	void CWE401_Memory_Leak__int_realloc_51b_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_51b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_51b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_51b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_51b_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_52_bad	void CWE401_Memory_Leak__int_realloc_52_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_realloc_52_good	void CWE401_Memory_Leak__int_realloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_52b_badSink	void CWE401_Memory_Leak__int_realloc_52b_badSink(int * data) {     CWE401_Memory_Leak__int_realloc_52c_badSink(data); }
0	CWE401_Memory_Leak__int_realloc_52b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_52b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_realloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_52b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_52b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_realloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_realloc_52c_badSink	void CWE401_Memory_Leak__int_realloc_52c_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_52c_goodG2BSink	void CWE401_Memory_Leak__int_realloc_52c_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_52c_goodB2GSink	void CWE401_Memory_Leak__int_realloc_52c_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_53_bad	void CWE401_Memory_Leak__int_realloc_53_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_realloc_53_good	void CWE401_Memory_Leak__int_realloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_53b_badSink	void CWE401_Memory_Leak__int_realloc_53b_badSink(int * data) {     CWE401_Memory_Leak__int_realloc_53c_badSink(data); }
0	CWE401_Memory_Leak__int_realloc_53b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_53b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_realloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_53b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_53b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_realloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_realloc_53c_badSink	void CWE401_Memory_Leak__int_realloc_53c_badSink(int * data) {     CWE401_Memory_Leak__int_realloc_53d_badSink(data); }
0	CWE401_Memory_Leak__int_realloc_53c_goodG2BSink	void CWE401_Memory_Leak__int_realloc_53c_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_realloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_53c_goodB2GSink	void CWE401_Memory_Leak__int_realloc_53c_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_realloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_realloc_53d_badSink	void CWE401_Memory_Leak__int_realloc_53d_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_53d_goodG2BSink	void CWE401_Memory_Leak__int_realloc_53d_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_53d_goodB2GSink	void CWE401_Memory_Leak__int_realloc_53d_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_54_bad	void CWE401_Memory_Leak__int_realloc_54_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__int_realloc_54_good	void CWE401_Memory_Leak__int_realloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_54b_badSink	void CWE401_Memory_Leak__int_realloc_54b_badSink(int * data) {     CWE401_Memory_Leak__int_realloc_54c_badSink(data); }
0	CWE401_Memory_Leak__int_realloc_54b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_54b_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_realloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_54b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_54b_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_realloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_realloc_54c_badSink	void CWE401_Memory_Leak__int_realloc_54c_badSink(int * data) {     CWE401_Memory_Leak__int_realloc_54d_badSink(data); }
0	CWE401_Memory_Leak__int_realloc_54c_goodG2BSink	void CWE401_Memory_Leak__int_realloc_54c_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_realloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_54c_goodB2GSink	void CWE401_Memory_Leak__int_realloc_54c_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_realloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_realloc_54d_badSink	void CWE401_Memory_Leak__int_realloc_54d_badSink(int * data) {     CWE401_Memory_Leak__int_realloc_54e_badSink(data); }
0	CWE401_Memory_Leak__int_realloc_54d_goodG2BSink	void CWE401_Memory_Leak__int_realloc_54d_goodG2BSink(int * data) {     CWE401_Memory_Leak__int_realloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__int_realloc_54d_goodB2GSink	void CWE401_Memory_Leak__int_realloc_54d_goodB2GSink(int * data) {     CWE401_Memory_Leak__int_realloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__int_realloc_54e_badSink	void CWE401_Memory_Leak__int_realloc_54e_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_54e_goodG2BSink	void CWE401_Memory_Leak__int_realloc_54e_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_54e_goodB2GSink	void CWE401_Memory_Leak__int_realloc_54e_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_61_bad	void CWE401_Memory_Leak__int_realloc_61_bad() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_realloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_realloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     data = CWE401_Memory_Leak__int_realloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_realloc_61_good	void CWE401_Memory_Leak__int_realloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_61b_badSource	int * CWE401_Memory_Leak__int_realloc_61b_badSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int_realloc_61b_goodG2BSource	int * CWE401_Memory_Leak__int_realloc_61b_goodG2BSource(int * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
0	CWE401_Memory_Leak__int_realloc_61b_goodB2GSource	int * CWE401_Memory_Leak__int_realloc_61b_goodB2GSource(int * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     return data; }
1	bad	void bad() {     int * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodG2BSource	void goodG2BSource(int * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	goodB2GSource	void goodB2GSource(int * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	CWE401_Memory_Leak__int_realloc_63_bad	void CWE401_Memory_Leak__int_realloc_63_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int_realloc_63_good	void CWE401_Memory_Leak__int_realloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_63b_badSink	void CWE401_Memory_Leak__int_realloc_63b_badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_63b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_63b_goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_63b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_63b_goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_64_bad	void CWE401_Memory_Leak__int_realloc_64_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__int_realloc_64_good	void CWE401_Memory_Leak__int_realloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_64b_badSink	void CWE401_Memory_Leak__int_realloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_64b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_64b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_65_bad	void CWE401_Memory_Leak__int_realloc_65_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_realloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_realloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = CWE401_Memory_Leak__int_realloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__int_realloc_65_good	void CWE401_Memory_Leak__int_realloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_65b_badSink	void CWE401_Memory_Leak__int_realloc_65b_badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_65b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_65b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_65b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_65b_goodB2GSink(int * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_66_bad	void CWE401_Memory_Leak__int_realloc_66_bad() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__int_realloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int_realloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__int_realloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__int_realloc_66_good	void CWE401_Memory_Leak__int_realloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_66b_badSink	void CWE401_Memory_Leak__int_realloc_66b_badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_66b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_66b_goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_66b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_66b_goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_67_bad	void CWE401_Memory_Leak__int_realloc_67_bad() {     int * data;     CWE401_Memory_Leak__int_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_realloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     CWE401_Memory_Leak__int_realloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_realloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     CWE401_Memory_Leak__int_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__int_realloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__int_realloc_67_good	void CWE401_Memory_Leak__int_realloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_67b_badSink	void CWE401_Memory_Leak__int_realloc_67b_badSink(CWE401_Memory_Leak__int_realloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_67b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_67b_goodG2BSink(CWE401_Memory_Leak__int_realloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_67b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_67b_goodB2GSink(CWE401_Memory_Leak__int_realloc_67_structType myStruct) {     int * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__int_realloc_68_bad	void CWE401_Memory_Leak__int_realloc_68_bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_68_badData = data;     CWE401_Memory_Leak__int_realloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_68_goodG2BData = data;     CWE401_Memory_Leak__int_realloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_68_goodB2GData = data;     CWE401_Memory_Leak__int_realloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__int_realloc_68_good	void CWE401_Memory_Leak__int_realloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__int_realloc_68b_badSink	void CWE401_Memory_Leak__int_realloc_68b_badSink() {     int * data = CWE401_Memory_Leak__int_realloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_68b_goodG2BSink	void CWE401_Memory_Leak__int_realloc_68b_goodG2BSink() {     int * data = CWE401_Memory_Leak__int_realloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_68b_goodB2GSink	void CWE401_Memory_Leak__int_realloc_68b_goodB2GSink() {     int * data = CWE401_Memory_Leak__int_realloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_realloc_81_bad::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int_realloc_81_goodB2G::action(int * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_realloc_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_realloc_81_base& baseObject = CWE401_Memory_Leak__int_realloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_realloc_81_base& baseObject = CWE401_Memory_Leak__int_realloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__int_realloc_81_base& baseObject = CWE401_Memory_Leak__int_realloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__int_realloc_82_bad::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__int_realloc_82_goodB2G::action(int * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__int_realloc_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_82_base* baseObject = new CWE401_Memory_Leak__int_realloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_82_base* baseObject = new CWE401_Memory_Leak__int_realloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__int_realloc_82_base* baseObject = new CWE401_Memory_Leak__int_realloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__int_realloc_83_bad	CWE401_Memory_Leak__int_realloc_83_bad::CWE401_Memory_Leak__int_realloc_83_bad(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	~CWE401_Memory_Leak__int_realloc_83_bad	CWE401_Memory_Leak__int_realloc_83_bad::~CWE401_Memory_Leak__int_realloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_83_goodB2G	CWE401_Memory_Leak__int_realloc_83_goodB2G::CWE401_Memory_Leak__int_realloc_83_goodB2G(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_realloc_83_goodB2G	CWE401_Memory_Leak__int_realloc_83_goodB2G::~CWE401_Memory_Leak__int_realloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_realloc_83_goodG2B	CWE401_Memory_Leak__int_realloc_83_goodG2B::CWE401_Memory_Leak__int_realloc_83_goodG2B(int * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_realloc_83_goodG2B	CWE401_Memory_Leak__int_realloc_83_goodG2B::~CWE401_Memory_Leak__int_realloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_realloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_realloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_realloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__int_realloc_84_bad	CWE401_Memory_Leak__int_realloc_84_bad::CWE401_Memory_Leak__int_realloc_84_bad(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
1	~CWE401_Memory_Leak__int_realloc_84_bad	CWE401_Memory_Leak__int_realloc_84_bad::~CWE401_Memory_Leak__int_realloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__int_realloc_84_goodB2G	CWE401_Memory_Leak__int_realloc_84_goodB2G::CWE401_Memory_Leak__int_realloc_84_goodB2G(int * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (int *)realloc(data, 100*sizeof(int));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_realloc_84_goodB2G	CWE401_Memory_Leak__int_realloc_84_goodB2G::~CWE401_Memory_Leak__int_realloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__int_realloc_84_goodG2B	CWE401_Memory_Leak__int_realloc_84_goodG2B::CWE401_Memory_Leak__int_realloc_84_goodG2B(int * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (int *)ALLOCA(100*sizeof(int));     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]); }
0	~CWE401_Memory_Leak__int_realloc_84_goodG2B	CWE401_Memory_Leak__int_realloc_84_goodG2B::~CWE401_Memory_Leak__int_realloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_realloc_84_bad * badObject = new CWE401_Memory_Leak__int_realloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_realloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__int_realloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     CWE401_Memory_Leak__int_realloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__int_realloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__malloc_realloc_char_01_bad	void CWE401_Memory_Leak__malloc_realloc_char_01_bad() {     {         char * data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (char *)realloc(data, (130000)*sizeof(char));         if (data != NULL)         {             /* Reinitialize and make use of data */             strcpy(data, "New String");             printLine(data);             free(data);         }     } }
0	good1	static void good1() {     {         char * data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         char * tmpData;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         tmpData = (char *)realloc(data, (130000)*sizeof(char));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             strcpy(data, "New String");             printLine(data);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_char_01_good	void CWE401_Memory_Leak__malloc_realloc_char_01_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_char_02_bad	void CWE401_Memory_Leak__malloc_realloc_char_02_bad() {     if(1)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(1)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_02_good	void CWE401_Memory_Leak__malloc_realloc_char_02_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_03_bad	void CWE401_Memory_Leak__malloc_realloc_char_03_bad() {     if(5==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(5==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_03_good	void CWE401_Memory_Leak__malloc_realloc_char_03_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_04_bad	void CWE401_Memory_Leak__malloc_realloc_char_04_bad() {     if(STATIC_CONST_TRUE)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_04_good	void CWE401_Memory_Leak__malloc_realloc_char_04_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_05_bad	void CWE401_Memory_Leak__malloc_realloc_char_05_bad() {     if(staticTrue)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticTrue)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_05_good	void CWE401_Memory_Leak__malloc_realloc_char_05_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_06_bad	void CWE401_Memory_Leak__malloc_realloc_char_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_06_good	void CWE401_Memory_Leak__malloc_realloc_char_06_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_07_bad	void CWE401_Memory_Leak__malloc_realloc_char_07_bad() {     if(staticFive==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticFive==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_07_good	void CWE401_Memory_Leak__malloc_realloc_char_07_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_08_bad	void CWE401_Memory_Leak__malloc_realloc_char_08_bad() {     if(staticReturnsTrue())     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_08_good	void CWE401_Memory_Leak__malloc_realloc_char_08_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_09_bad	void CWE401_Memory_Leak__malloc_realloc_char_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_09_good	void CWE401_Memory_Leak__malloc_realloc_char_09_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_10_bad	void CWE401_Memory_Leak__malloc_realloc_char_10_bad() {     if(globalTrue)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalTrue)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_10_good	void CWE401_Memory_Leak__malloc_realloc_char_10_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_11_bad	void CWE401_Memory_Leak__malloc_realloc_char_11_bad() {     if(globalReturnsTrue())     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_11_good	void CWE401_Memory_Leak__malloc_realloc_char_11_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_12_bad	void CWE401_Memory_Leak__malloc_realloc_char_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);           ...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */   ...
0	CWE401_Memory_Leak__malloc_realloc_char_12_good	void CWE401_Memory_Leak__malloc_realloc_char_12_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_char_13_bad	void CWE401_Memory_Leak__malloc_realloc_char_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_13_good	void CWE401_Memory_Leak__malloc_realloc_char_13_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_14_bad	void CWE401_Memory_Leak__malloc_realloc_char_14_bad() {     if(globalFive==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalFive==5)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_14_good	void CWE401_Memory_Leak__malloc_realloc_char_14_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_15_bad	void CWE401_Memory_Leak__malloc_realloc_char_15_bad() {     switch(6)     {     case 6:     {         char * data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (char *)realloc(data, (130000)*sizeof(char));         if (data != NULL)         {             /* Reinitialize and make use of data */             strcpy(data, "New String");             printLine(data);             free(data);         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         char * data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         char * tmpData;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         tmpData = (char *)realloc(data, (130000)*sizeof(char));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             strcpy(data, "New String");             printLine(data);         }         free(data);     }     break;     } }
0	good2	static void good2() {     switch(6)     {     case 6:     {         char * data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         char * tmpData;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         tmpData = (char *)realloc(data, (130000)*sizeof(char));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             strcpy(data, "New String");             printLine(data);         }         free(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_char_15_good	void CWE401_Memory_Leak__malloc_realloc_char_15_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_char_16_bad	void CWE401_Memory_Leak__malloc_realloc_char_16_bad() {     while(1)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_char_16_good	void CWE401_Memory_Leak__malloc_realloc_char_16_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_char_17_bad	void CWE401_Memory_Leak__malloc_realloc_char_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (char *)realloc(data, (130000)*sizeof(char));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             char * data = (char *)malloc(100*sizeof(char));             if (data == NULL) {exit(-1);}             char * tmpData;             /* Initialize and make use of data */             strcpy(data, "A String");             printLine(data);             tmpData = (char *)realloc(data, (130000)*sizeof(char));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 strcpy(data, "New String");                 printLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_char_17_good	void CWE401_Memory_Leak__malloc_realloc_char_17_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_char_18_bad	void CWE401_Memory_Leak__malloc_realloc_char_18_bad() {     goto sink; sink:     {         char * data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (char *)realloc(data, (130000)*sizeof(char));         if (data != NULL)         {             /* Reinitialize and make use of data */             strcpy(data, "New String");             printLine(data);             free(data);         }     } }
0	good1	static void good1() {     goto sink; sink:     {         char * data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         char * tmpData;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         tmpData = (char *)realloc(data, (130000)*sizeof(char));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             strcpy(data, "New String");             printLine(data);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_char_18_good	void CWE401_Memory_Leak__malloc_realloc_char_18_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_01_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_01_bad() {     {         int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0] = 10LL;             printLongLongLine(data[0]);             free(data);         }     } }
0	good1	static void good1() {     {         int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         int64_t * tmpData;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10LL;             printLongLongLine(data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_01_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_01_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_02_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_02_bad() {     if(1)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(1)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_02_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_02_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_03_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_03_bad() {     if(5==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(5==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_03_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_03_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_04_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_04_bad() {     if(STATIC_CONST_TRUE)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_04_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_04_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_05_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_05_bad() {     if(staticTrue)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticTrue)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_05_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_05_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_06_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_06_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_06_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_07_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_07_bad() {     if(staticFive==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticFive==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_07_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_07_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_08_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_08_bad() {     if(staticReturnsTrue())     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_08_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_08_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_09_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_09_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_09_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_10_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_10_bad() {     if(globalTrue)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalTrue)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_10_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_10_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_11_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_11_bad() {     if(globalReturnsTrue())     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_11_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_11_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_12_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLong...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initiali...
0	CWE401_Memory_Leak__malloc_realloc_int64_t_12_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_12_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_13_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_13_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_13_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_14_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_14_bad() {     if(globalFive==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalFive==5)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_14_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_14_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_15_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_15_bad() {     switch(6)     {     case 6:     {         int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0] = 10LL;             printLongLongLine(data[0]);             free(data);         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         int64_t * tmpData;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10LL;             printLongLongLine(data[0]);         }         free(data);     }     break;     } }
0	good2	static void good2() {     switch(6)     {     case 6:     {         int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         int64_t * tmpData;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10LL;             printLongLongLine(data[0]);         }         free(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_15_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_15_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_16_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_16_bad() {     while(1)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_16_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_16_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_17_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));             if (data == NULL) {exit(-1);}             int64_t * tmpData;             /* Initialize and make use of data */             data[0] = 5LL;             printLongLongLine(data[0]);             tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10LL;                 printLongLongLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_17_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_17_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int64_t_18_bad	void CWE401_Memory_Leak__malloc_realloc_int64_t_18_bad() {     goto sink; sink:     {         int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (int64_t *)realloc(data, (130000)*sizeof(int64_t));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0] = 10LL;             printLongLongLine(data[0]);             free(data);         }     } }
0	good1	static void good1() {     goto sink; sink:     {         int64_t * data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         int64_t * tmpData;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         tmpData = (int64_t *)realloc(data, (130000)*sizeof(int64_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10LL;             printLongLongLine(data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_int64_t_18_good	void CWE401_Memory_Leak__malloc_realloc_int64_t_18_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int_01_bad	void CWE401_Memory_Leak__malloc_realloc_int_01_bad() {     {         int * data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (int *)realloc(data, (130000)*sizeof(int));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0] = 10;             printIntLine(data[0]);             free(data);         }     } }
0	good1	static void good1() {     {         int * data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         int * tmpData;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         tmpData = (int *)realloc(data, (130000)*sizeof(int));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10;             printIntLine(data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_int_01_good	void CWE401_Memory_Leak__malloc_realloc_int_01_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int_02_bad	void CWE401_Memory_Leak__malloc_realloc_int_02_bad() {     if(1)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(1)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_02_good	void CWE401_Memory_Leak__malloc_realloc_int_02_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_03_bad	void CWE401_Memory_Leak__malloc_realloc_int_03_bad() {     if(5==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(5==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_03_good	void CWE401_Memory_Leak__malloc_realloc_int_03_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_04_bad	void CWE401_Memory_Leak__malloc_realloc_int_04_bad() {     if(STATIC_CONST_TRUE)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_04_good	void CWE401_Memory_Leak__malloc_realloc_int_04_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_05_bad	void CWE401_Memory_Leak__malloc_realloc_int_05_bad() {     if(staticTrue)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticTrue)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_05_good	void CWE401_Memory_Leak__malloc_realloc_int_05_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_06_bad	void CWE401_Memory_Leak__malloc_realloc_int_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_06_good	void CWE401_Memory_Leak__malloc_realloc_int_06_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_07_bad	void CWE401_Memory_Leak__malloc_realloc_int_07_bad() {     if(staticFive==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticFive==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_07_good	void CWE401_Memory_Leak__malloc_realloc_int_07_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_08_bad	void CWE401_Memory_Leak__malloc_realloc_int_08_bad() {     if(staticReturnsTrue())     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_08_good	void CWE401_Memory_Leak__malloc_realloc_int_08_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_09_bad	void CWE401_Memory_Leak__malloc_realloc_int_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_09_good	void CWE401_Memory_Leak__malloc_realloc_int_09_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_10_bad	void CWE401_Memory_Leak__malloc_realloc_int_10_bad() {     if(globalTrue)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalTrue)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_10_good	void CWE401_Memory_Leak__malloc_realloc_int_10_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_11_bad	void CWE401_Memory_Leak__malloc_realloc_int_11_bad() {     if(globalReturnsTrue())     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_11_good	void CWE401_Memory_Leak__malloc_realloc_int_11_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_12_bad	void CWE401_Memory_Leak__malloc_realloc_int_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data,...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;   ...
0	CWE401_Memory_Leak__malloc_realloc_int_12_good	void CWE401_Memory_Leak__malloc_realloc_int_12_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int_13_bad	void CWE401_Memory_Leak__malloc_realloc_int_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_13_good	void CWE401_Memory_Leak__malloc_realloc_int_13_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_14_bad	void CWE401_Memory_Leak__malloc_realloc_int_14_bad() {     if(globalFive==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalFive==5)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_14_good	void CWE401_Memory_Leak__malloc_realloc_int_14_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_15_bad	void CWE401_Memory_Leak__malloc_realloc_int_15_bad() {     switch(6)     {     case 6:     {         int * data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (int *)realloc(data, (130000)*sizeof(int));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0] = 10;             printIntLine(data[0]);             free(data);         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         int * data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         int * tmpData;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         tmpData = (int *)realloc(data, (130000)*sizeof(int));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10;             printIntLine(data[0]);         }         free(data);     }     break;     } }
0	good2	static void good2() {     switch(6)     {     case 6:     {         int * data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         int * tmpData;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         tmpData = (int *)realloc(data, (130000)*sizeof(int));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10;             printIntLine(data[0]);         }         free(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_int_15_good	void CWE401_Memory_Leak__malloc_realloc_int_15_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_int_16_bad	void CWE401_Memory_Leak__malloc_realloc_int_16_bad() {     while(1)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_int_16_good	void CWE401_Memory_Leak__malloc_realloc_int_16_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int_17_bad	void CWE401_Memory_Leak__malloc_realloc_int_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (int *)realloc(data, (130000)*sizeof(int));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             int * data = (int *)malloc(100*sizeof(int));             if (data == NULL) {exit(-1);}             int * tmpData;             /* Initialize and make use of data */             data[0] = 5;             printIntLine(data[0]);             tmpData = (int *)realloc(data, (130000)*sizeof(int));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0] = 10;                 printIntLine(data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_int_17_good	void CWE401_Memory_Leak__malloc_realloc_int_17_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_int_18_bad	void CWE401_Memory_Leak__malloc_realloc_int_18_bad() {     goto sink; sink:     {         int * data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (int *)realloc(data, (130000)*sizeof(int));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0] = 10;             printIntLine(data[0]);             free(data);         }     } }
0	good1	static void good1() {     goto sink; sink:     {         int * data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         int * tmpData;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         tmpData = (int *)realloc(data, (130000)*sizeof(int));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0] = 10;             printIntLine(data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_int_18_good	void CWE401_Memory_Leak__malloc_realloc_int_18_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_01_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_01_bad() {     {         struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine((twoIntsStruct *)&data[0]);             free(data);         }     } }
0	good1	static void good1() {     {         struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         struct _twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine((twoIntsStruct *)&data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_01_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_01_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_02_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_02_bad() {     if(1)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = ...
0	good2	static void good2() {     if(1)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_02_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_02_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_03_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_03_bad() {     if(5==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo...
0	good2	static void good2() {     if(5==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_03_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_03_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_04_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_04_bad() {     if(STATIC_CONST_TRUE)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 ...
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_04_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_04_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_05_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_05_bad() {     if(staticTrue)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0]...
0	good2	static void good2() {     if(staticTrue)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_05_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_05_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_06_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;               ...
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_06_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_06_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_07_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_07_bad() {     if(staticFive==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[...
0	good2	static void good2() {     if(staticFive==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_07_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_07_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_08_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_08_bad() {     if(staticReturnsTrue())     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;               ...
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_08_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_08_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_09_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 ...
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_09_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_09_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_10_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_10_bad() {     if(globalTrue)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0]...
0	good2	static void good2() {     if(globalTrue)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_10_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_10_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_11_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_11_bad() {     if(globalReturnsTrue())     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;               ...
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_11_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_11_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_12_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     }     else     {         {             struct _twoIntsStruct * data = (stru...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }    ...
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_12_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_12_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_13_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;               ...
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_13_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_13_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_14_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_14_bad() {     if(globalFive==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[...
0	good2	static void good2() {     if(globalFive==5)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_14_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_14_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_15_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_15_bad() {     switch(6)     {     case 6:     {         struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine((twoIntsStruct *)&data[0]);             free(data);         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;    ...
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         struct _twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine((twoIntsStruct...
0	good2	static void good2() {     switch(6)     {     case 6:     {         struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         struct _twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine((twoIntsStruct *)&data[0]);         }         free(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run ...
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_15_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_15_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_16_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_16_bad() {     while(1)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         }         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_16_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_16_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_17_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));             if (data == NULL) {exit(-1);}             struct _twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine((twoIntsStruct *)&data[0]);             tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine((twoIntsStruct *)&data[0]);             }             free(data);         } ...
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_17_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_17_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_18_bad	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_18_bad() {     goto sink; sink:     {         struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine((twoIntsStruct *)&data[0]);             free(data);         }     } }
0	good1	static void good1() {     goto sink; sink:     {         struct _twoIntsStruct * data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         struct _twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         tmpData = (struct _twoIntsStruct *)realloc(data, (130000)*sizeof(struct _twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine((twoIntsStruct *)&data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_18_good	void CWE401_Memory_Leak__malloc_realloc_struct_twoIntsStruct_18_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_01_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_01_bad() {     {         twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine(&data[0]);             free(data);         }     } }
0	good1	static void good1() {     {         twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine(&data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_01_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_01_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_02_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_02_bad() {     if(1)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }      ...
0	good2	static void good2() {     if(1)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_02_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_02_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_03_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_03_bad() {     if(5==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }   ...
0	good2	static void good2() {     if(5==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_03_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_03_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_04_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_04_bad() {     if(STATIC_CONST_TRUE)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);   ...
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_04_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_04_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_05_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_05_bad() {     if(staticTrue)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);          ...
0	good2	static void good2() {     if(staticTrue)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_05_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_05_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_06_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]); ...
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_06_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_06_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_07_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_07_bad() {     if(staticFive==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);        ...
0	good2	static void good2() {     if(staticFive==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_07_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_07_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_08_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_08_bad() {     if(staticReturnsTrue())     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]); ...
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_08_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_08_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_09_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);   ...
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_09_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_09_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_10_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_10_bad() {     if(globalTrue)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);          ...
0	good2	static void good2() {     if(globalTrue)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_10_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_10_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_11_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_11_bad() {     if(globalReturnsTrue())     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]); ...
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_11_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_11_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_12_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);} ...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)ma...
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_12_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_12_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_13_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]); ...
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_13_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_13_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_14_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_14_bad() {     if(globalFive==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);        ...
0	good2	static void good2() {     if(globalFive==5)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_14_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_14_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_15_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_15_bad() {     switch(6)     {     case 6:     {         twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine(&data[0]);             free(data);         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine(&data[0]);         }         free(data);     }     break;     } }
0	good2	static void good2() {     switch(6)     {     case 6:     {         twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine(&data[0]);         }         free(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_15_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_15_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_16_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_16_bad() {     while(1)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_16_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_16_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_17_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);                 free(data);             }         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));             if (data == NULL) {exit(-1);}             twoIntsStruct * tmpData;             /* Initialize and make use of data */             data[0].intOne = 0;             data[0].intTwo = 0;             printStructLine(&data[0]);             tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 data[0].intOne = 1;                 data[0].intTwo = 1;                 printStructLine(&data[0]);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_17_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_17_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_18_bad	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_18_bad() {     goto sink; sink:     {         twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));         if (data != NULL)         {             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine(&data[0]);             free(data);         }     } }
0	good1	static void good1() {     goto sink; sink:     {         twoIntsStruct * data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         twoIntsStruct * tmpData;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         tmpData = (twoIntsStruct *)realloc(data, (130000)*sizeof(twoIntsStruct));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             data[0].intOne = 1;             data[0].intTwo = 1;             printStructLine(&data[0]);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_18_good	void CWE401_Memory_Leak__malloc_realloc_twoIntsStruct_18_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_01_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_01_bad() {     {         wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));         if (data != NULL)         {             /* Reinitialize and make use of data */             wcscpy(data, L"New String");             printWLine(data);             free(data);         }     } }
0	good1	static void good1() {     {         wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         wchar_t * tmpData;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             wcscpy(data, L"New String");             printWLine(data);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_01_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_01_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_02_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_02_bad() {     if(1)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(1)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_02_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_02_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_03_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_03_bad() {     if(5==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(5==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_03_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_03_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_04_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_04_bad() {     if(STATIC_CONST_TRUE)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_04_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_04_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_05_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_05_bad() {     if(staticTrue)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticTrue)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_05_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_05_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_06_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_06_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_06_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_07_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_07_bad() {     if(staticFive==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticFive==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_07_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_07_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_08_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_08_bad() {     if(staticReturnsTrue())     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_08_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_08_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_09_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_09_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_09_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_10_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_10_bad() {     if(globalTrue)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalTrue)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_10_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_10_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_11_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_11_bad() {     if(globalReturnsTrue())     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_11_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_11_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_12_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");     ...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Ini...
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_12_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_12_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_13_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_13_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_13_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_14_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_14_bad() {     if(globalFive==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	good2	static void good2() {     if(globalFive==5)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_14_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_14_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_15_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_15_bad() {     switch(6)     {     case 6:     {         wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));         if (data != NULL)         {             /* Reinitialize and make use of data */             wcscpy(data, L"New String");             printWLine(data);             free(data);         }     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         wchar_t * tmpData;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             wcscpy(data, L"New String");             printWLine(data);         }         free(data);     }     break;     } }
0	good2	static void good2() {     switch(6)     {     case 6:     {         wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         wchar_t * tmpData;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             wcscpy(data, L"New String");             printWLine(data);         }         free(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_15_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_15_good() {     good1();     good2(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_16_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_16_bad() {     while(1)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }         break;     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_16_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_16_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_17_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             /* FLAW: If realloc() fails, the initial memory block will not be freed() */             data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             if (data != NULL)             {                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);                 free(data);             }         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));             if (data == NULL) {exit(-1);}             wchar_t * tmpData;             /* Initialize and make use of data */             wcscpy(data, L"A String");             printWLine(data);             tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));             /* FIX: Ensure realloc() was successful before assigning data to the memory block             * allocated with realloc() */             if (tmpData != NULL)             {                 data = tmpData;                 /* Reinitialize and make use of data */                 wcscpy(data, L"New String");                 printWLine(data);             }             free(data);         }     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_17_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_17_good() {     good1(); }
1	CWE401_Memory_Leak__malloc_realloc_wchar_t_18_bad	void CWE401_Memory_Leak__malloc_realloc_wchar_t_18_bad() {     goto sink; sink:     {         wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         /* FLAW: If realloc() fails, the initial memory block will not be freed() */         data = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));         if (data != NULL)         {             /* Reinitialize and make use of data */             wcscpy(data, L"New String");             printWLine(data);             free(data);         }     } }
0	good1	static void good1() {     goto sink; sink:     {         wchar_t * data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         wchar_t * tmpData;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         tmpData = (wchar_t *)realloc(data, (130000)*sizeof(wchar_t));         /* FIX: Ensure realloc() was successful before assigning data to the memory block         * allocated with realloc() */         if (tmpData != NULL)         {             data = tmpData;             /* Reinitialize and make use of data */             wcscpy(data, L"New String");             printWLine(data);         }         free(data);     } }
0	CWE401_Memory_Leak__malloc_realloc_wchar_t_18_good	void CWE401_Memory_Leak__malloc_realloc_wchar_t_18_good() {     good1(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(1)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete data;     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */  ...
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     TwoIntsClass * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     TwoIntsClass * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     TwoIntsClass * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goto sink; sink:     /* FIX: Deallocate memory */     delete data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(TwoIntsClass * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(TwoIntsClass * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2Sink	void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1Sink	void goodG2B1Sink(TwoIntsClass * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printIntLine(data->intOne);         printIntLine(data->intTwo);         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     {         TwoIntsClass * data = dataRef;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     TwoIntsClass * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete data;     } }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GSink(data); }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     funcPtr(data); }
1	badSink	static void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badSink(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GSink(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GSink(&data); }
1	badSink	void badSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     funcPtr(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(TwoIntsClass * dataArray[]) {     /* copy data out of dataArray */     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<TwoIntsClass *> dataVector) {     /* copy data out of dataVector */     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<TwoIntsClass *> dataList) {     /* copy data out of dataList */     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, TwoIntsClass *> dataMap) {     /* copy data out of dataMap */     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_TwoIntsClass_81_bad::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_TwoIntsClass_81_goodB2G::action(TwoIntsClass * data) const {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_TwoIntsClass_81_goodG2B::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     const CWE401_Memory_Leak__new_TwoIntsClass_81_base& o = CWE401_Memory_Leak__new_TwoIntsClass_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     const CWE401_Memory_Leak__new_TwoIntsClass_81_base& baseObject = CWE401_Memory_Leak__new_TwoIntsClass_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     const CWE401_Memory_Leak__new_TwoIntsClass_81_base& baseObject = CWE401_Memory_Leak__new_TwoIntsClass_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_TwoIntsClass_82_bad::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_TwoIntsClass_82_goodB2G::action(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_TwoIntsClass_82_goodG2B::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     CWE401_Memory_Leak__new_TwoIntsClass_82_base* baseObject = new CWE401_Memory_Leak__new_TwoIntsClass_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     CWE401_Memory_Leak__new_TwoIntsClass_82_base* baseObject = new CWE401_Memory_Leak__new_TwoIntsClass_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printIntLine(data->intOne);     printIntLine(data->intTwo);     CWE401_Memory_Leak__new_TwoIntsClass_82_base* baseObject = new CWE401_Memory_Leak__new_TwoIntsClass_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(1)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete[] data;     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for...
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete[] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     TwoIntsClass * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     TwoIntsClass * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     TwoIntsClass * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goto sink; sink:     /* FIX: Deallocate memory */     delete[] data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(TwoIntsClass * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(TwoIntsClass * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2Sink	void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1Sink	void goodG2B1Sink(TwoIntsClass * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         TwoIntsClass dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new TwoIntsClass[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printIntLine(data[0].intOne);         printIntLine(data[0].intTwo);         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     {         TwoIntsClass * data = dataRef;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     TwoIntsClass * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete[] data;     } }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GSink(data); }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     funcPtr(data); }
1	badSink	static void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badSink(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GSink(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GSink(&data); }
1	badSink	void badSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     funcPtr(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(TwoIntsClass * dataArray[]) {     /* copy data out of dataArray */     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<TwoIntsClass *> dataVector) {     /* copy data out of dataVector */     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<TwoIntsClass *> dataList) {     /* copy data out of dataList */     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, TwoIntsClass *> dataMap) {     /* copy data out of dataMap */     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_TwoIntsClass_81_bad::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_TwoIntsClass_81_goodB2G::action(TwoIntsClass * data) const {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_TwoIntsClass_81_goodG2B::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     const CWE401_Memory_Leak__new_array_TwoIntsClass_81_base& o = CWE401_Memory_Leak__new_array_TwoIntsClass_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     const CWE401_Memory_Leak__new_array_TwoIntsClass_81_base& baseObject = CWE401_Memory_Leak__new_array_TwoIntsClass_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     const CWE401_Memory_Leak__new_array_TwoIntsClass_81_base& baseObject = CWE401_Memory_Leak__new_array_TwoIntsClass_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_array_TwoIntsClass_82_bad::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_TwoIntsClass_82_goodB2G::action(TwoIntsClass * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_TwoIntsClass_82_goodG2B::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     CWE401_Memory_Leak__new_array_TwoIntsClass_82_base* baseObject = new CWE401_Memory_Leak__new_array_TwoIntsClass_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     TwoIntsClass dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     CWE401_Memory_Leak__new_array_TwoIntsClass_82_base* baseObject = new CWE401_Memory_Leak__new_array_TwoIntsClass_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new TwoIntsClass[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printIntLine(data[0].intOne);     printIntLine(data[0].intTwo);     CWE401_Memory_Leak__new_array_TwoIntsClass_82_base* baseObject = new CWE401_Memory_Leak__new_array_TwoIntsClass_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete[] data;     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete[] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     delete[] data; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(char * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(char * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2Sink	void goodB2G2Sink(char * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1Sink	void goodG2B1Sink(char * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char[100];         /* Initialize and make use of data */         strcpy(data, "A String");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     {         char * data = dataRef;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     char * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete[] data;     } }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink(data); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
1	badSink	static void badSink() {     char * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink(&data); }
1	badSink	void badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     funcPtr(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     char * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     char * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     char * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_char_81_bad::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_char_81_goodB2G::action(char * data) const {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_char_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__new_array_char_81_base& o = CWE401_Memory_Leak__new_array_char_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__new_array_char_81_base& baseObject = CWE401_Memory_Leak__new_array_char_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     const CWE401_Memory_Leak__new_array_char_81_base& baseObject = CWE401_Memory_Leak__new_array_char_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_array_char_82_bad::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_char_82_goodB2G::action(char * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_char_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__new_array_char_82_base* baseObject = new CWE401_Memory_Leak__new_array_char_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__new_array_char_82_base* baseObject = new CWE401_Memory_Leak__new_array_char_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char[100];     /* Initialize and make use of data */     strcpy(data, "A String");     printLine(data);     CWE401_Memory_Leak__new_array_char_82_base* baseObject = new CWE401_Memory_Leak__new_array_char_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete[] data;     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete[] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     delete[] data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int64_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(int64_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2Sink	void goodB2G2Sink(int64_t * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1Sink	void goodG2B1Sink(int64_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t[100];         /* Initialize and make use of data */         data[0] = 5LL;         printLongLongLine(data[0]);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     {         int64_t * data = dataRef;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     int64_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete[] data;     } }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink(data); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
1	badSink	static void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     funcPtr(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     int64_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_int64_t_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_int64_t_81_goodB2G::action(int64_t * data) const {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_int64_t_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__new_array_int64_t_81_base& o = CWE401_Memory_Leak__new_array_int64_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__new_array_int64_t_81_base& baseObject = CWE401_Memory_Leak__new_array_int64_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     const CWE401_Memory_Leak__new_array_int64_t_81_base& baseObject = CWE401_Memory_Leak__new_array_int64_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_array_int64_t_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_int64_t_82_goodB2G::action(int64_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_int64_t_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__new_array_int64_t_82_base* baseObject = new CWE401_Memory_Leak__new_array_int64_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__new_array_int64_t_82_base* baseObject = new CWE401_Memory_Leak__new_array_int64_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t[100];     /* Initialize and make use of data */     data[0] = 5LL;     printLongLongLine(data[0]);     CWE401_Memory_Leak__new_array_int64_t_82_base* baseObject = new CWE401_Memory_Leak__new_array_int64_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete[] data;     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete[] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     delete[] data; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(int * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2Sink	void goodB2G2Sink(int * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1Sink	void goodG2B1Sink(int * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * dataCopy = data;         int * data = dataCopy;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int[100];         /* Initialize and make use of data */         data[0] = 5;         printIntLine(data[0]);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     {         int * data = dataRef;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     int * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete[] data;     } }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink(data); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
1	badSink	static void badSink() {     int * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     funcPtr(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     int * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_int_81_bad::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_int_81_goodB2G::action(int * data) const {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_int_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__new_array_int_81_base& o = CWE401_Memory_Leak__new_array_int_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__new_array_int_81_base& baseObject = CWE401_Memory_Leak__new_array_int_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     const CWE401_Memory_Leak__new_array_int_81_base& baseObject = CWE401_Memory_Leak__new_array_int_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_array_int_82_bad::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_int_82_goodB2G::action(int * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_int_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__new_array_int_82_base* baseObject = new CWE401_Memory_Leak__new_array_int_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__new_array_int_82_base* baseObject = new CWE401_Memory_Leak__new_array_int_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int[100];     /* Initialize and make use of data */     data[0] = 5;     printIntLine(data[0]);     CWE401_Memory_Leak__new_array_int_82_base* baseObject = new CWE401_Memory_Leak__new_array_int_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete[] data;     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants *...
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete[] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     struct _twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     delete[] data; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(struct _twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(struct _twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(struct _twoIntsStruct * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(struct _twoIntsStruct * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2Sink	void goodB2G2Sink(struct _twoIntsStruct * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1Sink	void goodG2B1Sink(struct _twoIntsStruct * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete[] data;     } }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink(data); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
1	badSink	static void badSink() {     struct _twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     struct _twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     struct _twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink(data); }
1	badSink	void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(struct _twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(struct _twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(struct _twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(struct _twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(struct _twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(struct _twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(struct _twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(struct _twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(struct _twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(struct _twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(struct _twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(struct _twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(struct _twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(struct _twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(struct _twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(struct _twoIntsStruct * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(struct _twoIntsStruct * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(struct _twoIntsStruct * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
1	badSink	void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(struct _twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     struct _twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     struct _twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     struct _twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<struct _twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<struct _twoIntsStruct *> dataList) {     /* copy data out of dataList */     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, struct _twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_bad::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_goodB2G::action(struct _twoIntsStruct * data) const {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_goodG2B::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_base& o = CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_base& baseObject = CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_base& baseObject = CWE401_Memory_Leak__new_array_struct_twoIntsStruct_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_bad::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_goodB2G::action(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_goodG2B::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_array_struct_twoIntsStruct_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete[] data;     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete[] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     delete[] data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(twoIntsStruct * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2Sink	void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1Sink	void goodG2B1Sink(twoIntsStruct * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct[100];         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete[] data;     } }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink(data); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
1	badSink	static void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_twointsStruct_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_twointsStruct_81_goodB2G::action(twoIntsStruct * data) const {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_twointsStruct_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__new_array_twointsStruct_81_base& o = CWE401_Memory_Leak__new_array_twointsStruct_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__new_array_twointsStruct_81_base& baseObject = CWE401_Memory_Leak__new_array_twointsStruct_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__new_array_twointsStruct_81_base& baseObject = CWE401_Memory_Leak__new_array_twointsStruct_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_array_twointsStruct_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_twointsStruct_82_goodB2G::action(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_twointsStruct_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__new_array_twointsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_array_twointsStruct_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__new_array_twointsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_array_twointsStruct_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct[100];     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__new_array_twointsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_array_twointsStruct_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete[] data;     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete[] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete[] data;         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     delete[] data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(wchar_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodB2G2Sink	void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete[] data;     } }
0	goodG2B1Sink	void goodG2B1Sink(wchar_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer[100];         data = dataGoodBuffer;         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t[100];         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* FIX: Deallocate memory */         delete[] data;     } }
1	bad	void bad() {     wchar_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete[] data;     } }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink(data); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
1	badSink	static void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink(&data); }
1	badSink	void badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     wchar_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* FIX: Deallocate memory */     delete[] data; }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_wchar_t_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_wchar_t_81_goodB2G::action(wchar_t * data) const {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_wchar_t_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__new_array_wchar_t_81_base& o = CWE401_Memory_Leak__new_array_wchar_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__new_array_wchar_t_81_base& baseObject = CWE401_Memory_Leak__new_array_wchar_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__new_array_wchar_t_81_base& baseObject = CWE401_Memory_Leak__new_array_wchar_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_array_wchar_t_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_array_wchar_t_82_goodB2G::action(wchar_t * data) {     /* FIX: Deallocate memory */     delete[] data; }
0	action	void CWE401_Memory_Leak__new_array_wchar_t_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__new_array_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__new_array_wchar_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer[100];     data = dataGoodBuffer;     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__new_array_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__new_array_wchar_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t[100];     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__new_array_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__new_array_wchar_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(1)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete data;     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goto sink; sink:     /* FIX: Deallocate memory */     delete data; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(char * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(char * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2Sink	void goodB2G2Sink(char * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1Sink	void goodG2B1Sink(char * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     {         char * dataCopy = data;         char * data = dataCopy;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         char dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new char;         /* Initialize and make use of data */         *data = 'A';         printHexCharLine(*data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     {         char * data = dataRef;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     char * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete data;     } }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GSink(data); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     funcPtr(data); }
1	badSink	static void badSink() {     char * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GSink(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(char * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GSink(&data); }
1	badSink	void badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     funcPtr(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     char * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     char * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     char * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_char_81_bad::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_char_81_goodB2G::action(char * data) const {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_char_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     const CWE401_Memory_Leak__new_char_81_base& o = CWE401_Memory_Leak__new_char_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     const CWE401_Memory_Leak__new_char_81_base& baseObject = CWE401_Memory_Leak__new_char_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     const CWE401_Memory_Leak__new_char_81_base& baseObject = CWE401_Memory_Leak__new_char_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_char_82_bad::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_char_82_goodB2G::action(char * data) {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_char_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     CWE401_Memory_Leak__new_char_82_base* baseObject = new CWE401_Memory_Leak__new_char_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     char dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     CWE401_Memory_Leak__new_char_82_base* baseObject = new CWE401_Memory_Leak__new_char_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new char;     /* Initialize and make use of data */     *data = 'A';     printHexCharLine(*data);     CWE401_Memory_Leak__new_char_82_base* baseObject = new CWE401_Memory_Leak__new_char_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(1)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete data;     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goto sink; sink:     /* FIX: Deallocate memory */     delete data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int64_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(int64_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2Sink	void goodB2G2Sink(int64_t * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1Sink	void goodG2B1Sink(int64_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         int64_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     data = NULL;     {         int64_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int64_t;         /* Initialize and make use of data */         *data = 5LL;         printLongLongLine(*data);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     {         int64_t * data = dataRef;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     int64_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete data;     } }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GSink(data); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     funcPtr(data); }
1	badSink	static void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GSink(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GSink(&data); }
1	badSink	void badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     funcPtr(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     int64_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_int64_t_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_int64_t_81_goodB2G::action(int64_t * data) const {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_int64_t_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     const CWE401_Memory_Leak__new_int64_t_81_base& o = CWE401_Memory_Leak__new_int64_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     const CWE401_Memory_Leak__new_int64_t_81_base& baseObject = CWE401_Memory_Leak__new_int64_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     const CWE401_Memory_Leak__new_int64_t_81_base& baseObject = CWE401_Memory_Leak__new_int64_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_int64_t_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_int64_t_82_goodB2G::action(int64_t * data) {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_int64_t_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     CWE401_Memory_Leak__new_int64_t_82_base* baseObject = new CWE401_Memory_Leak__new_int64_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int64_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     CWE401_Memory_Leak__new_int64_t_82_base* baseObject = new CWE401_Memory_Leak__new_int64_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int64_t;     /* Initialize and make use of data */     *data = 5LL;     printLongLongLine(*data);     CWE401_Memory_Leak__new_int64_t_82_base* baseObject = new CWE401_Memory_Leak__new_int64_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(1)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete data;     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goto sink; sink:     /* FIX: Deallocate memory */     delete data; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(int * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2Sink	void goodB2G2Sink(int * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1Sink	void goodG2B1Sink(int * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     {         int * dataCopy = data;         int * data = dataCopy;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         int dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     data = NULL;     {         int * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new int;         /* Initialize and make use of data */         *data = 5;         printIntLine(*data);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     {         int * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     {         int * data = dataRef;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     int * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete data;     } }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GSink(data); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     funcPtr(data); }
1	badSink	static void badSink() {     int * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GSink(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(int * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GSink(&data); }
1	badSink	void badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     funcPtr(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     int * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_int_81_bad::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_int_81_goodB2G::action(int * data) const {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_int_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     const CWE401_Memory_Leak__new_int_81_base& o = CWE401_Memory_Leak__new_int_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     const CWE401_Memory_Leak__new_int_81_base& baseObject = CWE401_Memory_Leak__new_int_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     const CWE401_Memory_Leak__new_int_81_base& baseObject = CWE401_Memory_Leak__new_int_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_int_82_bad::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_int_82_goodB2G::action(int * data) {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_int_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     CWE401_Memory_Leak__new_int_82_base* baseObject = new CWE401_Memory_Leak__new_int_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     int dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     CWE401_Memory_Leak__new_int_82_base* baseObject = new CWE401_Memory_Leak__new_int_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new int;     /* Initialize and make use of data */     *data = 5;     printIntLine(*data);     CWE401_Memory_Leak__new_int_82_base* baseObject = new CWE401_Memory_Leak__new_int_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(1)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete data;     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     struct _twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goto sink; sink:     /* FIX: Deallocate memory */     delete data; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(struct _twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(struct _twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(struct _twoIntsStruct * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(struct _twoIntsStruct * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2Sink	void goodB2G2Sink(struct _twoIntsStruct * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1Sink	void goodG2B1Sink(struct _twoIntsStruct * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         struct _twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new struct _twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine((twoIntsStruct *)data);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     {         struct _twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     struct _twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete data;     } }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GSink(data); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     funcPtr(data); }
1	badSink	static void badSink() {     struct _twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     struct _twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     struct _twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GSink(data); }
1	badSink	void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(struct _twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(struct _twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(struct _twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(struct _twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(struct _twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(struct _twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(struct _twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(struct _twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(struct _twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(struct _twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(struct _twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(struct _twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(struct _twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(struct _twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(struct _twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(struct _twoIntsStruct * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(struct _twoIntsStruct * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(struct _twoIntsStruct * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GSink(&data); }
1	badSink	void badSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     funcPtr(data); }
1	badSink	void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(struct _twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     struct _twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     struct _twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     struct _twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<struct _twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<struct _twoIntsStruct *> dataList) {     /* copy data out of dataList */     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, struct _twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_struct_twoIntsStruct_81_bad::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_struct_twoIntsStruct_81_goodB2G::action(struct _twoIntsStruct * data) const {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_struct_twoIntsStruct_81_goodG2B::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     const CWE401_Memory_Leak__new_struct_twoIntsStruct_81_base& o = CWE401_Memory_Leak__new_struct_twoIntsStruct_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     const CWE401_Memory_Leak__new_struct_twoIntsStruct_81_base& baseObject = CWE401_Memory_Leak__new_struct_twoIntsStruct_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     const CWE401_Memory_Leak__new_struct_twoIntsStruct_81_base& baseObject = CWE401_Memory_Leak__new_struct_twoIntsStruct_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_struct_twoIntsStruct_82_bad::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_struct_twoIntsStruct_82_goodB2G::action(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_struct_twoIntsStruct_82_goodG2B::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     CWE401_Memory_Leak__new_struct_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_struct_twoIntsStruct_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     struct _twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     CWE401_Memory_Leak__new_struct_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_struct_twoIntsStruct_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new struct _twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine((twoIntsStruct *)data);     CWE401_Memory_Leak__new_struct_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_struct_twoIntsStruct_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete data;     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     delete data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(twoIntsStruct * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2Sink	void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1Sink	void goodG2B1Sink(twoIntsStruct * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         twoIntsStruct dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new twoIntsStruct;         /* Initialize and make use of data */         data->intOne = 0;         data->intTwo = 0;         printStructLine(data);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     {         twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete data;     } }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GSink(data); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     funcPtr(data); }
1	badSink	static void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GSink(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GSink(&data); }
1	badSink	void badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     funcPtr(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_twoIntsStruct_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_twoIntsStruct_81_goodB2G::action(twoIntsStruct * data) const {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_twoIntsStruct_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     const CWE401_Memory_Leak__new_twoIntsStruct_81_base& o = CWE401_Memory_Leak__new_twoIntsStruct_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     const CWE401_Memory_Leak__new_twoIntsStruct_81_base& baseObject = CWE401_Memory_Leak__new_twoIntsStruct_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     const CWE401_Memory_Leak__new_twoIntsStruct_81_base& baseObject = CWE401_Memory_Leak__new_twoIntsStruct_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_twoIntsStruct_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_twoIntsStruct_82_goodB2G::action(twoIntsStruct * data) {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_twoIntsStruct_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     CWE401_Memory_Leak__new_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_twoIntsStruct_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     twoIntsStruct dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     CWE401_Memory_Leak__new_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_twoIntsStruct_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new twoIntsStruct;     /* Initialize and make use of data */     data->intOne = 0;     data->intTwo = 0;     printStructLine(data);     CWE401_Memory_Leak__new_twoIntsStruct_82_base* baseObject = new CWE401_Memory_Leak__new_twoIntsStruct_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(1)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(5==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         delete data;     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         delete data;         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
1	bad	void bad() {     int i,j;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goto sink; sink:     /* FIX: Deallocate memory */     delete data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(wchar_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1Sink	void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodB2G2Sink	void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Global)     {         /* FIX: Deallocate memory */         delete data;     } }
0	goodG2B1Sink	void goodG2B1Sink(wchar_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack */         wchar_t dataGoodBuffer;         data = &dataGoodBuffer;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = new wchar_t;         /* Initialize and make use of data */         *data = L'A';         printHexCharLine((char)*data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     {         wchar_t * data = dataRef;         /* FIX: Deallocate memory */         delete data;     } }
1	bad	void bad() {     wchar_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         delete data;     } }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GSink(data); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     funcPtr(data); }
1	badSink	static void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GSink(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink_e	void goodG2BSink_e(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink_e	void goodB2GSink_e(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GSink(&data); }
1	badSink	void badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     funcPtr(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink() {     wchar_t * data = goodB2GData;     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* FIX: Deallocate memory */     delete data; }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_wchar_t_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_wchar_t_81_goodB2G::action(wchar_t * data) const {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_wchar_t_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     const CWE401_Memory_Leak__new_wchar_t_81_base& o = CWE401_Memory_Leak__new_wchar_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     const CWE401_Memory_Leak__new_wchar_t_81_base& baseObject = CWE401_Memory_Leak__new_wchar_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     const CWE401_Memory_Leak__new_wchar_t_81_base& baseObject = CWE401_Memory_Leak__new_wchar_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__new_wchar_t_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__new_wchar_t_82_goodB2G::action(wchar_t * data) {     /* FIX: Deallocate memory */     delete data; }
0	action	void CWE401_Memory_Leak__new_wchar_t_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     CWE401_Memory_Leak__new_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__new_wchar_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack */     wchar_t dataGoodBuffer;     data = &dataGoodBuffer;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     CWE401_Memory_Leak__new_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__new_wchar_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = new wchar_t;     /* Initialize and make use of data */     *data = L'A';     printHexCharLine((char)*data);     CWE401_Memory_Leak__new_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__new_wchar_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__strdup_char_01_bad	void CWE401_Memory_Leak__strdup_char_01_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_char_01_good	void CWE401_Memory_Leak__strdup_char_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_02_bad	void CWE401_Memory_Leak__strdup_char_02_bad() {     char * data;     data = NULL;     if(1)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(1)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(1)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(1)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_02_good	void CWE401_Memory_Leak__strdup_char_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_03_bad	void CWE401_Memory_Leak__strdup_char_03_bad() {     char * data;     data = NULL;     if(5==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(5==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(5==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(5==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_03_good	void CWE401_Memory_Leak__strdup_char_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_04_bad	void CWE401_Memory_Leak__strdup_char_04_bad() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_04_good	void CWE401_Memory_Leak__strdup_char_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_05_bad	void CWE401_Memory_Leak__strdup_char_05_bad() {     char * data;     data = NULL;     if(staticTrue)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticTrue)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticTrue)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticTrue)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_05_good	void CWE401_Memory_Leak__strdup_char_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_06_bad	void CWE401_Memory_Leak__strdup_char_06_bad() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_06_good	void CWE401_Memory_Leak__strdup_char_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_07_bad	void CWE401_Memory_Leak__strdup_char_07_bad() {     char * data;     data = NULL;     if(staticFive==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticFive==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticFive==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticFive==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_07_good	void CWE401_Memory_Leak__strdup_char_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_08_bad	void CWE401_Memory_Leak__strdup_char_08_bad() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_08_good	void CWE401_Memory_Leak__strdup_char_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_09_bad	void CWE401_Memory_Leak__strdup_char_09_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_09_good	void CWE401_Memory_Leak__strdup_char_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_10_bad	void CWE401_Memory_Leak__strdup_char_10_bad() {     char * data;     data = NULL;     if(globalTrue)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalTrue)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalTrue)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalTrue)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_10_good	void CWE401_Memory_Leak__strdup_char_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_11_bad	void CWE401_Memory_Leak__strdup_char_11_bad() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_11_good	void CWE401_Memory_Leak__strdup_char_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_12_bad	void CWE401_Memory_Leak__strdup_char_12_bad() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     else     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory initialized in the source */         free(data);     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_12_good	void CWE401_Memory_Leak__strdup_char_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_char_13_bad	void CWE401_Memory_Leak__strdup_char_13_bad() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_13_good	void CWE401_Memory_Leak__strdup_char_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_14_bad	void CWE401_Memory_Leak__strdup_char_14_bad() {     char * data;     data = NULL;     if(globalFive==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     if(globalFive==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     if(globalFive==5)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     if(globalFive==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_14_good	void CWE401_Memory_Leak__strdup_char_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_15_bad	void CWE401_Memory_Leak__strdup_char_15_bad() {     char * data;     data = NULL;     switch(6)     {     case 6:     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     switch(6)     {     case 6:     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory initialized in the source */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     switch(6)     {     case 6:     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory initialized in the source */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__strdup_char_15_good	void CWE401_Memory_Leak__strdup_char_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_char_16_bad	void CWE401_Memory_Leak__strdup_char_16_bad() {     char * data;     data = NULL;     while(1)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     while(1)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }         break;     }     while(1)     {         /* FIX: Deallocate memory initialized in the source */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__strdup_char_16_good	void CWE401_Memory_Leak__strdup_char_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_char_17_bad	void CWE401_Memory_Leak__strdup_char_17_bad() {     int i,j;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     data = NULL;     for(i = 0; i < 1; i++)     {         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_17_good	void CWE401_Memory_Leak__strdup_char_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_char_18_bad	void CWE401_Memory_Leak__strdup_char_18_bad() {     char * data;     data = NULL;     goto source; source:     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     goto sink; sink:     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goto source; source:     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     goto sink; sink:     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_18_good	void CWE401_Memory_Leak__strdup_char_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__strdup_char_21_bad	void CWE401_Memory_Leak__strdup_char_21_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_21_good	void CWE401_Memory_Leak__strdup_char_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_char_22_bad	void CWE401_Memory_Leak__strdup_char_22_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__strdup_char_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__strdup_char_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__strdup_char_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__strdup_char_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_22_good	void CWE401_Memory_Leak__strdup_char_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_char_22_badSink	void CWE401_Memory_Leak__strdup_char_22_badSink(char * data) {     if(CWE401_Memory_Leak__strdup_char_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_char_22_goodB2G1Sink	void CWE401_Memory_Leak__strdup_char_22_goodB2G1Sink(char * data) {     if(CWE401_Memory_Leak__strdup_char_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_char_22_goodB2G2Sink	void CWE401_Memory_Leak__strdup_char_22_goodB2G2Sink(char * data) {     if(CWE401_Memory_Leak__strdup_char_22_goodB2G2Global)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_char_22_goodG2BSink	void CWE401_Memory_Leak__strdup_char_22_goodG2BSink(char * data) {     if(CWE401_Memory_Leak__strdup_char_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__strdup_char_31_bad	void CWE401_Memory_Leak__strdup_char_31_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     {         char * dataCopy = data;         char * data = dataCopy;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_char_31_good	void CWE401_Memory_Leak__strdup_char_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_32_bad	void CWE401_Memory_Leak__strdup_char_32_bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (char *)ALLOCA(100*sizeof(char));         /* Initialize then use data */         strcpy(data, "a string");         printLine(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     data = NULL;     {         char * data = *dataPtr1;         {             char myString[] = "myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = strdup(myString);             /* Use data */             printLine(data);         }         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_char_32_good	void CWE401_Memory_Leak__strdup_char_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     char * data;     char * &dataRef = data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     {         char * data = dataRef;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
1	CWE401_Memory_Leak__strdup_char_34_bad	void CWE401_Memory_Leak__strdup_char_34_bad() {     char * data;     CWE401_Memory_Leak__strdup_char_34_unionType myUnion;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__strdup_char_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__strdup_char_34_unionType myUnion;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_char_34_good	void CWE401_Memory_Leak__strdup_char_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__strdup_char_41_bad	void CWE401_Memory_Leak__strdup_char_41_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_char_41_good	void CWE401_Memory_Leak__strdup_char_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static char * badSource(char * data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     return data; }
1	CWE401_Memory_Leak__strdup_char_42_bad	void CWE401_Memory_Leak__strdup_char_42_bad() {     char * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static char * goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     return data; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static char * goodB2GSource(char * data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     return data; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_char_42_good	void CWE401_Memory_Leak__strdup_char_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(char * &data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(char * &data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__strdup_char_44_bad	void CWE401_Memory_Leak__strdup_char_44_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     funcPtr(data); }
0	CWE401_Memory_Leak__strdup_char_44_good	void CWE401_Memory_Leak__strdup_char_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     char * data = CWE401_Memory_Leak__strdup_char_45_badData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__strdup_char_45_bad	void CWE401_Memory_Leak__strdup_char_45_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = CWE401_Memory_Leak__strdup_char_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = CWE401_Memory_Leak__strdup_char_45_goodB2GData;     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__strdup_char_45_good	void CWE401_Memory_Leak__strdup_char_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_51_bad	void CWE401_Memory_Leak__strdup_char_51_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_char_51_good	void CWE401_Memory_Leak__strdup_char_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_51b_badSink	void CWE401_Memory_Leak__strdup_char_51b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_51b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_51b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_51b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_51b_goodB2GSink(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_52_bad	void CWE401_Memory_Leak__strdup_char_52_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_char_52_good	void CWE401_Memory_Leak__strdup_char_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_52b_badSink	void CWE401_Memory_Leak__strdup_char_52b_badSink(char * data) {     CWE401_Memory_Leak__strdup_char_52c_badSink(data); }
0	CWE401_Memory_Leak__strdup_char_52b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_52b_goodG2BSink(char * data) {     CWE401_Memory_Leak__strdup_char_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_52b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_52b_goodB2GSink(char * data) {     CWE401_Memory_Leak__strdup_char_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_char_52c_badSink	void CWE401_Memory_Leak__strdup_char_52c_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_52c_goodG2BSink	void CWE401_Memory_Leak__strdup_char_52c_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_52c_goodB2GSink	void CWE401_Memory_Leak__strdup_char_52c_goodB2GSink(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_53_bad	void CWE401_Memory_Leak__strdup_char_53_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_char_53_good	void CWE401_Memory_Leak__strdup_char_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_53b_badSink	void CWE401_Memory_Leak__strdup_char_53b_badSink(char * data) {     CWE401_Memory_Leak__strdup_char_53c_badSink(data); }
0	CWE401_Memory_Leak__strdup_char_53b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_53b_goodG2BSink(char * data) {     CWE401_Memory_Leak__strdup_char_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_53b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_53b_goodB2GSink(char * data) {     CWE401_Memory_Leak__strdup_char_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_char_53c_badSink	void CWE401_Memory_Leak__strdup_char_53c_badSink(char * data) {     CWE401_Memory_Leak__strdup_char_53d_badSink(data); }
0	CWE401_Memory_Leak__strdup_char_53c_goodG2BSink	void CWE401_Memory_Leak__strdup_char_53c_goodG2BSink(char * data) {     CWE401_Memory_Leak__strdup_char_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_53c_goodB2GSink	void CWE401_Memory_Leak__strdup_char_53c_goodB2GSink(char * data) {     CWE401_Memory_Leak__strdup_char_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_char_53d_badSink	void CWE401_Memory_Leak__strdup_char_53d_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_53d_goodG2BSink	void CWE401_Memory_Leak__strdup_char_53d_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_53d_goodB2GSink	void CWE401_Memory_Leak__strdup_char_53d_goodB2GSink(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_54_bad	void CWE401_Memory_Leak__strdup_char_54_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_char_54_good	void CWE401_Memory_Leak__strdup_char_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_54b_badSink	void CWE401_Memory_Leak__strdup_char_54b_badSink(char * data) {     CWE401_Memory_Leak__strdup_char_54c_badSink(data); }
0	CWE401_Memory_Leak__strdup_char_54b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_54b_goodG2BSink(char * data) {     CWE401_Memory_Leak__strdup_char_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_54b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_54b_goodB2GSink(char * data) {     CWE401_Memory_Leak__strdup_char_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_char_54c_badSink	void CWE401_Memory_Leak__strdup_char_54c_badSink(char * data) {     CWE401_Memory_Leak__strdup_char_54d_badSink(data); }
0	CWE401_Memory_Leak__strdup_char_54c_goodG2BSink	void CWE401_Memory_Leak__strdup_char_54c_goodG2BSink(char * data) {     CWE401_Memory_Leak__strdup_char_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_54c_goodB2GSink	void CWE401_Memory_Leak__strdup_char_54c_goodB2GSink(char * data) {     CWE401_Memory_Leak__strdup_char_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_char_54d_badSink	void CWE401_Memory_Leak__strdup_char_54d_badSink(char * data) {     CWE401_Memory_Leak__strdup_char_54e_badSink(data); }
0	CWE401_Memory_Leak__strdup_char_54d_goodG2BSink	void CWE401_Memory_Leak__strdup_char_54d_goodG2BSink(char * data) {     CWE401_Memory_Leak__strdup_char_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_char_54d_goodB2GSink	void CWE401_Memory_Leak__strdup_char_54d_goodB2GSink(char * data) {     CWE401_Memory_Leak__strdup_char_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_char_54e_badSink	void CWE401_Memory_Leak__strdup_char_54e_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_54e_goodG2BSink	void CWE401_Memory_Leak__strdup_char_54e_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_54e_goodB2GSink	void CWE401_Memory_Leak__strdup_char_54e_goodB2GSink(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_61_bad	void CWE401_Memory_Leak__strdup_char_61_bad() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__strdup_char_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__strdup_char_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     data = CWE401_Memory_Leak__strdup_char_61b_goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_char_61_good	void CWE401_Memory_Leak__strdup_char_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_61b_badSource	char * CWE401_Memory_Leak__strdup_char_61b_badSource(char * data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     return data; }
0	CWE401_Memory_Leak__strdup_char_61b_goodG2BSource	char * CWE401_Memory_Leak__strdup_char_61b_goodG2BSource(char * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     return data; }
0	CWE401_Memory_Leak__strdup_char_61b_goodB2GSource	char * CWE401_Memory_Leak__strdup_char_61b_goodB2GSource(char * data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     return data; }
1	bad	void bad() {     char * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	badSource	void badSource(char * &data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
0	goodG2BSource	void goodG2BSource(char * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data); }
0	goodB2GSource	void goodB2GSource(char * &data) {     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
1	CWE401_Memory_Leak__strdup_char_63_bad	void CWE401_Memory_Leak__strdup_char_63_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__strdup_char_63_good	void CWE401_Memory_Leak__strdup_char_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_63b_badSink	void CWE401_Memory_Leak__strdup_char_63b_badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_63b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_63b_goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_63b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_63b_goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_64_bad	void CWE401_Memory_Leak__strdup_char_64_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__strdup_char_64_good	void CWE401_Memory_Leak__strdup_char_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_64b_badSink	void CWE401_Memory_Leak__strdup_char_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_64b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_64b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_65_bad	void CWE401_Memory_Leak__strdup_char_65_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = CWE401_Memory_Leak__strdup_char_65b_badSink;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__strdup_char_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = CWE401_Memory_Leak__strdup_char_65b_goodB2GSink;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     funcPtr(data); }
0	CWE401_Memory_Leak__strdup_char_65_good	void CWE401_Memory_Leak__strdup_char_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_65b_badSink	void CWE401_Memory_Leak__strdup_char_65b_badSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_65b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_65b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_65b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_65b_goodB2GSink(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_66_bad	void CWE401_Memory_Leak__strdup_char_66_bad() {     char * data;     char * dataArray[5];     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__strdup_char_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__strdup_char_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     dataArray[2] = data;     CWE401_Memory_Leak__strdup_char_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__strdup_char_66_good	void CWE401_Memory_Leak__strdup_char_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_66b_badSink	void CWE401_Memory_Leak__strdup_char_66b_badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_66b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_66b_goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_66b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_66b_goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_67_bad	void CWE401_Memory_Leak__strdup_char_67_bad() {     char * data;     CWE401_Memory_Leak__strdup_char_67_structType myStruct;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     myStruct.structFirst = data;     CWE401_Memory_Leak__strdup_char_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     CWE401_Memory_Leak__strdup_char_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__strdup_char_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     CWE401_Memory_Leak__strdup_char_67_structType myStruct;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     myStruct.structFirst = data;     CWE401_Memory_Leak__strdup_char_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__strdup_char_67_good	void CWE401_Memory_Leak__strdup_char_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_67b_badSink	void CWE401_Memory_Leak__strdup_char_67b_badSink(CWE401_Memory_Leak__strdup_char_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_67b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_67b_goodG2BSink(CWE401_Memory_Leak__strdup_char_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_67b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_67b_goodB2GSink(CWE401_Memory_Leak__strdup_char_67_structType myStruct) {     char * data = myStruct.structFirst;     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_char_68_bad	void CWE401_Memory_Leak__strdup_char_68_bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_68_badData = data;     CWE401_Memory_Leak__strdup_char_68b_badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_68_goodG2BData = data;     CWE401_Memory_Leak__strdup_char_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_68_goodB2GData = data;     CWE401_Memory_Leak__strdup_char_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__strdup_char_68_good	void CWE401_Memory_Leak__strdup_char_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_char_68b_badSink	void CWE401_Memory_Leak__strdup_char_68b_badSink() {     char * data = CWE401_Memory_Leak__strdup_char_68_badData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_68b_goodG2BSink	void CWE401_Memory_Leak__strdup_char_68b_goodG2BSink() {     char * data = CWE401_Memory_Leak__strdup_char_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_68b_goodB2GSink	void CWE401_Memory_Leak__strdup_char_68b_goodB2GSink() {     char * data = CWE401_Memory_Leak__strdup_char_68_goodB2GData;     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	bad	void bad() {     char * data;     list<char *> dataList;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	action	void CWE401_Memory_Leak__strdup_char_81_bad::action(char * data) const {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__strdup_char_81_goodB2G::action(char * data) const {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	action	void CWE401_Memory_Leak__strdup_char_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     const CWE401_Memory_Leak__strdup_char_81_base& baseObject = CWE401_Memory_Leak__strdup_char_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     const CWE401_Memory_Leak__strdup_char_81_base& baseObject = CWE401_Memory_Leak__strdup_char_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     const CWE401_Memory_Leak__strdup_char_81_base& baseObject = CWE401_Memory_Leak__strdup_char_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__strdup_char_82_bad::action(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__strdup_char_82_goodB2G::action(char * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	action	void CWE401_Memory_Leak__strdup_char_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_82_base* baseObject = new CWE401_Memory_Leak__strdup_char_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data);     CWE401_Memory_Leak__strdup_char_82_base* baseObject = new CWE401_Memory_Leak__strdup_char_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     }     CWE401_Memory_Leak__strdup_char_82_base* baseObject = new CWE401_Memory_Leak__strdup_char_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__strdup_char_83_bad	CWE401_Memory_Leak__strdup_char_83_bad::CWE401_Memory_Leak__strdup_char_83_bad(char * dataCopy) {     data = dataCopy;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
1	~CWE401_Memory_Leak__strdup_char_83_bad	CWE401_Memory_Leak__strdup_char_83_bad::~CWE401_Memory_Leak__strdup_char_83_bad() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_83_goodB2G	CWE401_Memory_Leak__strdup_char_83_goodB2G::CWE401_Memory_Leak__strdup_char_83_goodB2G(char * dataCopy) {     data = dataCopy;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
0	~CWE401_Memory_Leak__strdup_char_83_goodB2G	CWE401_Memory_Leak__strdup_char_83_goodB2G::~CWE401_Memory_Leak__strdup_char_83_goodB2G() {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_char_83_goodG2B	CWE401_Memory_Leak__strdup_char_83_goodG2B::CWE401_Memory_Leak__strdup_char_83_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data); }
0	~CWE401_Memory_Leak__strdup_char_83_goodG2B	CWE401_Memory_Leak__strdup_char_83_goodG2B::~CWE401_Memory_Leak__strdup_char_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__strdup_char_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__strdup_char_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__strdup_char_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__strdup_char_84_bad	CWE401_Memory_Leak__strdup_char_84_bad::CWE401_Memory_Leak__strdup_char_84_bad(char * dataCopy) {     data = dataCopy;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
1	~CWE401_Memory_Leak__strdup_char_84_bad	CWE401_Memory_Leak__strdup_char_84_bad::~CWE401_Memory_Leak__strdup_char_84_bad() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_char_84_goodB2G	CWE401_Memory_Leak__strdup_char_84_goodB2G::CWE401_Memory_Leak__strdup_char_84_goodB2G(char * dataCopy) {     data = dataCopy;     {         char myString[] = "myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = strdup(myString);         /* Use data */         printLine(data);     } }
0	~CWE401_Memory_Leak__strdup_char_84_goodB2G	CWE401_Memory_Leak__strdup_char_84_goodB2G::~CWE401_Memory_Leak__strdup_char_84_goodB2G() {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_char_84_goodG2B	CWE401_Memory_Leak__strdup_char_84_goodG2B::CWE401_Memory_Leak__strdup_char_84_goodG2B(char * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (char *)ALLOCA(100*sizeof(char));     /* Initialize then use data */     strcpy(data, "a string");     printLine(data); }
0	~CWE401_Memory_Leak__strdup_char_84_goodG2B	CWE401_Memory_Leak__strdup_char_84_goodG2B::~CWE401_Memory_Leak__strdup_char_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     data = NULL;     CWE401_Memory_Leak__strdup_char_84_bad * badObject = new CWE401_Memory_Leak__strdup_char_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * data;     data = NULL;     CWE401_Memory_Leak__strdup_char_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__strdup_char_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     char * data;     data = NULL;     CWE401_Memory_Leak__strdup_char_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__strdup_char_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__strdup_wchar_t_01_bad	void CWE401_Memory_Leak__strdup_wchar_t_01_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_01_good	void CWE401_Memory_Leak__strdup_wchar_t_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_02_bad	void CWE401_Memory_Leak__strdup_wchar_t_02_bad() {     wchar_t * data;     data = NULL;     if(1)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(1)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(1)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(1)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_02_good	void CWE401_Memory_Leak__strdup_wchar_t_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_03_bad	void CWE401_Memory_Leak__strdup_wchar_t_03_bad() {     wchar_t * data;     data = NULL;     if(5==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(5==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(5==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(5==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_03_good	void CWE401_Memory_Leak__strdup_wchar_t_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_04_bad	void CWE401_Memory_Leak__strdup_wchar_t_04_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_04_good	void CWE401_Memory_Leak__strdup_wchar_t_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_05_bad	void CWE401_Memory_Leak__strdup_wchar_t_05_bad() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticTrue)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_05_good	void CWE401_Memory_Leak__strdup_wchar_t_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_06_bad	void CWE401_Memory_Leak__strdup_wchar_t_06_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_06_good	void CWE401_Memory_Leak__strdup_wchar_t_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_07_bad	void CWE401_Memory_Leak__strdup_wchar_t_07_bad() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticFive==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_07_good	void CWE401_Memory_Leak__strdup_wchar_t_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_08_bad	void CWE401_Memory_Leak__strdup_wchar_t_08_bad() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_08_good	void CWE401_Memory_Leak__strdup_wchar_t_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_09_bad	void CWE401_Memory_Leak__strdup_wchar_t_09_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_09_good	void CWE401_Memory_Leak__strdup_wchar_t_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_10_bad	void CWE401_Memory_Leak__strdup_wchar_t_10_bad() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalTrue)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_10_good	void CWE401_Memory_Leak__strdup_wchar_t_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_11_bad	void CWE401_Memory_Leak__strdup_wchar_t_11_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_11_good	void CWE401_Memory_Leak__strdup_wchar_t_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_12_bad	void CWE401_Memory_Leak__strdup_wchar_t_12_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     else     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory initialized in the source */         free(data);     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_12_good	void CWE401_Memory_Leak__strdup_wchar_t_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_wchar_t_13_bad	void CWE401_Memory_Leak__strdup_wchar_t_13_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_13_good	void CWE401_Memory_Leak__strdup_wchar_t_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_14_bad	void CWE401_Memory_Leak__strdup_wchar_t_14_bad() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     if(globalFive==5)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_14_good	void CWE401_Memory_Leak__strdup_wchar_t_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_15_bad	void CWE401_Memory_Leak__strdup_wchar_t_15_bad() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory initialized in the source */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory initialized in the source */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__strdup_wchar_t_15_good	void CWE401_Memory_Leak__strdup_wchar_t_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__strdup_wchar_t_16_bad	void CWE401_Memory_Leak__strdup_wchar_t_16_bad() {     wchar_t * data;     data = NULL;     while(1)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     while(1)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }         break;     }     while(1)     {         /* FIX: Deallocate memory initialized in the source */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__strdup_wchar_t_16_good	void CWE401_Memory_Leak__strdup_wchar_t_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_wchar_t_17_bad	void CWE401_Memory_Leak__strdup_wchar_t_17_bad() {     int i,j;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_17_good	void CWE401_Memory_Leak__strdup_wchar_t_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_wchar_t_18_bad	void CWE401_Memory_Leak__strdup_wchar_t_18_bad() {     wchar_t * data;     data = NULL;     goto source; source:     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     goto sink; sink:     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goto source; source:     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     goto sink; sink:     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_18_good	void CWE401_Memory_Leak__strdup_wchar_t_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__strdup_wchar_t_21_bad	void CWE401_Memory_Leak__strdup_wchar_t_21_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_21_good	void CWE401_Memory_Leak__strdup_wchar_t_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_wchar_t_22_bad	void CWE401_Memory_Leak__strdup_wchar_t_22_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__strdup_wchar_t_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__strdup_wchar_t_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_22_good	void CWE401_Memory_Leak__strdup_wchar_t_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__strdup_wchar_t_22_badSink	void CWE401_Memory_Leak__strdup_wchar_t_22_badSink(wchar_t * data) {     if(CWE401_Memory_Leak__strdup_wchar_t_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G1Sink	void CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G1Sink(wchar_t * data) {     if(CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G2Sink	void CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G2Sink(wchar_t * data) {     if(CWE401_Memory_Leak__strdup_wchar_t_22_goodB2G2Global)     {         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_wchar_t_22_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_22_goodG2BSink(wchar_t * data) {     if(CWE401_Memory_Leak__strdup_wchar_t_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__strdup_wchar_t_31_bad	void CWE401_Memory_Leak__strdup_wchar_t_31_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_wchar_t_31_good	void CWE401_Memory_Leak__strdup_wchar_t_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_32_bad	void CWE401_Memory_Leak__strdup_wchar_t_32_bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize then use data */         wcscpy(data, L"a string");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         {             wchar_t myString[] = L"myString";             /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */             data = wcsdup(myString);             /* Use data */             printWLine(data);         }         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_wchar_t_32_good	void CWE401_Memory_Leak__strdup_wchar_t_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     {         wchar_t * data = dataRef;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
1	CWE401_Memory_Leak__strdup_wchar_t_34_bad	void CWE401_Memory_Leak__strdup_wchar_t_34_bad() {     wchar_t * data;     CWE401_Memory_Leak__strdup_wchar_t_34_unionType myUnion;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__strdup_wchar_t_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation of memory */         /* no deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__strdup_wchar_t_34_unionType myUnion;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory initialized in the source */         free(data);     } }
0	CWE401_Memory_Leak__strdup_wchar_t_34_good	void CWE401_Memory_Leak__strdup_wchar_t_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__strdup_wchar_t_41_bad	void CWE401_Memory_Leak__strdup_wchar_t_41_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_41_good	void CWE401_Memory_Leak__strdup_wchar_t_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static wchar_t * badSource(wchar_t * data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     return data; }
1	CWE401_Memory_Leak__strdup_wchar_t_42_bad	void CWE401_Memory_Leak__strdup_wchar_t_42_bad() {     wchar_t * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     return data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static wchar_t * goodB2GSource(wchar_t * data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     return data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_42_good	void CWE401_Memory_Leak__strdup_wchar_t_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(wchar_t * &data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(wchar_t * &data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__strdup_wchar_t_44_bad	void CWE401_Memory_Leak__strdup_wchar_t_44_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     funcPtr(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_44_good	void CWE401_Memory_Leak__strdup_wchar_t_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     wchar_t * data = CWE401_Memory_Leak__strdup_wchar_t_45_badData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__strdup_wchar_t_45_bad	void CWE401_Memory_Leak__strdup_wchar_t_45_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__strdup_wchar_t_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__strdup_wchar_t_45_goodB2GData;     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__strdup_wchar_t_45_good	void CWE401_Memory_Leak__strdup_wchar_t_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_51_bad	void CWE401_Memory_Leak__strdup_wchar_t_51_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_51_good	void CWE401_Memory_Leak__strdup_wchar_t_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_51b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_51b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_51b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_51b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_51b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_51b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_52_bad	void CWE401_Memory_Leak__strdup_wchar_t_52_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_52_good	void CWE401_Memory_Leak__strdup_wchar_t_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_52b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_52b_badSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_52c_badSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_52b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_52b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_52b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_52b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_52c_badSink	void CWE401_Memory_Leak__strdup_wchar_t_52c_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_52c_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_52c_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_52c_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_52c_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_53_bad	void CWE401_Memory_Leak__strdup_wchar_t_53_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_53_good	void CWE401_Memory_Leak__strdup_wchar_t_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_53b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_53b_badSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_53c_badSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_53b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_53b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_53b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_53b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_53c_badSink	void CWE401_Memory_Leak__strdup_wchar_t_53c_badSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_53d_badSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_53c_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_53c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_53c_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_53c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_53d_badSink	void CWE401_Memory_Leak__strdup_wchar_t_53d_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_53d_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_53d_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_53d_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_53d_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_54_bad	void CWE401_Memory_Leak__strdup_wchar_t_54_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_54_good	void CWE401_Memory_Leak__strdup_wchar_t_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_54b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_54b_badSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54c_badSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_54b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_54b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_54b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_54b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_54c_badSink	void CWE401_Memory_Leak__strdup_wchar_t_54c_badSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54d_badSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_54c_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_54c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_54c_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_54c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_54d_badSink	void CWE401_Memory_Leak__strdup_wchar_t_54d_badSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54e_badSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_54d_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_54d_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_54d_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_54d_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__strdup_wchar_t_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_54e_badSink	void CWE401_Memory_Leak__strdup_wchar_t_54e_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_54e_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_54e_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_54e_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_54e_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_61_bad	void CWE401_Memory_Leak__strdup_wchar_t_61_bad() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__strdup_wchar_t_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__strdup_wchar_t_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__strdup_wchar_t_61b_goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_61_good	void CWE401_Memory_Leak__strdup_wchar_t_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_61b_badSource	wchar_t * CWE401_Memory_Leak__strdup_wchar_t_61b_badSource(wchar_t * data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     return data; }
0	CWE401_Memory_Leak__strdup_wchar_t_61b_goodG2BSource	wchar_t * CWE401_Memory_Leak__strdup_wchar_t_61b_goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     return data; }
0	CWE401_Memory_Leak__strdup_wchar_t_61b_goodB2GSource	wchar_t * CWE401_Memory_Leak__strdup_wchar_t_61b_goodB2GSource(wchar_t * data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     return data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	badSource	void badSource(wchar_t * &data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
0	goodG2BSource	void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data); }
0	goodB2GSource	void goodB2GSource(wchar_t * &data) {     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
1	CWE401_Memory_Leak__strdup_wchar_t_63_bad	void CWE401_Memory_Leak__strdup_wchar_t_63_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__strdup_wchar_t_63_good	void CWE401_Memory_Leak__strdup_wchar_t_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_63b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_63b_badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_63b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_63b_goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_63b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_63b_goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_64_bad	void CWE401_Memory_Leak__strdup_wchar_t_64_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__strdup_wchar_t_64_good	void CWE401_Memory_Leak__strdup_wchar_t_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_64b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_64b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_64b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_65_bad	void CWE401_Memory_Leak__strdup_wchar_t_65_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__strdup_wchar_t_65b_badSink;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__strdup_wchar_t_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__strdup_wchar_t_65b_goodB2GSink;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     funcPtr(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_65_good	void CWE401_Memory_Leak__strdup_wchar_t_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_65b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_65b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_65b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_65b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_65b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_65b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_66_bad	void CWE401_Memory_Leak__strdup_wchar_t_66_bad() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__strdup_wchar_t_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__strdup_wchar_t_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     dataArray[2] = data;     CWE401_Memory_Leak__strdup_wchar_t_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__strdup_wchar_t_66_good	void CWE401_Memory_Leak__strdup_wchar_t_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_66b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_66b_badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_66b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_66b_goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_66b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_66b_goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_67_bad	void CWE401_Memory_Leak__strdup_wchar_t_67_bad() {     wchar_t * data;     CWE401_Memory_Leak__strdup_wchar_t_67_structType myStruct;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     myStruct.structFirst = data;     CWE401_Memory_Leak__strdup_wchar_t_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__strdup_wchar_t_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__strdup_wchar_t_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__strdup_wchar_t_67_structType myStruct;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     myStruct.structFirst = data;     CWE401_Memory_Leak__strdup_wchar_t_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__strdup_wchar_t_67_good	void CWE401_Memory_Leak__strdup_wchar_t_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_67b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_67b_badSink(CWE401_Memory_Leak__strdup_wchar_t_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_67b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_67b_goodG2BSink(CWE401_Memory_Leak__strdup_wchar_t_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_67b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_67b_goodB2GSink(CWE401_Memory_Leak__strdup_wchar_t_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_68_bad	void CWE401_Memory_Leak__strdup_wchar_t_68_bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_68_badData = data;     CWE401_Memory_Leak__strdup_wchar_t_68b_badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_68_goodG2BData = data;     CWE401_Memory_Leak__strdup_wchar_t_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_68_goodB2GData = data;     CWE401_Memory_Leak__strdup_wchar_t_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__strdup_wchar_t_68_good	void CWE401_Memory_Leak__strdup_wchar_t_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__strdup_wchar_t_68b_badSink	void CWE401_Memory_Leak__strdup_wchar_t_68b_badSink() {     wchar_t * data = CWE401_Memory_Leak__strdup_wchar_t_68_badData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_68b_goodG2BSink	void CWE401_Memory_Leak__strdup_wchar_t_68b_goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__strdup_wchar_t_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_68b_goodB2GSink	void CWE401_Memory_Leak__strdup_wchar_t_68b_goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__strdup_wchar_t_68_goodB2GData;     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* FIX: Deallocate memory initialized in the source */     free(data); }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	action	void CWE401_Memory_Leak__strdup_wchar_t_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__strdup_wchar_t_81_goodB2G::action(wchar_t * data) const {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	action	void CWE401_Memory_Leak__strdup_wchar_t_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     const CWE401_Memory_Leak__strdup_wchar_t_81_base& baseObject = CWE401_Memory_Leak__strdup_wchar_t_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     const CWE401_Memory_Leak__strdup_wchar_t_81_base& baseObject = CWE401_Memory_Leak__strdup_wchar_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     const CWE401_Memory_Leak__strdup_wchar_t_81_base& baseObject = CWE401_Memory_Leak__strdup_wchar_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__strdup_wchar_t_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__strdup_wchar_t_82_goodB2G::action(wchar_t * data) {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	action	void CWE401_Memory_Leak__strdup_wchar_t_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__strdup_wchar_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data);     CWE401_Memory_Leak__strdup_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__strdup_wchar_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     }     CWE401_Memory_Leak__strdup_wchar_t_82_base* baseObject = new CWE401_Memory_Leak__strdup_wchar_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__strdup_wchar_t_83_bad	CWE401_Memory_Leak__strdup_wchar_t_83_bad::CWE401_Memory_Leak__strdup_wchar_t_83_bad(wchar_t * dataCopy) {     data = dataCopy;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
1	~CWE401_Memory_Leak__strdup_wchar_t_83_bad	CWE401_Memory_Leak__strdup_wchar_t_83_bad::~CWE401_Memory_Leak__strdup_wchar_t_83_bad() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_83_goodB2G	CWE401_Memory_Leak__strdup_wchar_t_83_goodB2G::CWE401_Memory_Leak__strdup_wchar_t_83_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
0	~CWE401_Memory_Leak__strdup_wchar_t_83_goodB2G	CWE401_Memory_Leak__strdup_wchar_t_83_goodB2G::~CWE401_Memory_Leak__strdup_wchar_t_83_goodB2G() {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_83_goodG2B	CWE401_Memory_Leak__strdup_wchar_t_83_goodG2B::CWE401_Memory_Leak__strdup_wchar_t_83_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data); }
0	~CWE401_Memory_Leak__strdup_wchar_t_83_goodG2B	CWE401_Memory_Leak__strdup_wchar_t_83_goodG2B::~CWE401_Memory_Leak__strdup_wchar_t_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__strdup_wchar_t_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__strdup_wchar_t_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__strdup_wchar_t_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__strdup_wchar_t_84_bad	CWE401_Memory_Leak__strdup_wchar_t_84_bad::CWE401_Memory_Leak__strdup_wchar_t_84_bad(wchar_t * dataCopy) {     data = dataCopy;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
1	~CWE401_Memory_Leak__strdup_wchar_t_84_bad	CWE401_Memory_Leak__strdup_wchar_t_84_bad::~CWE401_Memory_Leak__strdup_wchar_t_84_bad() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G	CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G::CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     {         wchar_t myString[] = L"myString";         /* POTENTIAL FLAW: Allocate memory from the heap using a function that requires free() for deallocation */         data = wcsdup(myString);         /* Use data */         printWLine(data);     } }
0	~CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G	CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G::~CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G() {     /* FIX: Deallocate memory initialized in the source */     free(data); }
0	CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B	CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B::CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize then use data */     wcscpy(data, L"a string");     printWLine(data); }
0	~CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B	CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B::~CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation of memory */     /* no deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__strdup_wchar_t_84_bad * badObject = new CWE401_Memory_Leak__strdup_wchar_t_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__strdup_wchar_t_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__strdup_wchar_t_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_01_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_01_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_01_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_02_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_02_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_02_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_03_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_03_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_03_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_04_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_04_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_04_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_05_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_05_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_05_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_06_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_06_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_06_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_07_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_07_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_07_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_08_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_08_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_08_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_09_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_09_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_09_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_10_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_10_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_10_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_11_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_11_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_11_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_12_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_12_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         ...
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement neede...
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_12_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_13_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_13_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_13_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_14_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_14_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_14_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_15_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_15_bad() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_15_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_16_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_16_bad() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_16_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_17_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_17_bad() {     int i,j;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     struct _twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_17_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_18_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_18_bad() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_18_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_21_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_21_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(struct _twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(struct _twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_21_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_badSink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G1Sink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G1Sink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G2Sink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G2Sink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodG2BSink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_calloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_31_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_31_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_31_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_32_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_32_bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_32_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_34_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_34_bad() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_34_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_41_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_41_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_41_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static struct _twoIntsStruct * badSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_42_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_42_bad() {     struct _twoIntsStruct * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static struct _twoIntsStruct * goodG2BSource(struct _twoIntsStruct * data) {      /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static struct _twoIntsStruct * goodB2GSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_42_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(struct _twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_44_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_44_bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_44_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_51b_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_52c_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53c_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_53d_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54c_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54d_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_54e_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61_bad() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_badSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_badSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_goodG2BSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_goodG2BSource(struct _twoIntsStruct * data) {      /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_goodB2GSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_calloc_61b_goodB2GSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodG2BSource	void goodG2BSource(struct _twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodB2GSource	void goodB2GSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_badSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_goodG2BSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_63b_goodB2GSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65_bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_65b_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66_bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_badSink(struct _twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_goodG2BSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_66b_goodB2GSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_bad() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_badSink(CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_goodG2BSink(CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67b_goodB2GSink(CWE401_Memory_Leak__struct_twoIntsStruct_calloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_badData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_goodG2BData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_goodB2GData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_good	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_badSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_goodG2BSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68b_goodB2GSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<struct _twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<struct _twoIntsStruct *> dataList) {     /* copy data out of dataList */     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, struct _twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_bad::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_goodB2G::action(struct _twoIntsStruct * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_goodG2B::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_calloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_bad::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_goodB2G::action(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_goodG2B::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_calloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodB2G::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodB2G(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodB2G::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodG2B::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodG2B(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodG2B::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)calloc(100, sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B::CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B::~CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad * badObject = new CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__struct_twoIntsStruct_calloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_01_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_01_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_01_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_02_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_02_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_02_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_03_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_03_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_03_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_04_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_04_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_04_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_05_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_05_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_05_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_06_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_06_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_06_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_07_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_07_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_07_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_08_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_08_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_08_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_09_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_09_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_09_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_10_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_10_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_10_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_11_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_11_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_11_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_12_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_12_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /...
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement neede...
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_12_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_13_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_13_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_13_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_14_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_14_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_14_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_15_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_15_bad() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_15_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_16_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_16_bad() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_16_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_17_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_17_bad() {     int i,j;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     struct _twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_17_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_18_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_18_bad() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_18_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_21_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_21_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(struct _twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(struct _twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_21_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_badSink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G1Sink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G1Sink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G2Sink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G2Sink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodG2BSink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_malloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_31_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_31_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_31_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_32_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_32_bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_32_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_34_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_34_bad() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_34_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_41_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_41_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_41_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static struct _twoIntsStruct * badSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_42_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_42_bad() {     struct _twoIntsStruct * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static struct _twoIntsStruct * goodG2BSource(struct _twoIntsStruct * data) {      /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static struct _twoIntsStruct * goodB2GSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_42_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(struct _twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_44_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_44_bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_44_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_51b_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_52c_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53c_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_53d_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54c_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54d_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_54e_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61_bad() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_badSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_badSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_goodG2BSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_goodG2BSource(struct _twoIntsStruct * data) {      /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_goodB2GSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_malloc_61b_goodB2GSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodG2BSource	void goodG2BSource(struct _twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodB2GSource	void goodB2GSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_badSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_goodG2BSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_63b_goodB2GSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65_bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_65b_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66_bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_badSink(struct _twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_goodG2BSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_66b_goodB2GSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_bad() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_badSink(CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_goodG2BSink(CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67b_goodB2GSink(CWE401_Memory_Leak__struct_twoIntsStruct_malloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_badData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_goodG2BData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_goodB2GData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_good	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_badSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_goodG2BSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68b_goodB2GSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<struct _twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<struct _twoIntsStruct *> dataList) {     /* copy data out of dataList */     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, struct _twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_bad::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_goodB2G::action(struct _twoIntsStruct * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_goodG2B::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_malloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_bad::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_goodB2G::action(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_goodG2B::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_malloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_bad	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_bad::CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_bad(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_bad	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodB2G::CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodB2G(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodB2G::~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodG2B::CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodG2B(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodG2B::~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad::CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G::CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)malloc(100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G::~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B::CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B::~CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad * badObject = new CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__struct_twoIntsStruct_malloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_01_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_01_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_01_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_02_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_02_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_02_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_03_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_03_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_03_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_04_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_04_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_04_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_05_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_05_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_05_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_06_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_06_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_06_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_07_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_07_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_07_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_08_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_08_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_08_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_09_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_09_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_09_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_10_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_10_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_10_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_11_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_11_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_11_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_12_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_12_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {  ...
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data)...
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement neede...
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_12_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_13_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_13_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_13_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_14_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_14_bad() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_14_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_15_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_15_bad() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     struct _twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     struct _twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_15_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_16_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_16_bad() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_16_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_17_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_17_bad() {     int i,j;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     struct _twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     struct _twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_17_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_18_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_18_bad() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_18_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_21_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_21_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(struct _twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(struct _twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_21_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_badSink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G1Sink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G1Sink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G2Sink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G2Sink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodG2BSink(struct _twoIntsStruct * data) {     if(CWE401_Memory_Leak__struct_twoIntsStruct_realloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_31_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_31_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * dataCopy = data;         struct _twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_31_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_32_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_32_bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * *dataPtr1 = &data;     struct _twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         struct _twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine((twoIntsStruct *)&data[0]);         *dataPtr1 = data;     }     {         struct _twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_32_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     {         struct _twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_34_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_34_bad() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myUnion.unionFirst = data;     {         struct _twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_34_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_41_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_41_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_41_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static struct _twoIntsStruct * badSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_42_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_42_bad() {     struct _twoIntsStruct * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static struct _twoIntsStruct * goodG2BSource(struct _twoIntsStruct * data) {      /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static struct _twoIntsStruct * goodB2GSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_42_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(struct _twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_44_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_44_bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_44_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_51b_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_52c_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53c_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_53d_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54b_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54c_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_badSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_badSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_goodG2BSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54d_goodB2GSink(struct _twoIntsStruct * data) {     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_54e_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61_bad() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_badSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_badSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_goodG2BSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_goodG2BSource(struct _twoIntsStruct * data) {      /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_goodB2GSource	struct _twoIntsStruct * CWE401_Memory_Leak__struct_twoIntsStruct_realloc_61b_goodB2GSource(struct _twoIntsStruct * data) {      /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}      /* Initialize and make use of data */      data[0].intOne = 0;     data[0].intTwo = 0;      printStructLine((twoIntsStruct *)&data[0]);      return data; }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodG2BSource	void goodG2BSource(struct _twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	goodB2GSource	void goodB2GSource(struct _twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_badSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_goodG2BSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_63b_goodB2GSink(struct _twoIntsStruct * * dataPtr) {     struct _twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     struct _twoIntsStruct * * dataPtr = (struct _twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     struct _twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65_bad() {     struct _twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     void (*funcPtr) (struct _twoIntsStruct *) = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_badSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_goodG2BSink(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_65b_goodB2GSink(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66_bad() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     struct _twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_badSink(struct _twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_goodG2BSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_66b_goodB2GSink(struct _twoIntsStruct * dataArray[]) {     struct _twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_bad() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_badSink(CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_goodG2BSink(CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67b_goodB2GSink(CWE401_Memory_Leak__struct_twoIntsStruct_realloc_67_structType myStruct) {     struct _twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_bad	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_badData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_goodG2BData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_goodB2GData = data;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_good	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_badSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_badSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_goodG2BSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_goodG2BSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_goodB2GSink	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68b_goodB2GSink() {     struct _twoIntsStruct * data = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     vector<struct _twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<struct _twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<struct _twoIntsStruct *> dataVector) {     struct _twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     list<struct _twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<struct _twoIntsStruct *> dataList) {     /* copy data out of dataList */     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<struct _twoIntsStruct *> dataList) {     struct _twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     map<int, struct _twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, struct _twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, struct _twoIntsStruct *> dataMap) {     struct _twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_bad::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_goodB2G::action(struct _twoIntsStruct * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_goodG2B::action(struct _twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     const CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_base& baseObject = CWE401_Memory_Leak__struct_twoIntsStruct_realloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_bad::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_goodB2G::action(struct _twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_goodG2B::action(struct _twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]);     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_base* baseObject = new CWE401_Memory_Leak__struct_twoIntsStruct_realloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_bad	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_bad::CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_bad(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_bad	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodB2G::CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodB2G(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodB2G::~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodG2B::CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodG2B(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodG2B::~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad::CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
1	~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad::~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G::CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (struct _twoIntsStruct *)realloc(data, 100*sizeof(struct _twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G::~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B::CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B(struct _twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (struct _twoIntsStruct *)ALLOCA(100*sizeof(struct _twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine((twoIntsStruct *)&data[0]); }
0	~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B	CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B::~CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad * badObject = new CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     struct _twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__struct_twoIntsStruct_realloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_01_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_01_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_01_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_02_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_02_bad() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_02_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_03_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_03_bad() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_03_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_04_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_04_bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_04_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_05_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_05_bad() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_05_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_06_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_06_bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_06_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_07_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_07_bad() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_07_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_08_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_08_bad() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_08_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_09_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_09_bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_09_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_10_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_10_bad() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_10_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_11_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_11_bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_11_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_12_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_12_bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_12_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_13_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_13_bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_13_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_14_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_14_bad() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_14_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_15_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_15_bad() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_15_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_16_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_16_bad() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_16_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_17_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_17_bad() {     int i,j;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_17_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_18_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_18_bad() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_18_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_21_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_21_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_21_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_22_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_22_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_calloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_22_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_22_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_22_badSink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_calloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G1Sink	void CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G1Sink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G2Sink	void CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G2Sink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodG2BSink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_calloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_31_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_31_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_31_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_32_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_32_bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_32_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_34_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_34_bad() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_calloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_34_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_41_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_41_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_41_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static twoIntsStruct * badSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_42_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_42_bad() {     twoIntsStruct * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_42_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_44_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_44_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_44_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_calloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_45_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_45_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_calloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_calloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_45_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_51_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_51_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_51_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_51b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_51b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_51b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_51b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_51b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_51b_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_52_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_52_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_52_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_52b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_52b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_52c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_52b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_52b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_52b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_52b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_52c_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_52c_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_52c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_52c_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_52c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_52c_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_53_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_53_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_53_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_53b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_53c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_53b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_53b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_53c_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53c_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_53d_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_53c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53c_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_53c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53c_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_53d_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53d_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_53d_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53d_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_53d_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_53d_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_54_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_54_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_54b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_54c_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54c_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54d_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54c_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54c_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_54d_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54d_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54e_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54d_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54d_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54d_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54d_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_calloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_54e_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54e_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54e_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54e_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_54e_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_54e_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_61_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_61_bad() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_calloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_calloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_calloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_61_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_61b_badSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_calloc_61b_badSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_61b_goodG2BSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_calloc_61b_goodG2BSource(twoIntsStruct * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_61b_goodB2GSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_calloc_61b_goodB2GSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodG2BSource	void goodG2BSource(twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodB2GSource	void goodB2GSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_63_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_63_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_63_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_63b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_63b_badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_63b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_63b_goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_63b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_63b_goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_64_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_64_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_64_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_64b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_64b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_64b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_65_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_65_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_calloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_calloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_calloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_65_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_65b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_65b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_65b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_65b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_65b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_65b_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_66_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_66_bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_66_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_66b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_66b_badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_66b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_66b_goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_66b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_66b_goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_67_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_67_bad() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_calloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_67_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_67b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_67b_badSink(CWE401_Memory_Leak__twoIntsStruct_calloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_67b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_67b_goodG2BSink(CWE401_Memory_Leak__twoIntsStruct_calloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_67b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_67b_goodB2GSink(CWE401_Memory_Leak__twoIntsStruct_calloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_68_bad	void CWE401_Memory_Leak__twoIntsStruct_calloc_68_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_68_badData = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_68_goodG2BData = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_68_goodB2GData = data;     CWE401_Memory_Leak__twoIntsStruct_calloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_68_good	void CWE401_Memory_Leak__twoIntsStruct_calloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_68b_badSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_68b_badSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_calloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_68b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_68b_goodG2BSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_calloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_68b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_calloc_68b_goodB2GSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_calloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_calloc_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__twoIntsStruct_calloc_81_goodB2G::action(twoIntsStruct * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_calloc_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_calloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_calloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_calloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_calloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_calloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_calloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_calloc_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__twoIntsStruct_calloc_82_goodB2G::action(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_calloc_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_calloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_calloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_calloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_calloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad	CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad::CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	~CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad	CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad::~CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodB2G	CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodB2G::CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodB2G	CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodB2G::~CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodG2B	CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodG2B::CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodG2B	CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodG2B::~CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_calloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_calloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad	CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad::CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	~CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad	CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad::~CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G	CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G::CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)calloc(100, sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G	CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G::~CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B	CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B::CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B	CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B::~CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad * badObject = new CWE401_Memory_Leak__twoIntsStruct_calloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__twoIntsStruct_calloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_01_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_01_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_01_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_02_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_02_bad() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_02_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_03_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_03_bad() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_03_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_04_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_04_bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_04_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_05_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_05_bad() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_05_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_06_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_06_bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_06_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_07_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_07_bad() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_07_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_08_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_08_bad() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_08_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_09_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_09_bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_09_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_10_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_10_bad() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_10_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_11_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_11_bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_11_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_12_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_12_bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_12_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_13_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_13_bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_13_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_14_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_14_bad() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_14_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_15_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_15_bad() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_15_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_16_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_16_bad() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_16_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_17_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_17_bad() {     int i,j;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_17_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_18_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_18_bad() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_18_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_21_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_21_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_21_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_22_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_22_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_malloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_22_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_22_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_22_badSink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G1Sink	void CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G1Sink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G2Sink	void CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G2Sink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodG2BSink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_malloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_31_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_31_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_31_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_32_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_32_bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_32_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_34_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_34_bad() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_malloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_34_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_41_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_41_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_41_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static twoIntsStruct * badSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_42_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_42_bad() {     twoIntsStruct * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_42_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_44_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_44_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_44_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_malloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_45_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_45_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_malloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_malloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_45_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_51_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_51_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_51_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_51b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_51b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_51b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_51b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_51b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_51b_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_52_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_52_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_52_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_52b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_52b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_52c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_52b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_52b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_52b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_52b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_52c_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_52c_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_52c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_52c_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_52c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_52c_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_53_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_53_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_53_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_53b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_53c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_53b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_53b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_53c_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53c_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_53d_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_53c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53c_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_53c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53c_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_53d_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53d_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_53d_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53d_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_53d_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_53d_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_54_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_54_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_54b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_54c_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54c_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54d_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54c_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54c_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_54d_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54d_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54e_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54d_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54d_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54d_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54d_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_malloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_54e_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54e_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54e_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54e_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_54e_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_54e_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_61_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_61_bad() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_malloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_malloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_malloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_61_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_61b_badSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_malloc_61b_badSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_61b_goodG2BSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_malloc_61b_goodG2BSource(twoIntsStruct * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_61b_goodB2GSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_malloc_61b_goodB2GSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodG2BSource	void goodG2BSource(twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodB2GSource	void goodB2GSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_63_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_63_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_63_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_63b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_63b_badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_63b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_63b_goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_63b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_63b_goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_64_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_64_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_64_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_64b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_64b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_64b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_65_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_65_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_malloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_malloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_malloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_65_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_65b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_65b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_65b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_65b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_65b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_65b_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_66_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_66_bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_66_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_66b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_66b_badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_66b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_66b_goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_66b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_66b_goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_67_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_67_bad() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_malloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_67_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_67b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_67b_badSink(CWE401_Memory_Leak__twoIntsStruct_malloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_67b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_67b_goodG2BSink(CWE401_Memory_Leak__twoIntsStruct_malloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_67b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_67b_goodB2GSink(CWE401_Memory_Leak__twoIntsStruct_malloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_68_bad	void CWE401_Memory_Leak__twoIntsStruct_malloc_68_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_68_badData = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_68_goodG2BData = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_68_goodB2GData = data;     CWE401_Memory_Leak__twoIntsStruct_malloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_68_good	void CWE401_Memory_Leak__twoIntsStruct_malloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_68b_badSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_68b_badSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_malloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_68b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_68b_goodG2BSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_malloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_68b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_malloc_68b_goodB2GSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_malloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_malloc_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__twoIntsStruct_malloc_81_goodB2G::action(twoIntsStruct * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_malloc_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_malloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_malloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_malloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_malloc_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__twoIntsStruct_malloc_82_goodB2G::action(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_malloc_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_malloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_malloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad	CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad::CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	~CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad	CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad::~CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodB2G	CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodB2G::CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodB2G	CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodB2G::~CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodG2B	CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodG2B::CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodG2B	CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodG2B::~CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_malloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad	CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad::CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	~CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad	CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad::~CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G	CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G::CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G	CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G::~CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B	CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B::CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B	CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B::~CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad * badObject = new CWE401_Memory_Leak__twoIntsStruct_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__twoIntsStruct_malloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_01_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_01_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_01_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_02_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_02_bad() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_02_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_03_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_03_bad() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_03_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_04_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_04_bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_04_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_05_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_05_bad() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_05_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_06_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_06_bad() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_06_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_07_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_07_bad() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_07_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_08_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_08_bad() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_08_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_09_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_09_bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_09_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_10_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_10_bad() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_10_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_11_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_11_bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_11_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_12_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_12_bad() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_12_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_13_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_13_bad() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_13_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_14_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_14_bad() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_14_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_15_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_15_bad() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_15_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_16_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_16_bad() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_16_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_17_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_17_bad() {     int i,j;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_17_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_18_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_18_bad() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_18_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_21_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_21_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_21_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_22_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_22_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_realloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_22_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_22_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_22_badSink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_realloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G1Sink	void CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G1Sink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G2Sink	void CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G2Sink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodG2BSink(twoIntsStruct * data) {     if(CWE401_Memory_Leak__twoIntsStruct_realloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_31_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_31_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_31_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_32_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_32_bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         data[0].intOne = 0;         data[0].intTwo = 0;         printStructLine(&data[0]);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_32_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     {         twoIntsStruct * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_34_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_34_bad() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_realloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_34_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_41_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_41_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_41_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static twoIntsStruct * badSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_42_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_42_bad() {     twoIntsStruct * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_42_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_44_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_44_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_44_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_realloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_45_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_45_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_realloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_realloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_45_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_51_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_51_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_51_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_51b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_51b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_51b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_51b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_51b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_51b_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_52_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_52_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_52_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_52b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_52b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_52c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_52b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_52b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_52b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_52b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_52c_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_52c_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_52c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_52c_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_52c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_52c_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_53_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_53_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_53_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_53b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_53c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_53b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_53b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_53c_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53c_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_53d_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_53c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53c_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_53c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53c_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_53d_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53d_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_53d_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53d_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_53d_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_53d_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_54_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_54_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_54b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54b_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54c_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54b_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54b_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_54c_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54c_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54d_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54c_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54c_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54c_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54c_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_54d_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54d_badSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54e_badSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54d_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54d_goodG2BSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54d_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54d_goodB2GSink(twoIntsStruct * data) {     CWE401_Memory_Leak__twoIntsStruct_realloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_54e_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54e_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54e_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54e_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_54e_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_54e_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_61_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_61_bad() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_realloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_realloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     data = CWE401_Memory_Leak__twoIntsStruct_realloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_61_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_61b_badSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_realloc_61b_badSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_61b_goodG2BSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_realloc_61b_goodG2BSource(twoIntsStruct * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_61b_goodB2GSource	twoIntsStruct * CWE401_Memory_Leak__twoIntsStruct_realloc_61b_goodB2GSource(twoIntsStruct * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     return data; }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodG2BSource	void goodG2BSource(twoIntsStruct * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	goodB2GSource	void goodB2GSource(twoIntsStruct * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_63_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_63_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_63_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_63b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_63b_badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_63b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_63b_goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_63b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_63b_goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_64_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_64_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_64_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_64b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_64b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_64b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_65_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_65_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_realloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_realloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE401_Memory_Leak__twoIntsStruct_realloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     funcPtr(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_65_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_65b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_65b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_65b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_65b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_65b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_65b_goodB2GSink(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_66_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_66_bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataArray[2] = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_66_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_66b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_66b_badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_66b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_66b_goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_66b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_66b_goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_67_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_67_bad() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_realloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE401_Memory_Leak__twoIntsStruct_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     myStruct.structFirst = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_67_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_67b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_67b_badSink(CWE401_Memory_Leak__twoIntsStruct_realloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_67b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_67b_goodG2BSink(CWE401_Memory_Leak__twoIntsStruct_realloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_67b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_67b_goodB2GSink(CWE401_Memory_Leak__twoIntsStruct_realloc_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_68_bad	void CWE401_Memory_Leak__twoIntsStruct_realloc_68_bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_68_badData = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_68_goodG2BData = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_68_goodB2GData = data;     CWE401_Memory_Leak__twoIntsStruct_realloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_68_good	void CWE401_Memory_Leak__twoIntsStruct_realloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_68b_badSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_68b_badSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_realloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_68b_goodG2BSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_68b_goodG2BSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_realloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_68b_goodB2GSink	void CWE401_Memory_Leak__twoIntsStruct_realloc_68b_goodB2GSink() {     twoIntsStruct * data = CWE401_Memory_Leak__twoIntsStruct_realloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_realloc_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__twoIntsStruct_realloc_81_goodB2G::action(twoIntsStruct * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_realloc_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_realloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_realloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_realloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_realloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     const CWE401_Memory_Leak__twoIntsStruct_realloc_81_base& baseObject = CWE401_Memory_Leak__twoIntsStruct_realloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_realloc_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__twoIntsStruct_realloc_82_goodB2G::action(twoIntsStruct * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__twoIntsStruct_realloc_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_realloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_realloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]);     CWE401_Memory_Leak__twoIntsStruct_realloc_82_base* baseObject = new CWE401_Memory_Leak__twoIntsStruct_realloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_83_bad	CWE401_Memory_Leak__twoIntsStruct_realloc_83_bad::CWE401_Memory_Leak__twoIntsStruct_realloc_83_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	~CWE401_Memory_Leak__twoIntsStruct_realloc_83_bad	CWE401_Memory_Leak__twoIntsStruct_realloc_83_bad::~CWE401_Memory_Leak__twoIntsStruct_realloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodB2G	CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodB2G::CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodB2G	CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodB2G::~CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodG2B	CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodG2B::CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodG2B	CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodG2B::~CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_realloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_realloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad	CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad::CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
1	~CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad	CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad::~CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G	CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G::CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (twoIntsStruct *)realloc(data, 100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G	CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G::~CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B	CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B::CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));     /* Initialize and make use of data */     data[0].intOne = 0;     data[0].intTwo = 0;     printStructLine(&data[0]); }
0	~CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B	CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B::~CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad * badObject = new CWE401_Memory_Leak__twoIntsStruct_realloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     data = NULL;     CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__twoIntsStruct_realloc_84_goodB2G(data);     delete goodB2GObject; }
0	BadBaseClass	BadBaseClass()         {              printLine("Constructor: BadBaseClass");         }
0	~BadBaseClass	~BadBaseClass()         {              printLine("Destructor : BadBaseClass");         }
0	BadDerivedClass	BadDerivedClass(const char * name)         {             printLine("Constructor: BadDerivedClass");             if (name)             {                 this->name = new char[strlen(name) + 1];                 strcpy(this->name, name);                 printLine(this->name);             }             else             {                 this->name = new char[1];                 *(this->name) = '\0';             }         }
0	~BadDerivedClass	~BadDerivedClass()         {             /* This should never be executed */             printLine("Destructor : BadDerivedClass");             delete [] name;         }
0	BadDerivedClass	BadDerivedClass(BadDerivedClass &derivedClassObject)         {              this->name = new char[strlen(derivedClassObject.name) + 1];             strcpy(this->name, derivedClassObject.name);         }
0	=	BadDerivedClass& operator=(const BadDerivedClass &derivedClassObject)         {              if (&derivedClassObject != this)              {                  this->name = new char[strlen(derivedClassObject.name) + 1];                 strcpy(this->name, derivedClassObject.name);             }              return *this;          }
1	bad	void bad() {     BadBaseClass * baseClassObject = new BadDerivedClass("BadClass");      delete baseClassObject; }
0	GoodBaseClass	GoodBaseClass()         {              printLine("Constructor: GoodBaseClass");         }
0	~GoodBaseClass	virtual ~GoodBaseClass()         {             printLine("Destructor : GoodBaseClass");         }
0	GoodDerivedClass	GoodDerivedClass(const char * name)         {              printLine("Constructor: GoodDerivedClass");             if (name)             {                 this->name = new char[strlen(name) + 1];                 strcpy(this->name, name);                 printLine(this->name);             }             else             {                 this->name = new char[1];                 *(this->name) = '\0';             }         }
0	~GoodDerivedClass	~GoodDerivedClass()         {              printLine("Destructor : GoodDerivedClass");             delete [] name;         }
0	GoodDerivedClass	GoodDerivedClass(GoodDerivedClass &derivedClassObject)         {              this->name = new char[strlen(derivedClassObject.name) + 1];             strcpy(this->name, derivedClassObject.name);         }
0	=	GoodDerivedClass& operator=(const GoodDerivedClass &derivedClassObject)         {              if (&derivedClassObject != this)              {                  this->name = new char[strlen(derivedClassObject.name) + 1];                 strcpy(this->name, derivedClassObject.name);             }              return *this;          }
0	good1	static void good1() {     GoodBaseClass * baseClassObject = new GoodDerivedClass("GoodClass");      delete baseClassObject; }
1	CWE401_Memory_Leak__wchar_t_calloc_01_bad	void CWE401_Memory_Leak__wchar_t_calloc_01_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_01_good	void CWE401_Memory_Leak__wchar_t_calloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_02_bad	void CWE401_Memory_Leak__wchar_t_calloc_02_bad() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_02_good	void CWE401_Memory_Leak__wchar_t_calloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_03_bad	void CWE401_Memory_Leak__wchar_t_calloc_03_bad() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_03_good	void CWE401_Memory_Leak__wchar_t_calloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_04_bad	void CWE401_Memory_Leak__wchar_t_calloc_04_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_04_good	void CWE401_Memory_Leak__wchar_t_calloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_05_bad	void CWE401_Memory_Leak__wchar_t_calloc_05_bad() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_05_good	void CWE401_Memory_Leak__wchar_t_calloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_06_bad	void CWE401_Memory_Leak__wchar_t_calloc_06_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_06_good	void CWE401_Memory_Leak__wchar_t_calloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_07_bad	void CWE401_Memory_Leak__wchar_t_calloc_07_bad() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_07_good	void CWE401_Memory_Leak__wchar_t_calloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_08_bad	void CWE401_Memory_Leak__wchar_t_calloc_08_bad() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_08_good	void CWE401_Memory_Leak__wchar_t_calloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_09_bad	void CWE401_Memory_Leak__wchar_t_calloc_09_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_09_good	void CWE401_Memory_Leak__wchar_t_calloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_10_bad	void CWE401_Memory_Leak__wchar_t_calloc_10_bad() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_10_good	void CWE401_Memory_Leak__wchar_t_calloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_11_bad	void CWE401_Memory_Leak__wchar_t_calloc_11_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_11_good	void CWE401_Memory_Leak__wchar_t_calloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_12_bad	void CWE401_Memory_Leak__wchar_t_calloc_12_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_12_good	void CWE401_Memory_Leak__wchar_t_calloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_calloc_13_bad	void CWE401_Memory_Leak__wchar_t_calloc_13_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_13_good	void CWE401_Memory_Leak__wchar_t_calloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_14_bad	void CWE401_Memory_Leak__wchar_t_calloc_14_bad() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_14_good	void CWE401_Memory_Leak__wchar_t_calloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_15_bad	void CWE401_Memory_Leak__wchar_t_calloc_15_bad() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__wchar_t_calloc_15_good	void CWE401_Memory_Leak__wchar_t_calloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_calloc_16_bad	void CWE401_Memory_Leak__wchar_t_calloc_16_bad() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__wchar_t_calloc_16_good	void CWE401_Memory_Leak__wchar_t_calloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_calloc_17_bad	void CWE401_Memory_Leak__wchar_t_calloc_17_bad() {     int i,j;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_17_good	void CWE401_Memory_Leak__wchar_t_calloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_calloc_18_bad	void CWE401_Memory_Leak__wchar_t_calloc_18_bad() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_18_good	void CWE401_Memory_Leak__wchar_t_calloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__wchar_t_calloc_21_bad	void CWE401_Memory_Leak__wchar_t_calloc_21_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_21_good	void CWE401_Memory_Leak__wchar_t_calloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_calloc_22_bad	void CWE401_Memory_Leak__wchar_t_calloc_22_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__wchar_t_calloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__wchar_t_calloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_22_good	void CWE401_Memory_Leak__wchar_t_calloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_calloc_22_badSink	void CWE401_Memory_Leak__wchar_t_calloc_22_badSink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_calloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G1Sink	void CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G1Sink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G2Sink	void CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G2Sink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_calloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_calloc_22_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_22_goodG2BSink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_calloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__wchar_t_calloc_31_bad	void CWE401_Memory_Leak__wchar_t_calloc_31_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_calloc_31_good	void CWE401_Memory_Leak__wchar_t_calloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_32_bad	void CWE401_Memory_Leak__wchar_t_calloc_32_bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)calloc(100, sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_calloc_32_good	void CWE401_Memory_Leak__wchar_t_calloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__wchar_t_calloc_34_bad	void CWE401_Memory_Leak__wchar_t_calloc_34_bad() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_calloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_calloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_calloc_34_good	void CWE401_Memory_Leak__wchar_t_calloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_calloc_41_bad	void CWE401_Memory_Leak__wchar_t_calloc_41_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_41_good	void CWE401_Memory_Leak__wchar_t_calloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static wchar_t * badSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
1	CWE401_Memory_Leak__wchar_t_calloc_42_bad	void CWE401_Memory_Leak__wchar_t_calloc_42_bad() {     wchar_t * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static wchar_t * goodB2GSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_42_good	void CWE401_Memory_Leak__wchar_t_calloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_calloc_44_bad	void CWE401_Memory_Leak__wchar_t_calloc_44_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_44_good	void CWE401_Memory_Leak__wchar_t_calloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_calloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_calloc_45_bad	void CWE401_Memory_Leak__wchar_t_calloc_45_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_calloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_calloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__wchar_t_calloc_45_good	void CWE401_Memory_Leak__wchar_t_calloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_51_bad	void CWE401_Memory_Leak__wchar_t_calloc_51_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_51_good	void CWE401_Memory_Leak__wchar_t_calloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_51b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_51b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_51b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_51b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_51b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_51b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_52_bad	void CWE401_Memory_Leak__wchar_t_calloc_52_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_52_good	void CWE401_Memory_Leak__wchar_t_calloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_52b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_52b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_52c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_52b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_52b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_52b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_52b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_52c_badSink	void CWE401_Memory_Leak__wchar_t_calloc_52c_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_52c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_52c_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_52c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_52c_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_53_bad	void CWE401_Memory_Leak__wchar_t_calloc_53_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_53_good	void CWE401_Memory_Leak__wchar_t_calloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_53b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_53b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_53c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_53b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_53b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_53b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_53b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_53c_badSink	void CWE401_Memory_Leak__wchar_t_calloc_53c_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_53d_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_53c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_53c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_53c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_53c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_53d_badSink	void CWE401_Memory_Leak__wchar_t_calloc_53d_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_53d_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_53d_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_53d_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_53d_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_54_bad	void CWE401_Memory_Leak__wchar_t_calloc_54_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_54_good	void CWE401_Memory_Leak__wchar_t_calloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_54b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_54b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_54b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_54b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_54b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_54b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_54c_badSink	void CWE401_Memory_Leak__wchar_t_calloc_54c_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54d_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_54c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_54c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_54c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_54c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_54d_badSink	void CWE401_Memory_Leak__wchar_t_calloc_54d_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54e_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_54d_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_54d_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_54d_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_54d_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_calloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_54e_badSink	void CWE401_Memory_Leak__wchar_t_calloc_54e_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_54e_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_54e_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_54e_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_54e_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_61_bad	void CWE401_Memory_Leak__wchar_t_calloc_61_bad() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_calloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_calloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_calloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_61_good	void CWE401_Memory_Leak__wchar_t_calloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_61b_badSource	wchar_t * CWE401_Memory_Leak__wchar_t_calloc_61b_badSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	CWE401_Memory_Leak__wchar_t_calloc_61b_goodG2BSource	wchar_t * CWE401_Memory_Leak__wchar_t_calloc_61b_goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	CWE401_Memory_Leak__wchar_t_calloc_61b_goodB2GSource	wchar_t * CWE401_Memory_Leak__wchar_t_calloc_61b_goodB2GSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodG2BSource	void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodB2GSource	void goodB2GSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_63_bad	void CWE401_Memory_Leak__wchar_t_calloc_63_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__wchar_t_calloc_63_good	void CWE401_Memory_Leak__wchar_t_calloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_63b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_63b_badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_63b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_63b_goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_63b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_63b_goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_64_bad	void CWE401_Memory_Leak__wchar_t_calloc_64_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__wchar_t_calloc_64_good	void CWE401_Memory_Leak__wchar_t_calloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_64b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_64b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_64b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_65_bad	void CWE401_Memory_Leak__wchar_t_calloc_65_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_calloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_calloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_calloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_65_good	void CWE401_Memory_Leak__wchar_t_calloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_65b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_65b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_65b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_65b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_65b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_65b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_66_bad	void CWE401_Memory_Leak__wchar_t_calloc_66_bad() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_calloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_calloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_calloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__wchar_t_calloc_66_good	void CWE401_Memory_Leak__wchar_t_calloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_66b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_66b_badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_66b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_66b_goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_66b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_66b_goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_67_bad	void CWE401_Memory_Leak__wchar_t_calloc_67_bad() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_calloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_calloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_calloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_calloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_calloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__wchar_t_calloc_67_good	void CWE401_Memory_Leak__wchar_t_calloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_67b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_67b_badSink(CWE401_Memory_Leak__wchar_t_calloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_67b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_67b_goodG2BSink(CWE401_Memory_Leak__wchar_t_calloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_67b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_67b_goodB2GSink(CWE401_Memory_Leak__wchar_t_calloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_68_bad	void CWE401_Memory_Leak__wchar_t_calloc_68_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_68_badData = data;     CWE401_Memory_Leak__wchar_t_calloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_68_goodG2BData = data;     CWE401_Memory_Leak__wchar_t_calloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_68_goodB2GData = data;     CWE401_Memory_Leak__wchar_t_calloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__wchar_t_calloc_68_good	void CWE401_Memory_Leak__wchar_t_calloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_calloc_68b_badSink	void CWE401_Memory_Leak__wchar_t_calloc_68b_badSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_calloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_68b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_calloc_68b_goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_calloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_68b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_calloc_68b_goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_calloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_calloc_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__wchar_t_calloc_81_goodB2G::action(wchar_t * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_calloc_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_calloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_calloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_calloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_calloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_calloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_calloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__wchar_t_calloc_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__wchar_t_calloc_82_goodB2G::action(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_calloc_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_calloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_calloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_calloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_calloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__wchar_t_calloc_83_bad	CWE401_Memory_Leak__wchar_t_calloc_83_bad::CWE401_Memory_Leak__wchar_t_calloc_83_bad(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	~CWE401_Memory_Leak__wchar_t_calloc_83_bad	CWE401_Memory_Leak__wchar_t_calloc_83_bad::~CWE401_Memory_Leak__wchar_t_calloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_83_goodB2G	CWE401_Memory_Leak__wchar_t_calloc_83_goodB2G::CWE401_Memory_Leak__wchar_t_calloc_83_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_calloc_83_goodB2G	CWE401_Memory_Leak__wchar_t_calloc_83_goodB2G::~CWE401_Memory_Leak__wchar_t_calloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_83_goodG2B	CWE401_Memory_Leak__wchar_t_calloc_83_goodG2B::CWE401_Memory_Leak__wchar_t_calloc_83_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_calloc_83_goodG2B	CWE401_Memory_Leak__wchar_t_calloc_83_goodG2B::~CWE401_Memory_Leak__wchar_t_calloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_calloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_calloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_calloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__wchar_t_calloc_84_bad	CWE401_Memory_Leak__wchar_t_calloc_84_bad::CWE401_Memory_Leak__wchar_t_calloc_84_bad(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	~CWE401_Memory_Leak__wchar_t_calloc_84_bad	CWE401_Memory_Leak__wchar_t_calloc_84_bad::~CWE401_Memory_Leak__wchar_t_calloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G	CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G::CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)calloc(100, sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G	CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G::~CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B	CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B::CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B	CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B::~CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_calloc_84_bad * badObject = new CWE401_Memory_Leak__wchar_t_calloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__wchar_t_calloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__wchar_t_calloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__wchar_t_malloc_01_bad	void CWE401_Memory_Leak__wchar_t_malloc_01_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_01_good	void CWE401_Memory_Leak__wchar_t_malloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_02_bad	void CWE401_Memory_Leak__wchar_t_malloc_02_bad() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_02_good	void CWE401_Memory_Leak__wchar_t_malloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_03_bad	void CWE401_Memory_Leak__wchar_t_malloc_03_bad() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_03_good	void CWE401_Memory_Leak__wchar_t_malloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_04_bad	void CWE401_Memory_Leak__wchar_t_malloc_04_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_04_good	void CWE401_Memory_Leak__wchar_t_malloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_05_bad	void CWE401_Memory_Leak__wchar_t_malloc_05_bad() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_05_good	void CWE401_Memory_Leak__wchar_t_malloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_06_bad	void CWE401_Memory_Leak__wchar_t_malloc_06_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_06_good	void CWE401_Memory_Leak__wchar_t_malloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_07_bad	void CWE401_Memory_Leak__wchar_t_malloc_07_bad() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_07_good	void CWE401_Memory_Leak__wchar_t_malloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_08_bad	void CWE401_Memory_Leak__wchar_t_malloc_08_bad() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_08_good	void CWE401_Memory_Leak__wchar_t_malloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_09_bad	void CWE401_Memory_Leak__wchar_t_malloc_09_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_09_good	void CWE401_Memory_Leak__wchar_t_malloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_10_bad	void CWE401_Memory_Leak__wchar_t_malloc_10_bad() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_10_good	void CWE401_Memory_Leak__wchar_t_malloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_11_bad	void CWE401_Memory_Leak__wchar_t_malloc_11_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_11_good	void CWE401_Memory_Leak__wchar_t_malloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_12_bad	void CWE401_Memory_Leak__wchar_t_malloc_12_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_12_good	void CWE401_Memory_Leak__wchar_t_malloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_malloc_13_bad	void CWE401_Memory_Leak__wchar_t_malloc_13_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_13_good	void CWE401_Memory_Leak__wchar_t_malloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_14_bad	void CWE401_Memory_Leak__wchar_t_malloc_14_bad() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_14_good	void CWE401_Memory_Leak__wchar_t_malloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_15_bad	void CWE401_Memory_Leak__wchar_t_malloc_15_bad() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__wchar_t_malloc_15_good	void CWE401_Memory_Leak__wchar_t_malloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_malloc_16_bad	void CWE401_Memory_Leak__wchar_t_malloc_16_bad() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__wchar_t_malloc_16_good	void CWE401_Memory_Leak__wchar_t_malloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_malloc_17_bad	void CWE401_Memory_Leak__wchar_t_malloc_17_bad() {     int i,j;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_17_good	void CWE401_Memory_Leak__wchar_t_malloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_malloc_18_bad	void CWE401_Memory_Leak__wchar_t_malloc_18_bad() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_18_good	void CWE401_Memory_Leak__wchar_t_malloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__wchar_t_malloc_21_bad	void CWE401_Memory_Leak__wchar_t_malloc_21_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_21_good	void CWE401_Memory_Leak__wchar_t_malloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_malloc_22_bad	void CWE401_Memory_Leak__wchar_t_malloc_22_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__wchar_t_malloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__wchar_t_malloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_22_good	void CWE401_Memory_Leak__wchar_t_malloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_malloc_22_badSink	void CWE401_Memory_Leak__wchar_t_malloc_22_badSink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_malloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G1Sink	void CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G1Sink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G2Sink	void CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G2Sink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_malloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_malloc_22_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_22_goodG2BSink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_malloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__wchar_t_malloc_31_bad	void CWE401_Memory_Leak__wchar_t_malloc_31_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_malloc_31_good	void CWE401_Memory_Leak__wchar_t_malloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_32_bad	void CWE401_Memory_Leak__wchar_t_malloc_32_bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_malloc_32_good	void CWE401_Memory_Leak__wchar_t_malloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__wchar_t_malloc_34_bad	void CWE401_Memory_Leak__wchar_t_malloc_34_bad() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_malloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_malloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_malloc_34_good	void CWE401_Memory_Leak__wchar_t_malloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_malloc_41_bad	void CWE401_Memory_Leak__wchar_t_malloc_41_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_41_good	void CWE401_Memory_Leak__wchar_t_malloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static wchar_t * badSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
1	CWE401_Memory_Leak__wchar_t_malloc_42_bad	void CWE401_Memory_Leak__wchar_t_malloc_42_bad() {     wchar_t * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static wchar_t * goodB2GSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_42_good	void CWE401_Memory_Leak__wchar_t_malloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_malloc_44_bad	void CWE401_Memory_Leak__wchar_t_malloc_44_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_44_good	void CWE401_Memory_Leak__wchar_t_malloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_malloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_malloc_45_bad	void CWE401_Memory_Leak__wchar_t_malloc_45_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_malloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_malloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__wchar_t_malloc_45_good	void CWE401_Memory_Leak__wchar_t_malloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_51_bad	void CWE401_Memory_Leak__wchar_t_malloc_51_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_51_good	void CWE401_Memory_Leak__wchar_t_malloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_51b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_51b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_51b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_51b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_51b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_51b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_52_bad	void CWE401_Memory_Leak__wchar_t_malloc_52_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_52_good	void CWE401_Memory_Leak__wchar_t_malloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_52b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_52b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_52c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_52b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_52b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_52b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_52b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_52c_badSink	void CWE401_Memory_Leak__wchar_t_malloc_52c_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_52c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_52c_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_52c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_52c_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_53_bad	void CWE401_Memory_Leak__wchar_t_malloc_53_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_53_good	void CWE401_Memory_Leak__wchar_t_malloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_53b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_53b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_53c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_53b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_53b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_53b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_53b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_53c_badSink	void CWE401_Memory_Leak__wchar_t_malloc_53c_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_53d_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_53c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_53c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_53c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_53c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_53d_badSink	void CWE401_Memory_Leak__wchar_t_malloc_53d_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_53d_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_53d_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_53d_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_53d_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_54_bad	void CWE401_Memory_Leak__wchar_t_malloc_54_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_54_good	void CWE401_Memory_Leak__wchar_t_malloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_54b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_54b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_54b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_54b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_54b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_54b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_54c_badSink	void CWE401_Memory_Leak__wchar_t_malloc_54c_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54d_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_54c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_54c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_54c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_54c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_54d_badSink	void CWE401_Memory_Leak__wchar_t_malloc_54d_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54e_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_54d_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_54d_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_54d_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_54d_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_malloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_54e_badSink	void CWE401_Memory_Leak__wchar_t_malloc_54e_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_54e_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_54e_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_54e_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_54e_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_61_bad	void CWE401_Memory_Leak__wchar_t_malloc_61_bad() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_malloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_malloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_malloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_61_good	void CWE401_Memory_Leak__wchar_t_malloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_61b_badSource	wchar_t * CWE401_Memory_Leak__wchar_t_malloc_61b_badSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	CWE401_Memory_Leak__wchar_t_malloc_61b_goodG2BSource	wchar_t * CWE401_Memory_Leak__wchar_t_malloc_61b_goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	CWE401_Memory_Leak__wchar_t_malloc_61b_goodB2GSource	wchar_t * CWE401_Memory_Leak__wchar_t_malloc_61b_goodB2GSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodG2BSource	void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodB2GSource	void goodB2GSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_63_bad	void CWE401_Memory_Leak__wchar_t_malloc_63_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__wchar_t_malloc_63_good	void CWE401_Memory_Leak__wchar_t_malloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_63b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_63b_badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_63b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_63b_goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_63b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_63b_goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_64_bad	void CWE401_Memory_Leak__wchar_t_malloc_64_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__wchar_t_malloc_64_good	void CWE401_Memory_Leak__wchar_t_malloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_64b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_64b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_64b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_65_bad	void CWE401_Memory_Leak__wchar_t_malloc_65_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_malloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_malloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_malloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_65_good	void CWE401_Memory_Leak__wchar_t_malloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_65b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_65b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_65b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_65b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_65b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_65b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_66_bad	void CWE401_Memory_Leak__wchar_t_malloc_66_bad() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_malloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_malloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_malloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__wchar_t_malloc_66_good	void CWE401_Memory_Leak__wchar_t_malloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_66b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_66b_badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_66b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_66b_goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_66b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_66b_goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_67_bad	void CWE401_Memory_Leak__wchar_t_malloc_67_bad() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_malloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_malloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_malloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_malloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_malloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__wchar_t_malloc_67_good	void CWE401_Memory_Leak__wchar_t_malloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_67b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_67b_badSink(CWE401_Memory_Leak__wchar_t_malloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_67b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_67b_goodG2BSink(CWE401_Memory_Leak__wchar_t_malloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_67b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_67b_goodB2GSink(CWE401_Memory_Leak__wchar_t_malloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_68_bad	void CWE401_Memory_Leak__wchar_t_malloc_68_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_68_badData = data;     CWE401_Memory_Leak__wchar_t_malloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_68_goodG2BData = data;     CWE401_Memory_Leak__wchar_t_malloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_68_goodB2GData = data;     CWE401_Memory_Leak__wchar_t_malloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__wchar_t_malloc_68_good	void CWE401_Memory_Leak__wchar_t_malloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_malloc_68b_badSink	void CWE401_Memory_Leak__wchar_t_malloc_68b_badSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_malloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_68b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_malloc_68b_goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_malloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_68b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_malloc_68b_goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_malloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_malloc_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__wchar_t_malloc_81_goodB2G::action(wchar_t * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_malloc_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_malloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_malloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_malloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_malloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_malloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_malloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__wchar_t_malloc_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__wchar_t_malloc_82_goodB2G::action(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_malloc_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_malloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_malloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_malloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_malloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__wchar_t_malloc_83_bad	CWE401_Memory_Leak__wchar_t_malloc_83_bad::CWE401_Memory_Leak__wchar_t_malloc_83_bad(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	~CWE401_Memory_Leak__wchar_t_malloc_83_bad	CWE401_Memory_Leak__wchar_t_malloc_83_bad::~CWE401_Memory_Leak__wchar_t_malloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_83_goodB2G	CWE401_Memory_Leak__wchar_t_malloc_83_goodB2G::CWE401_Memory_Leak__wchar_t_malloc_83_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_malloc_83_goodB2G	CWE401_Memory_Leak__wchar_t_malloc_83_goodB2G::~CWE401_Memory_Leak__wchar_t_malloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_83_goodG2B	CWE401_Memory_Leak__wchar_t_malloc_83_goodG2B::CWE401_Memory_Leak__wchar_t_malloc_83_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_malloc_83_goodG2B	CWE401_Memory_Leak__wchar_t_malloc_83_goodG2B::~CWE401_Memory_Leak__wchar_t_malloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_malloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_malloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_malloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__wchar_t_malloc_84_bad	CWE401_Memory_Leak__wchar_t_malloc_84_bad::CWE401_Memory_Leak__wchar_t_malloc_84_bad(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	~CWE401_Memory_Leak__wchar_t_malloc_84_bad	CWE401_Memory_Leak__wchar_t_malloc_84_bad::~CWE401_Memory_Leak__wchar_t_malloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G	CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G::CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G	CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G::~CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B	CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B::CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B	CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B::~CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_malloc_84_bad * badObject = new CWE401_Memory_Leak__wchar_t_malloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__wchar_t_malloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__wchar_t_malloc_84_goodB2G(data);     delete goodB2GObject; }
1	CWE401_Memory_Leak__wchar_t_realloc_01_bad	void CWE401_Memory_Leak__wchar_t_realloc_01_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_01_good	void CWE401_Memory_Leak__wchar_t_realloc_01_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_02_bad	void CWE401_Memory_Leak__wchar_t_realloc_02_bad() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_02_good	void CWE401_Memory_Leak__wchar_t_realloc_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_03_bad	void CWE401_Memory_Leak__wchar_t_realloc_03_bad() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(5==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(5==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_03_good	void CWE401_Memory_Leak__wchar_t_realloc_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_04_bad	void CWE401_Memory_Leak__wchar_t_realloc_04_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_04_good	void CWE401_Memory_Leak__wchar_t_realloc_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_05_bad	void CWE401_Memory_Leak__wchar_t_realloc_05_bad() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_05_good	void CWE401_Memory_Leak__wchar_t_realloc_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_06_bad	void CWE401_Memory_Leak__wchar_t_realloc_06_bad() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(STATIC_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_06_good	void CWE401_Memory_Leak__wchar_t_realloc_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_07_bad	void CWE401_Memory_Leak__wchar_t_realloc_07_bad() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_07_good	void CWE401_Memory_Leak__wchar_t_realloc_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_08_bad	void CWE401_Memory_Leak__wchar_t_realloc_08_bad() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(staticReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_08_good	void CWE401_Memory_Leak__wchar_t_realloc_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_09_bad	void CWE401_Memory_Leak__wchar_t_realloc_09_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_TRUE)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_09_good	void CWE401_Memory_Leak__wchar_t_realloc_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_10_bad	void CWE401_Memory_Leak__wchar_t_realloc_10_bad() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalTrue)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_10_good	void CWE401_Memory_Leak__wchar_t_realloc_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_11_bad	void CWE401_Memory_Leak__wchar_t_realloc_11_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalReturnsTrue())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_11_good	void CWE401_Memory_Leak__wchar_t_realloc_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_12_bad	void CWE401_Memory_Leak__wchar_t_realloc_12_bad() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* FIX: Deallocate memory */         free(data);     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     if(globalReturnsTrueOrFalse())     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     }     else     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_12_good	void CWE401_Memory_Leak__wchar_t_realloc_12_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_realloc_13_bad	void CWE401_Memory_Leak__wchar_t_realloc_13_bad() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_13_good	void CWE401_Memory_Leak__wchar_t_realloc_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_14_bad	void CWE401_Memory_Leak__wchar_t_realloc_14_bad() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     if(globalFive==5)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_14_good	void CWE401_Memory_Leak__wchar_t_realloc_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_15_bad	void CWE401_Memory_Leak__wchar_t_realloc_15_bad() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* FIX: Deallocate memory */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     data = NULL;     switch(6)     {     case 6:         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE401_Memory_Leak__wchar_t_realloc_15_good	void CWE401_Memory_Leak__wchar_t_realloc_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE401_Memory_Leak__wchar_t_realloc_16_bad	void CWE401_Memory_Leak__wchar_t_realloc_16_bad() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     while(1)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* FIX: Deallocate memory */         free(data);         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     while(1)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */         break;     } }
0	CWE401_Memory_Leak__wchar_t_realloc_16_good	void CWE401_Memory_Leak__wchar_t_realloc_16_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_realloc_17_bad	void CWE401_Memory_Leak__wchar_t_realloc_17_bad() {     int i,j;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     data = NULL;     for(i = 0; i < 1; i++)     {         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(k = 0; k < 1; k++)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     data = NULL;     for(h = 0; h < 1; h++)     {         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_17_good	void CWE401_Memory_Leak__wchar_t_realloc_17_good() {     goodB2G();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_realloc_18_bad	void CWE401_Memory_Leak__wchar_t_realloc_18_bad() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goto source; source:     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* FIX: Deallocate memory */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goto source; source:     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goto sink; sink:     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_18_good	void CWE401_Memory_Leak__wchar_t_realloc_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__wchar_t_realloc_21_bad	void CWE401_Memory_Leak__wchar_t_realloc_21_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* FIX: Deallocate memory */         free(data);     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_21_good	void CWE401_Memory_Leak__wchar_t_realloc_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_realloc_22_bad	void CWE401_Memory_Leak__wchar_t_realloc_22_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_22_badGlobal = 1; /* true */     CWE401_Memory_Leak__wchar_t_realloc_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G1Global = 0; /* false */     CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G2Global = 1; /* true */     CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_22_goodG2BGlobal = 1; /* true */     CWE401_Memory_Leak__wchar_t_realloc_22_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_22_good	void CWE401_Memory_Leak__wchar_t_realloc_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE401_Memory_Leak__wchar_t_realloc_22_badSink	void CWE401_Memory_Leak__wchar_t_realloc_22_badSink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_realloc_22_badGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G1Sink	void CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G1Sink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G2Sink	void CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G2Sink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_realloc_22_goodB2G2Global)     {         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_realloc_22_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_22_goodG2BSink(wchar_t * data) {     if(CWE401_Memory_Leak__wchar_t_realloc_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
1	CWE401_Memory_Leak__wchar_t_realloc_31_bad	void CWE401_Memory_Leak__wchar_t_realloc_31_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_realloc_31_good	void CWE401_Memory_Leak__wchar_t_realloc_31_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_32_bad	void CWE401_Memory_Leak__wchar_t_realloc_32_bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* FIX: Use memory allocated on the stack with ALLOCA */         data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     data = NULL;     {         wchar_t * data = *dataPtr1;         /* POTENTIAL FLAW: Allocate memory on the heap */         data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* Initialize and make use of data */         wcscpy(data, L"A String");         printWLine(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_realloc_32_good	void CWE401_Memory_Leak__wchar_t_realloc_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     {         wchar_t * data = dataRef;         /* FIX: Deallocate memory */         free(data);     } }
1	CWE401_Memory_Leak__wchar_t_realloc_34_bad	void CWE401_Memory_Leak__wchar_t_realloc_34_bad() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_realloc_34_unionType myUnion;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: No deallocation */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_realloc_34_unionType myUnion;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* FIX: Deallocate memory */         free(data);     } }
0	CWE401_Memory_Leak__wchar_t_realloc_34_good	void CWE401_Memory_Leak__wchar_t_realloc_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_realloc_41_bad	void CWE401_Memory_Leak__wchar_t_realloc_41_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_41_good	void CWE401_Memory_Leak__wchar_t_realloc_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static wchar_t * badSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
1	CWE401_Memory_Leak__wchar_t_realloc_42_bad	void CWE401_Memory_Leak__wchar_t_realloc_42_bad() {     wchar_t * data;     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static wchar_t * goodB2GSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_42_good	void CWE401_Memory_Leak__wchar_t_realloc_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSource	static void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSource	static void goodB2GSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_realloc_44_bad	void CWE401_Memory_Leak__wchar_t_realloc_44_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_44_good	void CWE401_Memory_Leak__wchar_t_realloc_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_realloc_45_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	CWE401_Memory_Leak__wchar_t_realloc_45_bad	void CWE401_Memory_Leak__wchar_t_realloc_45_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_realloc_45_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_realloc_45_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_45_goodB2GData = data;     goodB2GSink(); }
0	CWE401_Memory_Leak__wchar_t_realloc_45_good	void CWE401_Memory_Leak__wchar_t_realloc_45_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_51_bad	void CWE401_Memory_Leak__wchar_t_realloc_51_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_51b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_51_good	void CWE401_Memory_Leak__wchar_t_realloc_51_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_51b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_51b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_51b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_51b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_51b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_51b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_52_bad	void CWE401_Memory_Leak__wchar_t_realloc_52_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_52b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_52_good	void CWE401_Memory_Leak__wchar_t_realloc_52_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_52b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_52b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_52c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_52b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_52b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_52c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_52b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_52b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_52c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_52c_badSink	void CWE401_Memory_Leak__wchar_t_realloc_52c_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_52c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_52c_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_52c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_52c_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_53_bad	void CWE401_Memory_Leak__wchar_t_realloc_53_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_53b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_53_good	void CWE401_Memory_Leak__wchar_t_realloc_53_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_53b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_53b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_53c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_53b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_53b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_53c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_53b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_53b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_53c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_53c_badSink	void CWE401_Memory_Leak__wchar_t_realloc_53c_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_53d_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_53c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_53c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_53d_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_53c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_53c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_53d_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_53d_badSink	void CWE401_Memory_Leak__wchar_t_realloc_53d_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_53d_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_53d_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_53d_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_53d_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_54_bad	void CWE401_Memory_Leak__wchar_t_realloc_54_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_54b_goodB2GSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_54_good	void CWE401_Memory_Leak__wchar_t_realloc_54_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_54b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_54b_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54c_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_54b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_54b_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54c_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_54b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_54b_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54c_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_54c_badSink	void CWE401_Memory_Leak__wchar_t_realloc_54c_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54d_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_54c_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_54c_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54d_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_54c_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_54c_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54d_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_54d_badSink	void CWE401_Memory_Leak__wchar_t_realloc_54d_badSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54e_badSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_54d_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_54d_goodG2BSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54e_goodG2BSink(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_54d_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_54d_goodB2GSink(wchar_t * data) {     CWE401_Memory_Leak__wchar_t_realloc_54e_goodB2GSink(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_54e_badSink	void CWE401_Memory_Leak__wchar_t_realloc_54e_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_54e_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_54e_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_54e_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_54e_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_61_bad	void CWE401_Memory_Leak__wchar_t_realloc_61_bad() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_realloc_61b_badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_realloc_61b_goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     data = CWE401_Memory_Leak__wchar_t_realloc_61b_goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_61_good	void CWE401_Memory_Leak__wchar_t_realloc_61_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_61b_badSource	wchar_t * CWE401_Memory_Leak__wchar_t_realloc_61b_badSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	CWE401_Memory_Leak__wchar_t_realloc_61b_goodG2BSource	wchar_t * CWE401_Memory_Leak__wchar_t_realloc_61b_goodG2BSource(wchar_t * data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
0	CWE401_Memory_Leak__wchar_t_realloc_61b_goodB2GSource	wchar_t * CWE401_Memory_Leak__wchar_t_realloc_61b_goodB2GSource(wchar_t * data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     return data; }
1	bad	void bad() {     wchar_t * data;     data = NULL;     badSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     goodB2GSource(data);     /* FIX: Deallocate memory */     free(data); }
1	badSource	void badSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodG2BSource	void goodG2BSource(wchar_t * &data) {     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	goodB2GSource	void goodB2GSource(wchar_t * &data) {     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_63_bad	void CWE401_Memory_Leak__wchar_t_realloc_63_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_63b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__wchar_t_realloc_63_good	void CWE401_Memory_Leak__wchar_t_realloc_63_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_63b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_63b_badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_63b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_63b_goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_63b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_63b_goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_64_bad	void CWE401_Memory_Leak__wchar_t_realloc_64_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_64b_goodB2GSink(&data); }
0	CWE401_Memory_Leak__wchar_t_realloc_64_good	void CWE401_Memory_Leak__wchar_t_realloc_64_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_64b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_64b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_64b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_65_bad	void CWE401_Memory_Leak__wchar_t_realloc_65_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_realloc_65b_badSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_realloc_65b_goodG2BSink;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE401_Memory_Leak__wchar_t_realloc_65b_goodB2GSink;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     funcPtr(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_65_good	void CWE401_Memory_Leak__wchar_t_realloc_65_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_65b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_65b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_65b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_65b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_65b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_65b_goodB2GSink(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_66_bad	void CWE401_Memory_Leak__wchar_t_realloc_66_bad() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* put data in array */     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_realloc_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_realloc_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataArray[2] = data;     CWE401_Memory_Leak__wchar_t_realloc_66b_goodB2GSink(dataArray); }
0	CWE401_Memory_Leak__wchar_t_realloc_66_good	void CWE401_Memory_Leak__wchar_t_realloc_66_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_66b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_66b_badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_66b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_66b_goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_66b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_66b_goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_67_bad	void CWE401_Memory_Leak__wchar_t_realloc_67_bad() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_realloc_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_realloc_67_structType myStruct;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_realloc_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE401_Memory_Leak__wchar_t_realloc_67_structType myStruct;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     myStruct.structFirst = data;     CWE401_Memory_Leak__wchar_t_realloc_67b_goodB2GSink(myStruct); }
0	CWE401_Memory_Leak__wchar_t_realloc_67_good	void CWE401_Memory_Leak__wchar_t_realloc_67_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_67b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_67b_badSink(CWE401_Memory_Leak__wchar_t_realloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_67b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_67b_goodG2BSink(CWE401_Memory_Leak__wchar_t_realloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_67b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_67b_goodB2GSink(CWE401_Memory_Leak__wchar_t_realloc_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* FIX: Deallocate memory */     free(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_68_bad	void CWE401_Memory_Leak__wchar_t_realloc_68_bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_68_badData = data;     CWE401_Memory_Leak__wchar_t_realloc_68b_badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_68_goodG2BData = data;     CWE401_Memory_Leak__wchar_t_realloc_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_68_goodB2GData = data;     CWE401_Memory_Leak__wchar_t_realloc_68b_goodB2GSink(); }
0	CWE401_Memory_Leak__wchar_t_realloc_68_good	void CWE401_Memory_Leak__wchar_t_realloc_68_good() {     goodG2B();     goodB2G(); }
1	CWE401_Memory_Leak__wchar_t_realloc_68b_badSink	void CWE401_Memory_Leak__wchar_t_realloc_68b_badSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_realloc_68_badData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_68b_goodG2BSink	void CWE401_Memory_Leak__wchar_t_realloc_68b_goodG2BSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_realloc_68_goodG2BData;     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_68b_goodB2GSink	void CWE401_Memory_Leak__wchar_t_realloc_68b_goodB2GSink() {     wchar_t * data = CWE401_Memory_Leak__wchar_t_realloc_68_goodB2GData;     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* FIX: Deallocate memory */     free(data); }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_realloc_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__wchar_t_realloc_81_goodB2G::action(wchar_t * data) const {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_realloc_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_realloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_realloc_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_realloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_realloc_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     const CWE401_Memory_Leak__wchar_t_realloc_81_base& baseObject = CWE401_Memory_Leak__wchar_t_realloc_81_goodB2G();     baseObject.action(data); }
0	action	void CWE401_Memory_Leak__wchar_t_realloc_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE401_Memory_Leak__wchar_t_realloc_82_goodB2G::action(wchar_t * data) {     /* FIX: Deallocate memory */     free(data); }
0	action	void CWE401_Memory_Leak__wchar_t_realloc_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_realloc_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_realloc_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data);     CWE401_Memory_Leak__wchar_t_realloc_82_base* baseObject = new CWE401_Memory_Leak__wchar_t_realloc_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE401_Memory_Leak__wchar_t_realloc_83_bad	CWE401_Memory_Leak__wchar_t_realloc_83_bad::CWE401_Memory_Leak__wchar_t_realloc_83_bad(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	~CWE401_Memory_Leak__wchar_t_realloc_83_bad	CWE401_Memory_Leak__wchar_t_realloc_83_bad::~CWE401_Memory_Leak__wchar_t_realloc_83_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_83_goodB2G	CWE401_Memory_Leak__wchar_t_realloc_83_goodB2G::CWE401_Memory_Leak__wchar_t_realloc_83_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_realloc_83_goodB2G	CWE401_Memory_Leak__wchar_t_realloc_83_goodB2G::~CWE401_Memory_Leak__wchar_t_realloc_83_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_83_goodG2B	CWE401_Memory_Leak__wchar_t_realloc_83_goodG2B::CWE401_Memory_Leak__wchar_t_realloc_83_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_realloc_83_goodG2B	CWE401_Memory_Leak__wchar_t_realloc_83_goodG2B::~CWE401_Memory_Leak__wchar_t_realloc_83_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_realloc_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_realloc_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_realloc_83_goodB2G goodB2GObject(data); }
1	CWE401_Memory_Leak__wchar_t_realloc_84_bad	CWE401_Memory_Leak__wchar_t_realloc_84_bad::CWE401_Memory_Leak__wchar_t_realloc_84_bad(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
1	~CWE401_Memory_Leak__wchar_t_realloc_84_bad	CWE401_Memory_Leak__wchar_t_realloc_84_bad::~CWE401_Memory_Leak__wchar_t_realloc_84_bad() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
0	CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G	CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G::CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     /* POTENTIAL FLAW: Allocate memory on the heap */     data = (wchar_t *)realloc(data, 100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G	CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G::~CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G() {     /* FIX: Deallocate memory */     free(data); }
0	CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B	CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B::CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     /* FIX: Use memory allocated on the stack with ALLOCA */     data = (wchar_t *)ALLOCA(100*sizeof(wchar_t));     /* Initialize and make use of data */     wcscpy(data, L"A String");     printWLine(data); }
0	~CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B	CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B::~CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B() {     /* POTENTIAL FLAW: No deallocation */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_realloc_84_bad * badObject = new CWE401_Memory_Leak__wchar_t_realloc_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B * goodG2BObject = new CWE401_Memory_Leak__wchar_t_realloc_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     data = NULL;     CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G * goodB2GObject = new CWE401_Memory_Leak__wchar_t_realloc_84_goodB2G(data);     delete goodB2GObject; }
0	action	virtual void action(struct _twoIntsStruct * data) const = 0;
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	action	virtual void action(struct _twoIntsStruct * data) const = 0;
0	action	virtual void action(TwoIntsClass * data) const = 0;
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	action	virtual void action(struct _twoIntsStruct * data) const = 0;
0	action	virtual void action(struct _twoIntsStruct * data) = 0;
0	action	virtual void action(struct _twoIntsStruct * data) = 0;
0	action	virtual void action(struct _twoIntsStruct * data) = 0;
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	action	virtual void action(struct _twoIntsStruct * data) const = 0;
0	action	virtual void action(TwoIntsClass * data) const = 0;
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	action	virtual void action(struct _twoIntsStruct * data) = 0;
0	action	virtual void action(struct _twoIntsStruct * data) = 0;
0	action	virtual void action(struct _twoIntsStruct * data) const = 0;