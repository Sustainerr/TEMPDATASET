1	CWE415_Double_Free__malloc_free_char_01_bad	void CWE415_Double_Free__malloc_free_char_01_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_char_01_good	void CWE415_Double_Free__malloc_free_char_01_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_02_bad	void CWE415_Double_Free__malloc_free_char_02_bad() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_02_good	void CWE415_Double_Free__malloc_free_char_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_03_bad	void CWE415_Double_Free__malloc_free_char_03_bad() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_03_good	void CWE415_Double_Free__malloc_free_char_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_04_bad	void CWE415_Double_Free__malloc_free_char_04_bad() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_04_good	void CWE415_Double_Free__malloc_free_char_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_05_bad	void CWE415_Double_Free__malloc_free_char_05_bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_05_good	void CWE415_Double_Free__malloc_free_char_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_06_bad	void CWE415_Double_Free__malloc_free_char_06_bad() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_06_good	void CWE415_Double_Free__malloc_free_char_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_07_bad	void CWE415_Double_Free__malloc_free_char_07_bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_07_good	void CWE415_Double_Free__malloc_free_char_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_08_bad	void CWE415_Double_Free__malloc_free_char_08_bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_08_good	void CWE415_Double_Free__malloc_free_char_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_09_bad	void CWE415_Double_Free__malloc_free_char_09_bad() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_09_good	void CWE415_Double_Free__malloc_free_char_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_10_bad	void CWE415_Double_Free__malloc_free_char_10_bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_10_good	void CWE415_Double_Free__malloc_free_char_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_11_bad	void CWE415_Double_Free__malloc_free_char_11_bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_11_good	void CWE415_Double_Free__malloc_free_char_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_12_bad	void CWE415_Double_Free__malloc_free_char_12_bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_12_good	void CWE415_Double_Free__malloc_free_char_12_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_char_13_bad	void CWE415_Double_Free__malloc_free_char_13_bad() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_13_good	void CWE415_Double_Free__malloc_free_char_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_14_bad	void CWE415_Double_Free__malloc_free_char_14_bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_14_good	void CWE415_Double_Free__malloc_free_char_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_15_bad	void CWE415_Double_Free__malloc_free_char_15_bad() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE415_Double_Free__malloc_free_char_15_good	void CWE415_Double_Free__malloc_free_char_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_char_16_bad	void CWE415_Double_Free__malloc_free_char_16_bad() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	CWE415_Double_Free__malloc_free_char_16_good	void CWE415_Double_Free__malloc_free_char_16_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_char_17_bad	void CWE415_Double_Free__malloc_free_char_17_bad() {     int i,j;     char * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_17_good	void CWE415_Double_Free__malloc_free_char_17_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_char_18_bad	void CWE415_Double_Free__malloc_free_char_18_bad() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_18_good	void CWE415_Double_Free__malloc_free_char_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_char_21_bad	void CWE415_Double_Free__malloc_free_char_21_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_21_good	void CWE415_Double_Free__malloc_free_char_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_char_22_bad	void CWE415_Double_Free__malloc_free_char_22_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_22_badGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_char_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_22_goodB2G1Global = 0; /* false */     CWE415_Double_Free__malloc_free_char_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_22_goodB2G2Global = 1; /* true */     CWE415_Double_Free__malloc_free_char_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_22_goodG2BGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_char_22_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_22_good	void CWE415_Double_Free__malloc_free_char_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_char_22_badSink	void CWE415_Double_Free__malloc_free_char_22_badSink(char * data) {     if(CWE415_Double_Free__malloc_free_char_22_badGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_char_22_goodB2G1Sink	void CWE415_Double_Free__malloc_free_char_22_goodB2G1Sink(char * data) {     if(CWE415_Double_Free__malloc_free_char_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_char_22_goodB2G2Sink	void CWE415_Double_Free__malloc_free_char_22_goodB2G2Sink(char * data) {     if(CWE415_Double_Free__malloc_free_char_22_goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_char_22_goodG2BSink	void CWE415_Double_Free__malloc_free_char_22_goodG2BSink(char * data) {     if(CWE415_Double_Free__malloc_free_char_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_char_31_bad	void CWE415_Double_Free__malloc_free_char_31_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         char * dataCopy = data;         char * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_char_31_good	void CWE415_Double_Free__malloc_free_char_31_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_32_bad	void CWE415_Double_Free__malloc_free_char_32_bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = (char *)malloc(100*sizeof(char));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_char_32_good	void CWE415_Double_Free__malloc_free_char_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         char * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         char * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         char * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
1	CWE415_Double_Free__malloc_free_char_34_bad	void CWE415_Double_Free__malloc_free_char_34_bad() {     char * data;     CWE415_Double_Free__malloc_free_char_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     char * data;     CWE415_Double_Free__malloc_free_char_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     char * data;     CWE415_Double_Free__malloc_free_char_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_char_34_good	void CWE415_Double_Free__malloc_free_char_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_char_41_bad	void CWE415_Double_Free__malloc_free_char_41_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_char_41_good	void CWE415_Double_Free__malloc_free_char_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static char * badSource(char * data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	CWE415_Double_Free__malloc_free_char_42_bad	void CWE415_Double_Free__malloc_free_char_42_bad() {     char * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static char * goodG2BSource(char * data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static char * goodB2GSource(char * data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_char_42_good	void CWE415_Double_Free__malloc_free_char_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(char * &data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static void goodG2BSource(char * &data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static void goodB2GSource(char * &data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_char_44_bad	void CWE415_Double_Free__malloc_free_char_44_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_char_44_good	void CWE415_Double_Free__malloc_free_char_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     char * data = CWE415_Double_Free__malloc_free_char_45_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_char_45_bad	void CWE415_Double_Free__malloc_free_char_45_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = CWE415_Double_Free__malloc_free_char_45_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = CWE415_Double_Free__malloc_free_char_45_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_45_goodB2GData = data;     goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_char_45_good	void CWE415_Double_Free__malloc_free_char_45_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_51_bad	void CWE415_Double_Free__malloc_free_char_51_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_51b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_char_51_good	void CWE415_Double_Free__malloc_free_char_51_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_51b_badSink	void CWE415_Double_Free__malloc_free_char_51b_badSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_51b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_51b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_51b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_51b_goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_52_bad	void CWE415_Double_Free__malloc_free_char_52_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_52b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_char_52_good	void CWE415_Double_Free__malloc_free_char_52_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_52b_badSink	void CWE415_Double_Free__malloc_free_char_52b_badSink(char * data) {     CWE415_Double_Free__malloc_free_char_52c_badSink(data); }
0	CWE415_Double_Free__malloc_free_char_52b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_52b_goodG2BSink(char * data) {     CWE415_Double_Free__malloc_free_char_52c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_52b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_52b_goodB2GSink(char * data) {     CWE415_Double_Free__malloc_free_char_52c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_char_52c_badSink	void CWE415_Double_Free__malloc_free_char_52c_badSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_52c_goodG2BSink	void CWE415_Double_Free__malloc_free_char_52c_goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_52c_goodB2GSink	void CWE415_Double_Free__malloc_free_char_52c_goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_53_bad	void CWE415_Double_Free__malloc_free_char_53_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_53b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_char_53_good	void CWE415_Double_Free__malloc_free_char_53_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_53b_badSink	void CWE415_Double_Free__malloc_free_char_53b_badSink(char * data) {     CWE415_Double_Free__malloc_free_char_53c_badSink(data); }
0	CWE415_Double_Free__malloc_free_char_53b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_53b_goodG2BSink(char * data) {     CWE415_Double_Free__malloc_free_char_53c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_53b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_53b_goodB2GSink(char * data) {     CWE415_Double_Free__malloc_free_char_53c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_char_53c_badSink	void CWE415_Double_Free__malloc_free_char_53c_badSink(char * data) {     CWE415_Double_Free__malloc_free_char_53d_badSink(data); }
0	CWE415_Double_Free__malloc_free_char_53c_goodG2BSink	void CWE415_Double_Free__malloc_free_char_53c_goodG2BSink(char * data) {     CWE415_Double_Free__malloc_free_char_53d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_53c_goodB2GSink	void CWE415_Double_Free__malloc_free_char_53c_goodB2GSink(char * data) {     CWE415_Double_Free__malloc_free_char_53d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_char_53d_badSink	void CWE415_Double_Free__malloc_free_char_53d_badSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_53d_goodG2BSink	void CWE415_Double_Free__malloc_free_char_53d_goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_53d_goodB2GSink	void CWE415_Double_Free__malloc_free_char_53d_goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_54_bad	void CWE415_Double_Free__malloc_free_char_54_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_54b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_char_54_good	void CWE415_Double_Free__malloc_free_char_54_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_54b_badSink	void CWE415_Double_Free__malloc_free_char_54b_badSink(char * data) {     CWE415_Double_Free__malloc_free_char_54c_badSink(data); }
0	CWE415_Double_Free__malloc_free_char_54b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_54b_goodG2BSink(char * data) {     CWE415_Double_Free__malloc_free_char_54c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_54b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_54b_goodB2GSink(char * data) {     CWE415_Double_Free__malloc_free_char_54c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_char_54c_badSink	void CWE415_Double_Free__malloc_free_char_54c_badSink(char * data) {     CWE415_Double_Free__malloc_free_char_54d_badSink(data); }
0	CWE415_Double_Free__malloc_free_char_54c_goodG2BSink	void CWE415_Double_Free__malloc_free_char_54c_goodG2BSink(char * data) {     CWE415_Double_Free__malloc_free_char_54d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_54c_goodB2GSink	void CWE415_Double_Free__malloc_free_char_54c_goodB2GSink(char * data) {     CWE415_Double_Free__malloc_free_char_54d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_char_54d_badSink	void CWE415_Double_Free__malloc_free_char_54d_badSink(char * data) {     CWE415_Double_Free__malloc_free_char_54e_badSink(data); }
0	CWE415_Double_Free__malloc_free_char_54d_goodG2BSink	void CWE415_Double_Free__malloc_free_char_54d_goodG2BSink(char * data) {     CWE415_Double_Free__malloc_free_char_54e_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_char_54d_goodB2GSink	void CWE415_Double_Free__malloc_free_char_54d_goodB2GSink(char * data) {     CWE415_Double_Free__malloc_free_char_54e_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_char_54e_badSink	void CWE415_Double_Free__malloc_free_char_54e_badSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_54e_goodG2BSink	void CWE415_Double_Free__malloc_free_char_54e_goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_54e_goodB2GSink	void CWE415_Double_Free__malloc_free_char_54e_goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_61_bad	void CWE415_Double_Free__malloc_free_char_61_bad() {     char * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_char_61b_badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_char_61b_goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_char_61b_goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_char_61_good	void CWE415_Double_Free__malloc_free_char_61_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_61b_badSource	char * CWE415_Double_Free__malloc_free_char_61b_badSource(char * data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	CWE415_Double_Free__malloc_free_char_61b_goodG2BSource	char * CWE415_Double_Free__malloc_free_char_61b_goodG2BSource(char * data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	CWE415_Double_Free__malloc_free_char_61b_goodB2GSource	char * CWE415_Double_Free__malloc_free_char_61b_goodB2GSource(char * data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(char * &data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodG2BSource	void goodG2BSource(char * &data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodB2GSource	void goodB2GSource(char * &data) {     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	CWE415_Double_Free__malloc_free_char_63_bad	void CWE415_Double_Free__malloc_free_char_63_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_63b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_char_63_good	void CWE415_Double_Free__malloc_free_char_63_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_63b_badSink	void CWE415_Double_Free__malloc_free_char_63b_badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_63b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_63b_goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_63b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_63b_goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_64_bad	void CWE415_Double_Free__malloc_free_char_64_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_64b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_char_64_good	void CWE415_Double_Free__malloc_free_char_64_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_64b_badSink	void CWE415_Double_Free__malloc_free_char_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_64b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_64b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_65_bad	void CWE415_Double_Free__malloc_free_char_65_bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = CWE415_Double_Free__malloc_free_char_65b_badSink;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = CWE415_Double_Free__malloc_free_char_65b_goodG2BSink;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = CWE415_Double_Free__malloc_free_char_65b_goodB2GSink;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_char_65_good	void CWE415_Double_Free__malloc_free_char_65_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_65b_badSink	void CWE415_Double_Free__malloc_free_char_65b_badSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_65b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_65b_goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_65b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_65b_goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_66_bad	void CWE415_Double_Free__malloc_free_char_66_bad() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* put data in array */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_char_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_char_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataArray[2] = data;     CWE415_Double_Free__malloc_free_char_66b_goodB2GSink(dataArray); }
0	CWE415_Double_Free__malloc_free_char_66_good	void CWE415_Double_Free__malloc_free_char_66_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_66b_badSink	void CWE415_Double_Free__malloc_free_char_66b_badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_66b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_66b_goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_66b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_66b_goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_67_bad	void CWE415_Double_Free__malloc_free_char_67_bad() {     char * data;     CWE415_Double_Free__malloc_free_char_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_char_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     CWE415_Double_Free__malloc_free_char_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_char_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     CWE415_Double_Free__malloc_free_char_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_char_67b_goodB2GSink(myStruct); }
0	CWE415_Double_Free__malloc_free_char_67_good	void CWE415_Double_Free__malloc_free_char_67_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_67b_badSink	void CWE415_Double_Free__malloc_free_char_67b_badSink(CWE415_Double_Free__malloc_free_char_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_67b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_67b_goodG2BSink(CWE415_Double_Free__malloc_free_char_67_structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_67b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_67b_goodB2GSink(CWE415_Double_Free__malloc_free_char_67_structType myStruct) {     char * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_char_68_bad	void CWE415_Double_Free__malloc_free_char_68_bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_68_badData = data;     CWE415_Double_Free__malloc_free_char_68b_badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_68_goodG2BData = data;     CWE415_Double_Free__malloc_free_char_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_68_goodB2GData = data;     CWE415_Double_Free__malloc_free_char_68b_goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_char_68_good	void CWE415_Double_Free__malloc_free_char_68_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_char_68b_badSink	void CWE415_Double_Free__malloc_free_char_68b_badSink() {     char * data = CWE415_Double_Free__malloc_free_char_68_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_68b_goodG2BSink	void CWE415_Double_Free__malloc_free_char_68b_goodG2BSink() {     char * data = CWE415_Double_Free__malloc_free_char_68_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_68b_goodB2GSink	void CWE415_Double_Free__malloc_free_char_68b_goodB2GSink() {     char * data = CWE415_Double_Free__malloc_free_char_68_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_char_81_bad::action(char * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_char_81_goodB2G::action(char * data) const {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_char_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_char_81_base& baseObject = CWE415_Double_Free__malloc_free_char_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     const CWE415_Double_Free__malloc_free_char_81_base& baseObject = CWE415_Double_Free__malloc_free_char_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_char_81_base& baseObject = CWE415_Double_Free__malloc_free_char_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__malloc_free_char_82_bad::action(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_char_82_goodB2G::action(char * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_char_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_82_base* baseObject = new CWE415_Double_Free__malloc_free_char_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_char_82_base* baseObject = new CWE415_Double_Free__malloc_free_char_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_char_82_base* baseObject = new CWE415_Double_Free__malloc_free_char_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__malloc_free_char_83_bad	CWE415_Double_Free__malloc_free_char_83_bad::CWE415_Double_Free__malloc_free_char_83_bad(char * dataCopy) {     data = dataCopy;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_char_83_bad	CWE415_Double_Free__malloc_free_char_83_bad::~CWE415_Double_Free__malloc_free_char_83_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_83_goodB2G	CWE415_Double_Free__malloc_free_char_83_goodB2G::CWE415_Double_Free__malloc_free_char_83_goodB2G(char * dataCopy) {     data = dataCopy;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_char_83_goodB2G	CWE415_Double_Free__malloc_free_char_83_goodB2G::~CWE415_Double_Free__malloc_free_char_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_char_83_goodG2B	CWE415_Double_Free__malloc_free_char_83_goodG2B::CWE415_Double_Free__malloc_free_char_83_goodG2B(char * dataCopy) {     data = dataCopy;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_char_83_goodG2B	CWE415_Double_Free__malloc_free_char_83_goodG2B::~CWE415_Double_Free__malloc_free_char_83_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_char_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_char_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_char_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__malloc_free_char_84_bad	CWE415_Double_Free__malloc_free_char_84_bad::CWE415_Double_Free__malloc_free_char_84_bad(char * dataCopy) {     data = dataCopy;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_char_84_bad	CWE415_Double_Free__malloc_free_char_84_bad::~CWE415_Double_Free__malloc_free_char_84_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_char_84_goodB2G	CWE415_Double_Free__malloc_free_char_84_goodB2G::CWE415_Double_Free__malloc_free_char_84_goodB2G(char * dataCopy) {     data = dataCopy;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_char_84_goodB2G	CWE415_Double_Free__malloc_free_char_84_goodB2G::~CWE415_Double_Free__malloc_free_char_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_char_84_goodG2B	CWE415_Double_Free__malloc_free_char_84_goodG2B::CWE415_Double_Free__malloc_free_char_84_goodG2B(char * dataCopy) {     data = dataCopy;     data = (char *)malloc(100*sizeof(char));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_char_84_goodG2B	CWE415_Double_Free__malloc_free_char_84_goodG2B::~CWE415_Double_Free__malloc_free_char_84_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_char_84_bad * badObject = new CWE415_Double_Free__malloc_free_char_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_char_84_goodG2B * goodG2BObject = new CWE415_Double_Free__malloc_free_char_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_char_84_goodB2G * goodB2GObject = new CWE415_Double_Free__malloc_free_char_84_goodB2G(data);     delete goodB2GObject; }
1	CWE415_Double_Free__malloc_free_int64_t_01_bad	void CWE415_Double_Free__malloc_free_int64_t_01_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int64_t_01_good	void CWE415_Double_Free__malloc_free_int64_t_01_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_02_bad	void CWE415_Double_Free__malloc_free_int64_t_02_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_02_good	void CWE415_Double_Free__malloc_free_int64_t_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_03_bad	void CWE415_Double_Free__malloc_free_int64_t_03_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_03_good	void CWE415_Double_Free__malloc_free_int64_t_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_04_bad	void CWE415_Double_Free__malloc_free_int64_t_04_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_04_good	void CWE415_Double_Free__malloc_free_int64_t_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_05_bad	void CWE415_Double_Free__malloc_free_int64_t_05_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_05_good	void CWE415_Double_Free__malloc_free_int64_t_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_06_bad	void CWE415_Double_Free__malloc_free_int64_t_06_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_06_good	void CWE415_Double_Free__malloc_free_int64_t_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_07_bad	void CWE415_Double_Free__malloc_free_int64_t_07_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_07_good	void CWE415_Double_Free__malloc_free_int64_t_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_08_bad	void CWE415_Double_Free__malloc_free_int64_t_08_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_08_good	void CWE415_Double_Free__malloc_free_int64_t_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_09_bad	void CWE415_Double_Free__malloc_free_int64_t_09_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_09_good	void CWE415_Double_Free__malloc_free_int64_t_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_10_bad	void CWE415_Double_Free__malloc_free_int64_t_10_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_10_good	void CWE415_Double_Free__malloc_free_int64_t_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_11_bad	void CWE415_Double_Free__malloc_free_int64_t_11_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_11_good	void CWE415_Double_Free__malloc_free_int64_t_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_12_bad	void CWE415_Double_Free__malloc_free_int64_t_12_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_12_good	void CWE415_Double_Free__malloc_free_int64_t_12_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int64_t_13_bad	void CWE415_Double_Free__malloc_free_int64_t_13_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_13_good	void CWE415_Double_Free__malloc_free_int64_t_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_14_bad	void CWE415_Double_Free__malloc_free_int64_t_14_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_14_good	void CWE415_Double_Free__malloc_free_int64_t_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_15_bad	void CWE415_Double_Free__malloc_free_int64_t_15_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE415_Double_Free__malloc_free_int64_t_15_good	void CWE415_Double_Free__malloc_free_int64_t_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int64_t_16_bad	void CWE415_Double_Free__malloc_free_int64_t_16_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	CWE415_Double_Free__malloc_free_int64_t_16_good	void CWE415_Double_Free__malloc_free_int64_t_16_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int64_t_17_bad	void CWE415_Double_Free__malloc_free_int64_t_17_bad() {     int i,j;     int64_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_17_good	void CWE415_Double_Free__malloc_free_int64_t_17_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int64_t_18_bad	void CWE415_Double_Free__malloc_free_int64_t_18_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_18_good	void CWE415_Double_Free__malloc_free_int64_t_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_int64_t_21_bad	void CWE415_Double_Free__malloc_free_int64_t_21_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_21_good	void CWE415_Double_Free__malloc_free_int64_t_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int64_t_22_bad	void CWE415_Double_Free__malloc_free_int64_t_22_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_22_badGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_int64_t_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_22_goodB2G1Global = 0; /* false */     CWE415_Double_Free__malloc_free_int64_t_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_22_goodB2G2Global = 1; /* true */     CWE415_Double_Free__malloc_free_int64_t_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_22_goodG2BGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_int64_t_22_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_22_good	void CWE415_Double_Free__malloc_free_int64_t_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int64_t_22_badSink	void CWE415_Double_Free__malloc_free_int64_t_22_badSink(int64_t * data) {     if(CWE415_Double_Free__malloc_free_int64_t_22_badGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int64_t_22_goodB2G1Sink	void CWE415_Double_Free__malloc_free_int64_t_22_goodB2G1Sink(int64_t * data) {     if(CWE415_Double_Free__malloc_free_int64_t_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int64_t_22_goodB2G2Sink	void CWE415_Double_Free__malloc_free_int64_t_22_goodB2G2Sink(int64_t * data) {     if(CWE415_Double_Free__malloc_free_int64_t_22_goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int64_t_22_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_22_goodG2BSink(int64_t * data) {     if(CWE415_Double_Free__malloc_free_int64_t_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_int64_t_31_bad	void CWE415_Double_Free__malloc_free_int64_t_31_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int64_t_31_good	void CWE415_Double_Free__malloc_free_int64_t_31_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_32_bad	void CWE415_Double_Free__malloc_free_int64_t_32_bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = (int64_t *)malloc(100*sizeof(int64_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int64_t_32_good	void CWE415_Double_Free__malloc_free_int64_t_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int64_t * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
1	CWE415_Double_Free__malloc_free_int64_t_34_bad	void CWE415_Double_Free__malloc_free_int64_t_34_bad() {     int64_t * data;     CWE415_Double_Free__malloc_free_int64_t_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE415_Double_Free__malloc_free_int64_t_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE415_Double_Free__malloc_free_int64_t_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int64_t_34_good	void CWE415_Double_Free__malloc_free_int64_t_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_int64_t_41_bad	void CWE415_Double_Free__malloc_free_int64_t_41_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_41_good	void CWE415_Double_Free__malloc_free_int64_t_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int64_t * badSource(int64_t * data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	CWE415_Double_Free__malloc_free_int64_t_42_bad	void CWE415_Double_Free__malloc_free_int64_t_42_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static int64_t * goodG2BSource(int64_t * data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static int64_t * goodB2GSource(int64_t * data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int64_t_42_good	void CWE415_Double_Free__malloc_free_int64_t_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int64_t * &data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static void goodG2BSource(int64_t * &data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static void goodB2GSource(int64_t * &data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_int64_t_44_bad	void CWE415_Double_Free__malloc_free_int64_t_44_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_int64_t_44_good	void CWE415_Double_Free__malloc_free_int64_t_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int64_t * data = CWE415_Double_Free__malloc_free_int64_t_45_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_int64_t_45_bad	void CWE415_Double_Free__malloc_free_int64_t_45_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = CWE415_Double_Free__malloc_free_int64_t_45_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = CWE415_Double_Free__malloc_free_int64_t_45_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_45_goodB2GData = data;     goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_int64_t_45_good	void CWE415_Double_Free__malloc_free_int64_t_45_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_51_bad	void CWE415_Double_Free__malloc_free_int64_t_51_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_51b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_51_good	void CWE415_Double_Free__malloc_free_int64_t_51_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_51b_badSink	void CWE415_Double_Free__malloc_free_int64_t_51b_badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_51b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_51b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_51b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_51b_goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_52_bad	void CWE415_Double_Free__malloc_free_int64_t_52_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_52b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_52_good	void CWE415_Double_Free__malloc_free_int64_t_52_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_52b_badSink	void CWE415_Double_Free__malloc_free_int64_t_52b_badSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_52c_badSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_52b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_52b_goodG2BSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_52c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_52b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_52b_goodB2GSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_52c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int64_t_52c_badSink	void CWE415_Double_Free__malloc_free_int64_t_52c_badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_52c_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_52c_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_52c_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_52c_goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_53_bad	void CWE415_Double_Free__malloc_free_int64_t_53_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_53b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_53_good	void CWE415_Double_Free__malloc_free_int64_t_53_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_53b_badSink	void CWE415_Double_Free__malloc_free_int64_t_53b_badSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_53c_badSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_53b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_53b_goodG2BSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_53c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_53b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_53b_goodB2GSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_53c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int64_t_53c_badSink	void CWE415_Double_Free__malloc_free_int64_t_53c_badSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_53d_badSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_53c_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_53c_goodG2BSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_53d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_53c_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_53c_goodB2GSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_53d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int64_t_53d_badSink	void CWE415_Double_Free__malloc_free_int64_t_53d_badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_53d_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_53d_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_53d_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_53d_goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_54_bad	void CWE415_Double_Free__malloc_free_int64_t_54_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_54b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54_good	void CWE415_Double_Free__malloc_free_int64_t_54_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_54b_badSink	void CWE415_Double_Free__malloc_free_int64_t_54b_badSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54c_badSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_54b_goodG2BSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_54b_goodB2GSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int64_t_54c_badSink	void CWE415_Double_Free__malloc_free_int64_t_54c_badSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54d_badSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54c_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_54c_goodG2BSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54c_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_54c_goodB2GSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int64_t_54d_badSink	void CWE415_Double_Free__malloc_free_int64_t_54d_badSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54e_badSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54d_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_54d_goodG2BSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54e_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54d_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_54d_goodB2GSink(int64_t * data) {     CWE415_Double_Free__malloc_free_int64_t_54e_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int64_t_54e_badSink	void CWE415_Double_Free__malloc_free_int64_t_54e_badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54e_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_54e_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_54e_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_54e_goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_61_bad	void CWE415_Double_Free__malloc_free_int64_t_61_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_int64_t_61b_badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_int64_t_61b_goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_int64_t_61b_goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int64_t_61_good	void CWE415_Double_Free__malloc_free_int64_t_61_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_61b_badSource	int64_t * CWE415_Double_Free__malloc_free_int64_t_61b_badSource(int64_t * data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	CWE415_Double_Free__malloc_free_int64_t_61b_goodG2BSource	int64_t * CWE415_Double_Free__malloc_free_int64_t_61b_goodG2BSource(int64_t * data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	CWE415_Double_Free__malloc_free_int64_t_61b_goodB2GSource	int64_t * CWE415_Double_Free__malloc_free_int64_t_61b_goodB2GSource(int64_t * data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int64_t * &data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodG2BSource	void goodG2BSource(int64_t * &data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodB2GSource	void goodB2GSource(int64_t * &data) {     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	CWE415_Double_Free__malloc_free_int64_t_63_bad	void CWE415_Double_Free__malloc_free_int64_t_63_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_63b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_int64_t_63_good	void CWE415_Double_Free__malloc_free_int64_t_63_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_63b_badSink	void CWE415_Double_Free__malloc_free_int64_t_63b_badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_63b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_63b_goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_63b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_63b_goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_64_bad	void CWE415_Double_Free__malloc_free_int64_t_64_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_64b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_int64_t_64_good	void CWE415_Double_Free__malloc_free_int64_t_64_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_64b_badSink	void CWE415_Double_Free__malloc_free_int64_t_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_64b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_64b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_65_bad	void CWE415_Double_Free__malloc_free_int64_t_65_bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = CWE415_Double_Free__malloc_free_int64_t_65b_badSink;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE415_Double_Free__malloc_free_int64_t_65b_goodG2BSink;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = CWE415_Double_Free__malloc_free_int64_t_65b_goodB2GSink;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_int64_t_65_good	void CWE415_Double_Free__malloc_free_int64_t_65_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_65b_badSink	void CWE415_Double_Free__malloc_free_int64_t_65b_badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_65b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_65b_goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_65b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_65b_goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_66_bad	void CWE415_Double_Free__malloc_free_int64_t_66_bad() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* put data in array */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_int64_t_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_int64_t_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataArray[2] = data;     CWE415_Double_Free__malloc_free_int64_t_66b_goodB2GSink(dataArray); }
0	CWE415_Double_Free__malloc_free_int64_t_66_good	void CWE415_Double_Free__malloc_free_int64_t_66_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_66b_badSink	void CWE415_Double_Free__malloc_free_int64_t_66b_badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_66b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_66b_goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_66b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_66b_goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_67_bad	void CWE415_Double_Free__malloc_free_int64_t_67_bad() {     int64_t * data;     CWE415_Double_Free__malloc_free_int64_t_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_int64_t_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     CWE415_Double_Free__malloc_free_int64_t_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_int64_t_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     CWE415_Double_Free__malloc_free_int64_t_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_int64_t_67b_goodB2GSink(myStruct); }
0	CWE415_Double_Free__malloc_free_int64_t_67_good	void CWE415_Double_Free__malloc_free_int64_t_67_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_67b_badSink	void CWE415_Double_Free__malloc_free_int64_t_67b_badSink(CWE415_Double_Free__malloc_free_int64_t_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_67b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_67b_goodG2BSink(CWE415_Double_Free__malloc_free_int64_t_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_67b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_67b_goodB2GSink(CWE415_Double_Free__malloc_free_int64_t_67_structType myStruct) {     int64_t * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int64_t_68_bad	void CWE415_Double_Free__malloc_free_int64_t_68_bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_68_badData = data;     CWE415_Double_Free__malloc_free_int64_t_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_68_goodG2BData = data;     CWE415_Double_Free__malloc_free_int64_t_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_68_goodB2GData = data;     CWE415_Double_Free__malloc_free_int64_t_68b_goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_int64_t_68_good	void CWE415_Double_Free__malloc_free_int64_t_68_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int64_t_68b_badSink	void CWE415_Double_Free__malloc_free_int64_t_68b_badSink() {     int64_t * data = CWE415_Double_Free__malloc_free_int64_t_68_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_68b_goodG2BSink	void CWE415_Double_Free__malloc_free_int64_t_68b_goodG2BSink() {     int64_t * data = CWE415_Double_Free__malloc_free_int64_t_68_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_68b_goodB2GSink	void CWE415_Double_Free__malloc_free_int64_t_68b_goodB2GSink() {     int64_t * data = CWE415_Double_Free__malloc_free_int64_t_68_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_int64_t_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_int64_t_81_goodB2G::action(int64_t * data) const {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_int64_t_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_int64_t_81_base& baseObject = CWE415_Double_Free__malloc_free_int64_t_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     const CWE415_Double_Free__malloc_free_int64_t_81_base& baseObject = CWE415_Double_Free__malloc_free_int64_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_int64_t_81_base& baseObject = CWE415_Double_Free__malloc_free_int64_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__malloc_free_int64_t_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_int64_t_82_goodB2G::action(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_int64_t_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_82_base* baseObject = new CWE415_Double_Free__malloc_free_int64_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int64_t_82_base* baseObject = new CWE415_Double_Free__malloc_free_int64_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int64_t_82_base* baseObject = new CWE415_Double_Free__malloc_free_int64_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__malloc_free_int64_t_83_bad	CWE415_Double_Free__malloc_free_int64_t_83_bad::CWE415_Double_Free__malloc_free_int64_t_83_bad(int64_t * dataCopy) {     data = dataCopy;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_int64_t_83_bad	CWE415_Double_Free__malloc_free_int64_t_83_bad::~CWE415_Double_Free__malloc_free_int64_t_83_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_83_goodB2G	CWE415_Double_Free__malloc_free_int64_t_83_goodB2G::CWE415_Double_Free__malloc_free_int64_t_83_goodB2G(int64_t * dataCopy) {     data = dataCopy;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_int64_t_83_goodB2G	CWE415_Double_Free__malloc_free_int64_t_83_goodB2G::~CWE415_Double_Free__malloc_free_int64_t_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int64_t_83_goodG2B	CWE415_Double_Free__malloc_free_int64_t_83_goodG2B::CWE415_Double_Free__malloc_free_int64_t_83_goodG2B(int64_t * dataCopy) {     data = dataCopy;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_int64_t_83_goodG2B	CWE415_Double_Free__malloc_free_int64_t_83_goodG2B::~CWE415_Double_Free__malloc_free_int64_t_83_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int64_t_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int64_t_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int64_t_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__malloc_free_int64_t_84_bad	CWE415_Double_Free__malloc_free_int64_t_84_bad::CWE415_Double_Free__malloc_free_int64_t_84_bad(int64_t * dataCopy) {     data = dataCopy;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_int64_t_84_bad	CWE415_Double_Free__malloc_free_int64_t_84_bad::~CWE415_Double_Free__malloc_free_int64_t_84_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int64_t_84_goodB2G	CWE415_Double_Free__malloc_free_int64_t_84_goodB2G::CWE415_Double_Free__malloc_free_int64_t_84_goodB2G(int64_t * dataCopy) {     data = dataCopy;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_int64_t_84_goodB2G	CWE415_Double_Free__malloc_free_int64_t_84_goodB2G::~CWE415_Double_Free__malloc_free_int64_t_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int64_t_84_goodG2B	CWE415_Double_Free__malloc_free_int64_t_84_goodG2B::CWE415_Double_Free__malloc_free_int64_t_84_goodG2B(int64_t * dataCopy) {     data = dataCopy;     data = (int64_t *)malloc(100*sizeof(int64_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_int64_t_84_goodG2B	CWE415_Double_Free__malloc_free_int64_t_84_goodG2B::~CWE415_Double_Free__malloc_free_int64_t_84_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int64_t_84_bad * badObject = new CWE415_Double_Free__malloc_free_int64_t_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int64_t_84_goodG2B * goodG2BObject = new CWE415_Double_Free__malloc_free_int64_t_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int64_t_84_goodB2G * goodB2GObject = new CWE415_Double_Free__malloc_free_int64_t_84_goodB2G(data);     delete goodB2GObject; }
1	CWE415_Double_Free__malloc_free_int_01_bad	void CWE415_Double_Free__malloc_free_int_01_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int_01_good	void CWE415_Double_Free__malloc_free_int_01_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_02_bad	void CWE415_Double_Free__malloc_free_int_02_bad() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_02_good	void CWE415_Double_Free__malloc_free_int_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_03_bad	void CWE415_Double_Free__malloc_free_int_03_bad() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_03_good	void CWE415_Double_Free__malloc_free_int_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_04_bad	void CWE415_Double_Free__malloc_free_int_04_bad() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_04_good	void CWE415_Double_Free__malloc_free_int_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_05_bad	void CWE415_Double_Free__malloc_free_int_05_bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_05_good	void CWE415_Double_Free__malloc_free_int_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_06_bad	void CWE415_Double_Free__malloc_free_int_06_bad() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_06_good	void CWE415_Double_Free__malloc_free_int_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_07_bad	void CWE415_Double_Free__malloc_free_int_07_bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_07_good	void CWE415_Double_Free__malloc_free_int_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_08_bad	void CWE415_Double_Free__malloc_free_int_08_bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_08_good	void CWE415_Double_Free__malloc_free_int_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_09_bad	void CWE415_Double_Free__malloc_free_int_09_bad() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_09_good	void CWE415_Double_Free__malloc_free_int_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_10_bad	void CWE415_Double_Free__malloc_free_int_10_bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_10_good	void CWE415_Double_Free__malloc_free_int_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_11_bad	void CWE415_Double_Free__malloc_free_int_11_bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_11_good	void CWE415_Double_Free__malloc_free_int_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_12_bad	void CWE415_Double_Free__malloc_free_int_12_bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_12_good	void CWE415_Double_Free__malloc_free_int_12_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int_13_bad	void CWE415_Double_Free__malloc_free_int_13_bad() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_13_good	void CWE415_Double_Free__malloc_free_int_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_14_bad	void CWE415_Double_Free__malloc_free_int_14_bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_14_good	void CWE415_Double_Free__malloc_free_int_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_15_bad	void CWE415_Double_Free__malloc_free_int_15_bad() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE415_Double_Free__malloc_free_int_15_good	void CWE415_Double_Free__malloc_free_int_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_int_16_bad	void CWE415_Double_Free__malloc_free_int_16_bad() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	CWE415_Double_Free__malloc_free_int_16_good	void CWE415_Double_Free__malloc_free_int_16_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int_17_bad	void CWE415_Double_Free__malloc_free_int_17_bad() {     int i,j;     int * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_17_good	void CWE415_Double_Free__malloc_free_int_17_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int_18_bad	void CWE415_Double_Free__malloc_free_int_18_bad() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_18_good	void CWE415_Double_Free__malloc_free_int_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_int_21_bad	void CWE415_Double_Free__malloc_free_int_21_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_21_good	void CWE415_Double_Free__malloc_free_int_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int_22_bad	void CWE415_Double_Free__malloc_free_int_22_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_22_badGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_int_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_22_goodB2G1Global = 0; /* false */     CWE415_Double_Free__malloc_free_int_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_22_goodB2G2Global = 1; /* true */     CWE415_Double_Free__malloc_free_int_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_22_goodG2BGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_int_22_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_22_good	void CWE415_Double_Free__malloc_free_int_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_int_22_badSink	void CWE415_Double_Free__malloc_free_int_22_badSink(int * data) {     if(CWE415_Double_Free__malloc_free_int_22_badGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_int_22_goodB2G1Sink	void CWE415_Double_Free__malloc_free_int_22_goodB2G1Sink(int * data) {     if(CWE415_Double_Free__malloc_free_int_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int_22_goodB2G2Sink	void CWE415_Double_Free__malloc_free_int_22_goodB2G2Sink(int * data) {     if(CWE415_Double_Free__malloc_free_int_22_goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int_22_goodG2BSink	void CWE415_Double_Free__malloc_free_int_22_goodG2BSink(int * data) {     if(CWE415_Double_Free__malloc_free_int_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_int_31_bad	void CWE415_Double_Free__malloc_free_int_31_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int * dataCopy = data;         int * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int_31_good	void CWE415_Double_Free__malloc_free_int_31_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_32_bad	void CWE415_Double_Free__malloc_free_int_32_bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = (int *)malloc(100*sizeof(int));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int_32_good	void CWE415_Double_Free__malloc_free_int_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         int * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         int * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
1	CWE415_Double_Free__malloc_free_int_34_bad	void CWE415_Double_Free__malloc_free_int_34_bad() {     int * data;     CWE415_Double_Free__malloc_free_int_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     int * data;     CWE415_Double_Free__malloc_free_int_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int * data;     CWE415_Double_Free__malloc_free_int_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_int_34_good	void CWE415_Double_Free__malloc_free_int_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_int_41_bad	void CWE415_Double_Free__malloc_free_int_41_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int_41_good	void CWE415_Double_Free__malloc_free_int_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static int * badSource(int * data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	CWE415_Double_Free__malloc_free_int_42_bad	void CWE415_Double_Free__malloc_free_int_42_bad() {     int * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static int * goodG2BSource(int * data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static int * goodB2GSource(int * data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int_42_good	void CWE415_Double_Free__malloc_free_int_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(int * &data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static void goodG2BSource(int * &data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static void goodB2GSource(int * &data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_int_44_bad	void CWE415_Double_Free__malloc_free_int_44_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_int_44_good	void CWE415_Double_Free__malloc_free_int_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     int * data = CWE415_Double_Free__malloc_free_int_45_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_int_45_bad	void CWE415_Double_Free__malloc_free_int_45_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = CWE415_Double_Free__malloc_free_int_45_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = CWE415_Double_Free__malloc_free_int_45_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_45_goodB2GData = data;     goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_int_45_good	void CWE415_Double_Free__malloc_free_int_45_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_51_bad	void CWE415_Double_Free__malloc_free_int_51_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_51b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int_51_good	void CWE415_Double_Free__malloc_free_int_51_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_51b_badSink	void CWE415_Double_Free__malloc_free_int_51b_badSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_51b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_51b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_51b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_51b_goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_52_bad	void CWE415_Double_Free__malloc_free_int_52_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_52b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int_52_good	void CWE415_Double_Free__malloc_free_int_52_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_52b_badSink	void CWE415_Double_Free__malloc_free_int_52b_badSink(int * data) {     CWE415_Double_Free__malloc_free_int_52c_badSink(data); }
0	CWE415_Double_Free__malloc_free_int_52b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_52b_goodG2BSink(int * data) {     CWE415_Double_Free__malloc_free_int_52c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_52b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_52b_goodB2GSink(int * data) {     CWE415_Double_Free__malloc_free_int_52c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int_52c_badSink	void CWE415_Double_Free__malloc_free_int_52c_badSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_52c_goodG2BSink	void CWE415_Double_Free__malloc_free_int_52c_goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_52c_goodB2GSink	void CWE415_Double_Free__malloc_free_int_52c_goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_53_bad	void CWE415_Double_Free__malloc_free_int_53_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_53b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int_53_good	void CWE415_Double_Free__malloc_free_int_53_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_53b_badSink	void CWE415_Double_Free__malloc_free_int_53b_badSink(int * data) {     CWE415_Double_Free__malloc_free_int_53c_badSink(data); }
0	CWE415_Double_Free__malloc_free_int_53b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_53b_goodG2BSink(int * data) {     CWE415_Double_Free__malloc_free_int_53c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_53b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_53b_goodB2GSink(int * data) {     CWE415_Double_Free__malloc_free_int_53c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int_53c_badSink	void CWE415_Double_Free__malloc_free_int_53c_badSink(int * data) {     CWE415_Double_Free__malloc_free_int_53d_badSink(data); }
0	CWE415_Double_Free__malloc_free_int_53c_goodG2BSink	void CWE415_Double_Free__malloc_free_int_53c_goodG2BSink(int * data) {     CWE415_Double_Free__malloc_free_int_53d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_53c_goodB2GSink	void CWE415_Double_Free__malloc_free_int_53c_goodB2GSink(int * data) {     CWE415_Double_Free__malloc_free_int_53d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int_53d_badSink	void CWE415_Double_Free__malloc_free_int_53d_badSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_53d_goodG2BSink	void CWE415_Double_Free__malloc_free_int_53d_goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_53d_goodB2GSink	void CWE415_Double_Free__malloc_free_int_53d_goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_54_bad	void CWE415_Double_Free__malloc_free_int_54_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_54b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_int_54_good	void CWE415_Double_Free__malloc_free_int_54_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_54b_badSink	void CWE415_Double_Free__malloc_free_int_54b_badSink(int * data) {     CWE415_Double_Free__malloc_free_int_54c_badSink(data); }
0	CWE415_Double_Free__malloc_free_int_54b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_54b_goodG2BSink(int * data) {     CWE415_Double_Free__malloc_free_int_54c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_54b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_54b_goodB2GSink(int * data) {     CWE415_Double_Free__malloc_free_int_54c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int_54c_badSink	void CWE415_Double_Free__malloc_free_int_54c_badSink(int * data) {     CWE415_Double_Free__malloc_free_int_54d_badSink(data); }
0	CWE415_Double_Free__malloc_free_int_54c_goodG2BSink	void CWE415_Double_Free__malloc_free_int_54c_goodG2BSink(int * data) {     CWE415_Double_Free__malloc_free_int_54d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_54c_goodB2GSink	void CWE415_Double_Free__malloc_free_int_54c_goodB2GSink(int * data) {     CWE415_Double_Free__malloc_free_int_54d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int_54d_badSink	void CWE415_Double_Free__malloc_free_int_54d_badSink(int * data) {     CWE415_Double_Free__malloc_free_int_54e_badSink(data); }
0	CWE415_Double_Free__malloc_free_int_54d_goodG2BSink	void CWE415_Double_Free__malloc_free_int_54d_goodG2BSink(int * data) {     CWE415_Double_Free__malloc_free_int_54e_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_int_54d_goodB2GSink	void CWE415_Double_Free__malloc_free_int_54d_goodB2GSink(int * data) {     CWE415_Double_Free__malloc_free_int_54e_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_int_54e_badSink	void CWE415_Double_Free__malloc_free_int_54e_badSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_54e_goodG2BSink	void CWE415_Double_Free__malloc_free_int_54e_goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_54e_goodB2GSink	void CWE415_Double_Free__malloc_free_int_54e_goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_61_bad	void CWE415_Double_Free__malloc_free_int_61_bad() {     int * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_int_61b_badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_int_61b_goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_int_61b_goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int_61_good	void CWE415_Double_Free__malloc_free_int_61_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_61b_badSource	int * CWE415_Double_Free__malloc_free_int_61b_badSource(int * data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	CWE415_Double_Free__malloc_free_int_61b_goodG2BSource	int * CWE415_Double_Free__malloc_free_int_61b_goodG2BSource(int * data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	CWE415_Double_Free__malloc_free_int_61b_goodB2GSource	int * CWE415_Double_Free__malloc_free_int_61b_goodB2GSource(int * data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int * &data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodG2BSource	void goodG2BSource(int * &data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodB2GSource	void goodB2GSource(int * &data) {     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	CWE415_Double_Free__malloc_free_int_63_bad	void CWE415_Double_Free__malloc_free_int_63_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_63b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_int_63_good	void CWE415_Double_Free__malloc_free_int_63_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_63b_badSink	void CWE415_Double_Free__malloc_free_int_63b_badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_63b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_63b_goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_63b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_63b_goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_64_bad	void CWE415_Double_Free__malloc_free_int_64_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_64b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_int_64_good	void CWE415_Double_Free__malloc_free_int_64_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_64b_badSink	void CWE415_Double_Free__malloc_free_int_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_64b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_64b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_65_bad	void CWE415_Double_Free__malloc_free_int_65_bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = CWE415_Double_Free__malloc_free_int_65b_badSink;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = CWE415_Double_Free__malloc_free_int_65b_goodG2BSink;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = CWE415_Double_Free__malloc_free_int_65b_goodB2GSink;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_int_65_good	void CWE415_Double_Free__malloc_free_int_65_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_65b_badSink	void CWE415_Double_Free__malloc_free_int_65b_badSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_65b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_65b_goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_65b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_65b_goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_66_bad	void CWE415_Double_Free__malloc_free_int_66_bad() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* put data in array */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_int_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_int_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataArray[2] = data;     CWE415_Double_Free__malloc_free_int_66b_goodB2GSink(dataArray); }
0	CWE415_Double_Free__malloc_free_int_66_good	void CWE415_Double_Free__malloc_free_int_66_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_66b_badSink	void CWE415_Double_Free__malloc_free_int_66b_badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_66b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_66b_goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_66b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_66b_goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_67_bad	void CWE415_Double_Free__malloc_free_int_67_bad() {     int * data;     CWE415_Double_Free__malloc_free_int_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_int_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     CWE415_Double_Free__malloc_free_int_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_int_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     CWE415_Double_Free__malloc_free_int_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_int_67b_goodB2GSink(myStruct); }
0	CWE415_Double_Free__malloc_free_int_67_good	void CWE415_Double_Free__malloc_free_int_67_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_67b_badSink	void CWE415_Double_Free__malloc_free_int_67b_badSink(CWE415_Double_Free__malloc_free_int_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_67b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_67b_goodG2BSink(CWE415_Double_Free__malloc_free_int_67_structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_67b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_67b_goodB2GSink(CWE415_Double_Free__malloc_free_int_67_structType myStruct) {     int * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_int_68_bad	void CWE415_Double_Free__malloc_free_int_68_bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_68_badData = data;     CWE415_Double_Free__malloc_free_int_68b_badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_68_goodG2BData = data;     CWE415_Double_Free__malloc_free_int_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_68_goodB2GData = data;     CWE415_Double_Free__malloc_free_int_68b_goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_int_68_good	void CWE415_Double_Free__malloc_free_int_68_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_int_68b_badSink	void CWE415_Double_Free__malloc_free_int_68b_badSink() {     int * data = CWE415_Double_Free__malloc_free_int_68_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_68b_goodG2BSink	void CWE415_Double_Free__malloc_free_int_68b_goodG2BSink() {     int * data = CWE415_Double_Free__malloc_free_int_68_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_68b_goodB2GSink	void CWE415_Double_Free__malloc_free_int_68b_goodB2GSink() {     int * data = CWE415_Double_Free__malloc_free_int_68_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_int_81_bad::action(int * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_int_81_goodB2G::action(int * data) const {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_int_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_int_81_base& baseObject = CWE415_Double_Free__malloc_free_int_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     const CWE415_Double_Free__malloc_free_int_81_base& baseObject = CWE415_Double_Free__malloc_free_int_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_int_81_base& baseObject = CWE415_Double_Free__malloc_free_int_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__malloc_free_int_82_bad::action(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_int_82_goodB2G::action(int * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_int_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_82_base* baseObject = new CWE415_Double_Free__malloc_free_int_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_int_82_base* baseObject = new CWE415_Double_Free__malloc_free_int_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_int_82_base* baseObject = new CWE415_Double_Free__malloc_free_int_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__malloc_free_int_83_bad	CWE415_Double_Free__malloc_free_int_83_bad::CWE415_Double_Free__malloc_free_int_83_bad(int * dataCopy) {     data = dataCopy;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_int_83_bad	CWE415_Double_Free__malloc_free_int_83_bad::~CWE415_Double_Free__malloc_free_int_83_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_83_goodB2G	CWE415_Double_Free__malloc_free_int_83_goodB2G::CWE415_Double_Free__malloc_free_int_83_goodB2G(int * dataCopy) {     data = dataCopy;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_int_83_goodB2G	CWE415_Double_Free__malloc_free_int_83_goodB2G::~CWE415_Double_Free__malloc_free_int_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int_83_goodG2B	CWE415_Double_Free__malloc_free_int_83_goodG2B::CWE415_Double_Free__malloc_free_int_83_goodG2B(int * dataCopy) {     data = dataCopy;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_int_83_goodG2B	CWE415_Double_Free__malloc_free_int_83_goodG2B::~CWE415_Double_Free__malloc_free_int_83_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__malloc_free_int_84_bad	CWE415_Double_Free__malloc_free_int_84_bad::CWE415_Double_Free__malloc_free_int_84_bad(int * dataCopy) {     data = dataCopy;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_int_84_bad	CWE415_Double_Free__malloc_free_int_84_bad::~CWE415_Double_Free__malloc_free_int_84_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_int_84_goodB2G	CWE415_Double_Free__malloc_free_int_84_goodB2G::CWE415_Double_Free__malloc_free_int_84_goodB2G(int * dataCopy) {     data = dataCopy;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_int_84_goodB2G	CWE415_Double_Free__malloc_free_int_84_goodB2G::~CWE415_Double_Free__malloc_free_int_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_int_84_goodG2B	CWE415_Double_Free__malloc_free_int_84_goodG2B::CWE415_Double_Free__malloc_free_int_84_goodG2B(int * dataCopy) {     data = dataCopy;     data = (int *)malloc(100*sizeof(int));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_int_84_goodG2B	CWE415_Double_Free__malloc_free_int_84_goodG2B::~CWE415_Double_Free__malloc_free_int_84_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int_84_bad * badObject = new CWE415_Double_Free__malloc_free_int_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int_84_goodG2B * goodG2BObject = new CWE415_Double_Free__malloc_free_int_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_int_84_goodB2G * goodB2GObject = new CWE415_Double_Free__malloc_free_int_84_goodB2G(data);     delete goodB2GObject; }
1	CWE415_Double_Free__malloc_free_long_01_bad	void CWE415_Double_Free__malloc_free_long_01_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_long_01_good	void CWE415_Double_Free__malloc_free_long_01_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_02_bad	void CWE415_Double_Free__malloc_free_long_02_bad() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_02_good	void CWE415_Double_Free__malloc_free_long_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_03_bad	void CWE415_Double_Free__malloc_free_long_03_bad() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_03_good	void CWE415_Double_Free__malloc_free_long_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_04_bad	void CWE415_Double_Free__malloc_free_long_04_bad() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_04_good	void CWE415_Double_Free__malloc_free_long_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_05_bad	void CWE415_Double_Free__malloc_free_long_05_bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_05_good	void CWE415_Double_Free__malloc_free_long_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_06_bad	void CWE415_Double_Free__malloc_free_long_06_bad() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_06_good	void CWE415_Double_Free__malloc_free_long_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_07_bad	void CWE415_Double_Free__malloc_free_long_07_bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_07_good	void CWE415_Double_Free__malloc_free_long_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_08_bad	void CWE415_Double_Free__malloc_free_long_08_bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_08_good	void CWE415_Double_Free__malloc_free_long_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_09_bad	void CWE415_Double_Free__malloc_free_long_09_bad() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_09_good	void CWE415_Double_Free__malloc_free_long_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_10_bad	void CWE415_Double_Free__malloc_free_long_10_bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_10_good	void CWE415_Double_Free__malloc_free_long_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_11_bad	void CWE415_Double_Free__malloc_free_long_11_bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_11_good	void CWE415_Double_Free__malloc_free_long_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_12_bad	void CWE415_Double_Free__malloc_free_long_12_bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_12_good	void CWE415_Double_Free__malloc_free_long_12_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_long_13_bad	void CWE415_Double_Free__malloc_free_long_13_bad() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_13_good	void CWE415_Double_Free__malloc_free_long_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_14_bad	void CWE415_Double_Free__malloc_free_long_14_bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_14_good	void CWE415_Double_Free__malloc_free_long_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_15_bad	void CWE415_Double_Free__malloc_free_long_15_bad() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE415_Double_Free__malloc_free_long_15_good	void CWE415_Double_Free__malloc_free_long_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_long_16_bad	void CWE415_Double_Free__malloc_free_long_16_bad() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	CWE415_Double_Free__malloc_free_long_16_good	void CWE415_Double_Free__malloc_free_long_16_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_long_17_bad	void CWE415_Double_Free__malloc_free_long_17_bad() {     int i,j;     long * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int i,k;     long * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     long * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_17_good	void CWE415_Double_Free__malloc_free_long_17_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_long_18_bad	void CWE415_Double_Free__malloc_free_long_18_bad() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_18_good	void CWE415_Double_Free__malloc_free_long_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(long * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_long_21_bad	void CWE415_Double_Free__malloc_free_long_21_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(long * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(long * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_21_good	void CWE415_Double_Free__malloc_free_long_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_long_22_bad	void CWE415_Double_Free__malloc_free_long_22_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_22_badGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_long_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_22_goodB2G1Global = 0; /* false */     CWE415_Double_Free__malloc_free_long_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_22_goodB2G2Global = 1; /* true */     CWE415_Double_Free__malloc_free_long_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_22_goodG2BGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_long_22_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_22_good	void CWE415_Double_Free__malloc_free_long_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_long_22_badSink	void CWE415_Double_Free__malloc_free_long_22_badSink(long * data) {     if(CWE415_Double_Free__malloc_free_long_22_badGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_long_22_goodB2G1Sink	void CWE415_Double_Free__malloc_free_long_22_goodB2G1Sink(long * data) {     if(CWE415_Double_Free__malloc_free_long_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_long_22_goodB2G2Sink	void CWE415_Double_Free__malloc_free_long_22_goodB2G2Sink(long * data) {     if(CWE415_Double_Free__malloc_free_long_22_goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_long_22_goodG2BSink	void CWE415_Double_Free__malloc_free_long_22_goodG2BSink(long * data) {     if(CWE415_Double_Free__malloc_free_long_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_long_31_bad	void CWE415_Double_Free__malloc_free_long_31_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         long * dataCopy = data;         long * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         long * dataCopy = data;         long * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         long * dataCopy = data;         long * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_long_31_good	void CWE415_Double_Free__malloc_free_long_31_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_32_bad	void CWE415_Double_Free__malloc_free_long_32_bad() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = (long *)malloc(100*sizeof(long));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_long_32_good	void CWE415_Double_Free__malloc_free_long_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         long * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         long * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         long * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
1	CWE415_Double_Free__malloc_free_long_34_bad	void CWE415_Double_Free__malloc_free_long_34_bad() {     long * data;     CWE415_Double_Free__malloc_free_long_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     long * data;     CWE415_Double_Free__malloc_free_long_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     long * data;     CWE415_Double_Free__malloc_free_long_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_long_34_good	void CWE415_Double_Free__malloc_free_long_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_long_41_bad	void CWE415_Double_Free__malloc_free_long_41_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_long_41_good	void CWE415_Double_Free__malloc_free_long_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static long * badSource(long * data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	CWE415_Double_Free__malloc_free_long_42_bad	void CWE415_Double_Free__malloc_free_long_42_bad() {     long * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static long * goodG2BSource(long * data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static long * goodB2GSource(long * data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_long_42_good	void CWE415_Double_Free__malloc_free_long_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(long * &data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static void goodG2BSource(long * &data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static void goodB2GSource(long * &data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_long_44_bad	void CWE415_Double_Free__malloc_free_long_44_bad() {     long * data;     /* define a function pointer */     void (*funcPtr) (long *) = badSink;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     long * data;     void (*funcPtr) (long *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     void (*funcPtr) (long *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_long_44_good	void CWE415_Double_Free__malloc_free_long_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     long * data = CWE415_Double_Free__malloc_free_long_45_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_long_45_bad	void CWE415_Double_Free__malloc_free_long_45_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     long * data = CWE415_Double_Free__malloc_free_long_45_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     long * data = CWE415_Double_Free__malloc_free_long_45_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_45_goodB2GData = data;     goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_long_45_good	void CWE415_Double_Free__malloc_free_long_45_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_51_bad	void CWE415_Double_Free__malloc_free_long_51_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_51b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_long_51_good	void CWE415_Double_Free__malloc_free_long_51_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_51b_badSink	void CWE415_Double_Free__malloc_free_long_51b_badSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_51b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_51b_goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_51b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_51b_goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_52_bad	void CWE415_Double_Free__malloc_free_long_52_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_52b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_long_52_good	void CWE415_Double_Free__malloc_free_long_52_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_52b_badSink	void CWE415_Double_Free__malloc_free_long_52b_badSink(long * data) {     CWE415_Double_Free__malloc_free_long_52c_badSink(data); }
0	CWE415_Double_Free__malloc_free_long_52b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_52b_goodG2BSink(long * data) {     CWE415_Double_Free__malloc_free_long_52c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_52b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_52b_goodB2GSink(long * data) {     CWE415_Double_Free__malloc_free_long_52c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_long_52c_badSink	void CWE415_Double_Free__malloc_free_long_52c_badSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_52c_goodG2BSink	void CWE415_Double_Free__malloc_free_long_52c_goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_52c_goodB2GSink	void CWE415_Double_Free__malloc_free_long_52c_goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_53_bad	void CWE415_Double_Free__malloc_free_long_53_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_53b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_long_53_good	void CWE415_Double_Free__malloc_free_long_53_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_53b_badSink	void CWE415_Double_Free__malloc_free_long_53b_badSink(long * data) {     CWE415_Double_Free__malloc_free_long_53c_badSink(data); }
0	CWE415_Double_Free__malloc_free_long_53b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_53b_goodG2BSink(long * data) {     CWE415_Double_Free__malloc_free_long_53c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_53b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_53b_goodB2GSink(long * data) {     CWE415_Double_Free__malloc_free_long_53c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_long_53c_badSink	void CWE415_Double_Free__malloc_free_long_53c_badSink(long * data) {     CWE415_Double_Free__malloc_free_long_53d_badSink(data); }
0	CWE415_Double_Free__malloc_free_long_53c_goodG2BSink	void CWE415_Double_Free__malloc_free_long_53c_goodG2BSink(long * data) {     CWE415_Double_Free__malloc_free_long_53d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_53c_goodB2GSink	void CWE415_Double_Free__malloc_free_long_53c_goodB2GSink(long * data) {     CWE415_Double_Free__malloc_free_long_53d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_long_53d_badSink	void CWE415_Double_Free__malloc_free_long_53d_badSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_53d_goodG2BSink	void CWE415_Double_Free__malloc_free_long_53d_goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_53d_goodB2GSink	void CWE415_Double_Free__malloc_free_long_53d_goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_54_bad	void CWE415_Double_Free__malloc_free_long_54_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_54b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_long_54_good	void CWE415_Double_Free__malloc_free_long_54_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_54b_badSink	void CWE415_Double_Free__malloc_free_long_54b_badSink(long * data) {     CWE415_Double_Free__malloc_free_long_54c_badSink(data); }
0	CWE415_Double_Free__malloc_free_long_54b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_54b_goodG2BSink(long * data) {     CWE415_Double_Free__malloc_free_long_54c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_54b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_54b_goodB2GSink(long * data) {     CWE415_Double_Free__malloc_free_long_54c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_long_54c_badSink	void CWE415_Double_Free__malloc_free_long_54c_badSink(long * data) {     CWE415_Double_Free__malloc_free_long_54d_badSink(data); }
0	CWE415_Double_Free__malloc_free_long_54c_goodG2BSink	void CWE415_Double_Free__malloc_free_long_54c_goodG2BSink(long * data) {     CWE415_Double_Free__malloc_free_long_54d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_54c_goodB2GSink	void CWE415_Double_Free__malloc_free_long_54c_goodB2GSink(long * data) {     CWE415_Double_Free__malloc_free_long_54d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_long_54d_badSink	void CWE415_Double_Free__malloc_free_long_54d_badSink(long * data) {     CWE415_Double_Free__malloc_free_long_54e_badSink(data); }
0	CWE415_Double_Free__malloc_free_long_54d_goodG2BSink	void CWE415_Double_Free__malloc_free_long_54d_goodG2BSink(long * data) {     CWE415_Double_Free__malloc_free_long_54e_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_long_54d_goodB2GSink	void CWE415_Double_Free__malloc_free_long_54d_goodB2GSink(long * data) {     CWE415_Double_Free__malloc_free_long_54e_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_long_54e_badSink	void CWE415_Double_Free__malloc_free_long_54e_badSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_54e_goodG2BSink	void CWE415_Double_Free__malloc_free_long_54e_goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_54e_goodB2GSink	void CWE415_Double_Free__malloc_free_long_54e_goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_61_bad	void CWE415_Double_Free__malloc_free_long_61_bad() {     long * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_long_61b_badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_long_61b_goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_long_61b_goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_long_61_good	void CWE415_Double_Free__malloc_free_long_61_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_61b_badSource	long * CWE415_Double_Free__malloc_free_long_61b_badSource(long * data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	CWE415_Double_Free__malloc_free_long_61b_goodG2BSource	long * CWE415_Double_Free__malloc_free_long_61b_goodG2BSource(long * data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	CWE415_Double_Free__malloc_free_long_61b_goodB2GSource	long * CWE415_Double_Free__malloc_free_long_61b_goodB2GSource(long * data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(long * &data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodG2BSource	void goodG2BSource(long * &data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodB2GSource	void goodB2GSource(long * &data) {     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	CWE415_Double_Free__malloc_free_long_63_bad	void CWE415_Double_Free__malloc_free_long_63_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_63b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_long_63_good	void CWE415_Double_Free__malloc_free_long_63_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_63b_badSink	void CWE415_Double_Free__malloc_free_long_63b_badSink(long * * dataPtr) {     long * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_63b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_63b_goodG2BSink(long * * dataPtr) {     long * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_63b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_63b_goodB2GSink(long * * dataPtr) {     long * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_64_bad	void CWE415_Double_Free__malloc_free_long_64_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_64b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_long_64_good	void CWE415_Double_Free__malloc_free_long_64_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_64b_badSink	void CWE415_Double_Free__malloc_free_long_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_64b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_64b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_65_bad	void CWE415_Double_Free__malloc_free_long_65_bad() {     long * data;     /* define a function pointer */     void (*funcPtr) (long *) = CWE415_Double_Free__malloc_free_long_65b_badSink;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     long * data;     void (*funcPtr) (long *) = CWE415_Double_Free__malloc_free_long_65b_goodG2BSink;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     long * data;     void (*funcPtr) (long *) = CWE415_Double_Free__malloc_free_long_65b_goodB2GSink;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_long_65_good	void CWE415_Double_Free__malloc_free_long_65_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_65b_badSink	void CWE415_Double_Free__malloc_free_long_65b_badSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_65b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_65b_goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_65b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_65b_goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_66_bad	void CWE415_Double_Free__malloc_free_long_66_bad() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* put data in array */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_long_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_long_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataArray[2] = data;     CWE415_Double_Free__malloc_free_long_66b_goodB2GSink(dataArray); }
0	CWE415_Double_Free__malloc_free_long_66_good	void CWE415_Double_Free__malloc_free_long_66_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_66b_badSink	void CWE415_Double_Free__malloc_free_long_66b_badSink(long * dataArray[]) {     /* copy data out of dataArray */     long * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_66b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_66b_goodG2BSink(long * dataArray[]) {     long * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_66b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_66b_goodB2GSink(long * dataArray[]) {     long * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_67_bad	void CWE415_Double_Free__malloc_free_long_67_bad() {     long * data;     CWE415_Double_Free__malloc_free_long_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_long_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     long * data;     CWE415_Double_Free__malloc_free_long_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_long_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     long * data;     CWE415_Double_Free__malloc_free_long_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_long_67b_goodB2GSink(myStruct); }
0	CWE415_Double_Free__malloc_free_long_67_good	void CWE415_Double_Free__malloc_free_long_67_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_67b_badSink	void CWE415_Double_Free__malloc_free_long_67b_badSink(CWE415_Double_Free__malloc_free_long_67_structType myStruct) {     long * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_67b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_67b_goodG2BSink(CWE415_Double_Free__malloc_free_long_67_structType myStruct) {     long * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_67b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_67b_goodB2GSink(CWE415_Double_Free__malloc_free_long_67_structType myStruct) {     long * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_long_68_bad	void CWE415_Double_Free__malloc_free_long_68_bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_68_badData = data;     CWE415_Double_Free__malloc_free_long_68b_badSink(); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_68_goodG2BData = data;     CWE415_Double_Free__malloc_free_long_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_68_goodB2GData = data;     CWE415_Double_Free__malloc_free_long_68b_goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_long_68_good	void CWE415_Double_Free__malloc_free_long_68_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_long_68b_badSink	void CWE415_Double_Free__malloc_free_long_68b_badSink() {     long * data = CWE415_Double_Free__malloc_free_long_68_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_68b_goodG2BSink	void CWE415_Double_Free__malloc_free_long_68b_goodG2BSink() {     long * data = CWE415_Double_Free__malloc_free_long_68_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_68b_goodB2GSink	void CWE415_Double_Free__malloc_free_long_68b_goodB2GSink() {     long * data = CWE415_Double_Free__malloc_free_long_68_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<long *> dataVector) {     /* copy data out of dataVector */     long * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(vector<long *> dataVector) {     long * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(vector<long *> dataVector) {     long * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<long *> dataList) {     /* copy data out of dataList */     long * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(list<long *> dataList) {     long * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(list<long *> dataList) {     long * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, long *> dataMap) {     /* copy data out of dataMap */     long * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(map<int, long *> dataMap) {     long * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(map<int, long *> dataMap) {     long * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_long_81_bad::action(long * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_long_81_goodB2G::action(long * data) const {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_long_81_goodG2B::action(long * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_long_81_base& baseObject = CWE415_Double_Free__malloc_free_long_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     const CWE415_Double_Free__malloc_free_long_81_base& baseObject = CWE415_Double_Free__malloc_free_long_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_long_81_base& baseObject = CWE415_Double_Free__malloc_free_long_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__malloc_free_long_82_bad::action(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_long_82_goodB2G::action(long * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_long_82_goodG2B::action(long * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_82_base* baseObject = new CWE415_Double_Free__malloc_free_long_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_long_82_base* baseObject = new CWE415_Double_Free__malloc_free_long_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_long_82_base* baseObject = new CWE415_Double_Free__malloc_free_long_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__malloc_free_long_83_bad	CWE415_Double_Free__malloc_free_long_83_bad::CWE415_Double_Free__malloc_free_long_83_bad(long * dataCopy) {     data = dataCopy;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_long_83_bad	CWE415_Double_Free__malloc_free_long_83_bad::~CWE415_Double_Free__malloc_free_long_83_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_83_goodB2G	CWE415_Double_Free__malloc_free_long_83_goodB2G::CWE415_Double_Free__malloc_free_long_83_goodB2G(long * dataCopy) {     data = dataCopy;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_long_83_goodB2G	CWE415_Double_Free__malloc_free_long_83_goodB2G::~CWE415_Double_Free__malloc_free_long_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_long_83_goodG2B	CWE415_Double_Free__malloc_free_long_83_goodG2B::CWE415_Double_Free__malloc_free_long_83_goodG2B(long * dataCopy) {     data = dataCopy;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_long_83_goodG2B	CWE415_Double_Free__malloc_free_long_83_goodG2B::~CWE415_Double_Free__malloc_free_long_83_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_long_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_long_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_long_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__malloc_free_long_84_bad	CWE415_Double_Free__malloc_free_long_84_bad::CWE415_Double_Free__malloc_free_long_84_bad(long * dataCopy) {     data = dataCopy;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_long_84_bad	CWE415_Double_Free__malloc_free_long_84_bad::~CWE415_Double_Free__malloc_free_long_84_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_long_84_goodB2G	CWE415_Double_Free__malloc_free_long_84_goodB2G::CWE415_Double_Free__malloc_free_long_84_goodB2G(long * dataCopy) {     data = dataCopy;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_long_84_goodB2G	CWE415_Double_Free__malloc_free_long_84_goodB2G::~CWE415_Double_Free__malloc_free_long_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_long_84_goodG2B	CWE415_Double_Free__malloc_free_long_84_goodG2B::CWE415_Double_Free__malloc_free_long_84_goodG2B(long * dataCopy) {     data = dataCopy;     data = (long *)malloc(100*sizeof(long));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_long_84_goodG2B	CWE415_Double_Free__malloc_free_long_84_goodG2B::~CWE415_Double_Free__malloc_free_long_84_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_long_84_bad * badObject = new CWE415_Double_Free__malloc_free_long_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_long_84_goodG2B * goodG2BObject = new CWE415_Double_Free__malloc_free_long_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_long_84_goodB2G * goodB2GObject = new CWE415_Double_Free__malloc_free_long_84_goodB2G(data);     delete goodB2GObject; }
1	CWE415_Double_Free__malloc_free_struct_01_bad	void CWE415_Double_Free__malloc_free_struct_01_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_struct_01_good	void CWE415_Double_Free__malloc_free_struct_01_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_02_bad	void CWE415_Double_Free__malloc_free_struct_02_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_02_good	void CWE415_Double_Free__malloc_free_struct_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_03_bad	void CWE415_Double_Free__malloc_free_struct_03_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_03_good	void CWE415_Double_Free__malloc_free_struct_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_04_bad	void CWE415_Double_Free__malloc_free_struct_04_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_04_good	void CWE415_Double_Free__malloc_free_struct_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_05_bad	void CWE415_Double_Free__malloc_free_struct_05_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_05_good	void CWE415_Double_Free__malloc_free_struct_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_06_bad	void CWE415_Double_Free__malloc_free_struct_06_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_06_good	void CWE415_Double_Free__malloc_free_struct_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_07_bad	void CWE415_Double_Free__malloc_free_struct_07_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_07_good	void CWE415_Double_Free__malloc_free_struct_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_08_bad	void CWE415_Double_Free__malloc_free_struct_08_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_08_good	void CWE415_Double_Free__malloc_free_struct_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_09_bad	void CWE415_Double_Free__malloc_free_struct_09_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_09_good	void CWE415_Double_Free__malloc_free_struct_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_10_bad	void CWE415_Double_Free__malloc_free_struct_10_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_10_good	void CWE415_Double_Free__malloc_free_struct_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_11_bad	void CWE415_Double_Free__malloc_free_struct_11_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_11_good	void CWE415_Double_Free__malloc_free_struct_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_12_bad	void CWE415_Double_Free__malloc_free_struct_12_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_12_good	void CWE415_Double_Free__malloc_free_struct_12_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_struct_13_bad	void CWE415_Double_Free__malloc_free_struct_13_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_13_good	void CWE415_Double_Free__malloc_free_struct_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_14_bad	void CWE415_Double_Free__malloc_free_struct_14_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_14_good	void CWE415_Double_Free__malloc_free_struct_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_15_bad	void CWE415_Double_Free__malloc_free_struct_15_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE415_Double_Free__malloc_free_struct_15_good	void CWE415_Double_Free__malloc_free_struct_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_struct_16_bad	void CWE415_Double_Free__malloc_free_struct_16_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	CWE415_Double_Free__malloc_free_struct_16_good	void CWE415_Double_Free__malloc_free_struct_16_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_struct_17_bad	void CWE415_Double_Free__malloc_free_struct_17_bad() {     int i,j;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_17_good	void CWE415_Double_Free__malloc_free_struct_17_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_struct_18_bad	void CWE415_Double_Free__malloc_free_struct_18_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_18_good	void CWE415_Double_Free__malloc_free_struct_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_struct_21_bad	void CWE415_Double_Free__malloc_free_struct_21_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_21_good	void CWE415_Double_Free__malloc_free_struct_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_struct_22_bad	void CWE415_Double_Free__malloc_free_struct_22_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_22_badGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_struct_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_22_goodB2G1Global = 0; /* false */     CWE415_Double_Free__malloc_free_struct_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_22_goodB2G2Global = 1; /* true */     CWE415_Double_Free__malloc_free_struct_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_22_goodG2BGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_struct_22_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_22_good	void CWE415_Double_Free__malloc_free_struct_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_struct_22_badSink	void CWE415_Double_Free__malloc_free_struct_22_badSink(twoIntsStruct * data) {     if(CWE415_Double_Free__malloc_free_struct_22_badGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_struct_22_goodB2G1Sink	void CWE415_Double_Free__malloc_free_struct_22_goodB2G1Sink(twoIntsStruct * data) {     if(CWE415_Double_Free__malloc_free_struct_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_struct_22_goodB2G2Sink	void CWE415_Double_Free__malloc_free_struct_22_goodB2G2Sink(twoIntsStruct * data) {     if(CWE415_Double_Free__malloc_free_struct_22_goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_struct_22_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_22_goodG2BSink(twoIntsStruct * data) {     if(CWE415_Double_Free__malloc_free_struct_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_struct_31_bad	void CWE415_Double_Free__malloc_free_struct_31_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_struct_31_good	void CWE415_Double_Free__malloc_free_struct_31_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_32_bad	void CWE415_Double_Free__malloc_free_struct_32_bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_struct_32_good	void CWE415_Double_Free__malloc_free_struct_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         twoIntsStruct * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
1	CWE415_Double_Free__malloc_free_struct_34_bad	void CWE415_Double_Free__malloc_free_struct_34_bad() {     twoIntsStruct * data;     CWE415_Double_Free__malloc_free_struct_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE415_Double_Free__malloc_free_struct_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE415_Double_Free__malloc_free_struct_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_struct_34_good	void CWE415_Double_Free__malloc_free_struct_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_struct_41_bad	void CWE415_Double_Free__malloc_free_struct_41_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_struct_41_good	void CWE415_Double_Free__malloc_free_struct_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static twoIntsStruct * badSource(twoIntsStruct * data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	CWE415_Double_Free__malloc_free_struct_42_bad	void CWE415_Double_Free__malloc_free_struct_42_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_struct_42_good	void CWE415_Double_Free__malloc_free_struct_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(twoIntsStruct * &data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static void goodG2BSource(twoIntsStruct * &data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static void goodB2GSource(twoIntsStruct * &data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_struct_44_bad	void CWE415_Double_Free__malloc_free_struct_44_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_struct_44_good	void CWE415_Double_Free__malloc_free_struct_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     twoIntsStruct * data = CWE415_Double_Free__malloc_free_struct_45_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_struct_45_bad	void CWE415_Double_Free__malloc_free_struct_45_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = CWE415_Double_Free__malloc_free_struct_45_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = CWE415_Double_Free__malloc_free_struct_45_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_45_goodB2GData = data;     goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_struct_45_good	void CWE415_Double_Free__malloc_free_struct_45_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_51_bad	void CWE415_Double_Free__malloc_free_struct_51_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_51b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_struct_51_good	void CWE415_Double_Free__malloc_free_struct_51_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_51b_badSink	void CWE415_Double_Free__malloc_free_struct_51b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_51b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_51b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_51b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_51b_goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_52_bad	void CWE415_Double_Free__malloc_free_struct_52_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_52b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_struct_52_good	void CWE415_Double_Free__malloc_free_struct_52_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_52b_badSink	void CWE415_Double_Free__malloc_free_struct_52b_badSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_52c_badSink(data); }
0	CWE415_Double_Free__malloc_free_struct_52b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_52b_goodG2BSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_52c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_52b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_52b_goodB2GSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_52c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_struct_52c_badSink	void CWE415_Double_Free__malloc_free_struct_52c_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_52c_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_52c_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_52c_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_52c_goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_53_bad	void CWE415_Double_Free__malloc_free_struct_53_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_53b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_struct_53_good	void CWE415_Double_Free__malloc_free_struct_53_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_53b_badSink	void CWE415_Double_Free__malloc_free_struct_53b_badSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_53c_badSink(data); }
0	CWE415_Double_Free__malloc_free_struct_53b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_53b_goodG2BSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_53c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_53b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_53b_goodB2GSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_53c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_struct_53c_badSink	void CWE415_Double_Free__malloc_free_struct_53c_badSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_53d_badSink(data); }
0	CWE415_Double_Free__malloc_free_struct_53c_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_53c_goodG2BSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_53d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_53c_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_53c_goodB2GSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_53d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_struct_53d_badSink	void CWE415_Double_Free__malloc_free_struct_53d_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_53d_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_53d_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_53d_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_53d_goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_54_bad	void CWE415_Double_Free__malloc_free_struct_54_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_54b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_struct_54_good	void CWE415_Double_Free__malloc_free_struct_54_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_54b_badSink	void CWE415_Double_Free__malloc_free_struct_54b_badSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54c_badSink(data); }
0	CWE415_Double_Free__malloc_free_struct_54b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_54b_goodG2BSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_54b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_54b_goodB2GSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_struct_54c_badSink	void CWE415_Double_Free__malloc_free_struct_54c_badSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54d_badSink(data); }
0	CWE415_Double_Free__malloc_free_struct_54c_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_54c_goodG2BSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_54c_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_54c_goodB2GSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_struct_54d_badSink	void CWE415_Double_Free__malloc_free_struct_54d_badSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54e_badSink(data); }
0	CWE415_Double_Free__malloc_free_struct_54d_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_54d_goodG2BSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54e_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_struct_54d_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_54d_goodB2GSink(twoIntsStruct * data) {     CWE415_Double_Free__malloc_free_struct_54e_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_struct_54e_badSink	void CWE415_Double_Free__malloc_free_struct_54e_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_54e_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_54e_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_54e_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_54e_goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_61_bad	void CWE415_Double_Free__malloc_free_struct_61_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_struct_61b_badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_struct_61b_goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_struct_61b_goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_struct_61_good	void CWE415_Double_Free__malloc_free_struct_61_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_61b_badSource	twoIntsStruct * CWE415_Double_Free__malloc_free_struct_61b_badSource(twoIntsStruct * data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	CWE415_Double_Free__malloc_free_struct_61b_goodG2BSource	twoIntsStruct * CWE415_Double_Free__malloc_free_struct_61b_goodG2BSource(twoIntsStruct * data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	CWE415_Double_Free__malloc_free_struct_61b_goodB2GSource	twoIntsStruct * CWE415_Double_Free__malloc_free_struct_61b_goodB2GSource(twoIntsStruct * data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(twoIntsStruct * &data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodG2BSource	void goodG2BSource(twoIntsStruct * &data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodB2GSource	void goodB2GSource(twoIntsStruct * &data) {     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	CWE415_Double_Free__malloc_free_struct_63_bad	void CWE415_Double_Free__malloc_free_struct_63_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_63b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_struct_63_good	void CWE415_Double_Free__malloc_free_struct_63_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_63b_badSink	void CWE415_Double_Free__malloc_free_struct_63b_badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_63b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_63b_goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_63b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_63b_goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_64_bad	void CWE415_Double_Free__malloc_free_struct_64_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_64b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_struct_64_good	void CWE415_Double_Free__malloc_free_struct_64_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_64b_badSink	void CWE415_Double_Free__malloc_free_struct_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_64b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_64b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_65_bad	void CWE415_Double_Free__malloc_free_struct_65_bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = CWE415_Double_Free__malloc_free_struct_65b_badSink;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE415_Double_Free__malloc_free_struct_65b_goodG2BSink;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = CWE415_Double_Free__malloc_free_struct_65b_goodB2GSink;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_struct_65_good	void CWE415_Double_Free__malloc_free_struct_65_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_65b_badSink	void CWE415_Double_Free__malloc_free_struct_65b_badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_65b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_65b_goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_65b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_65b_goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_66_bad	void CWE415_Double_Free__malloc_free_struct_66_bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* put data in array */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_struct_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_struct_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataArray[2] = data;     CWE415_Double_Free__malloc_free_struct_66b_goodB2GSink(dataArray); }
0	CWE415_Double_Free__malloc_free_struct_66_good	void CWE415_Double_Free__malloc_free_struct_66_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_66b_badSink	void CWE415_Double_Free__malloc_free_struct_66b_badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_66b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_66b_goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_66b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_66b_goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_67_bad	void CWE415_Double_Free__malloc_free_struct_67_bad() {     twoIntsStruct * data;     CWE415_Double_Free__malloc_free_struct_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_struct_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     CWE415_Double_Free__malloc_free_struct_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_struct_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     CWE415_Double_Free__malloc_free_struct_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_struct_67b_goodB2GSink(myStruct); }
0	CWE415_Double_Free__malloc_free_struct_67_good	void CWE415_Double_Free__malloc_free_struct_67_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_67b_badSink	void CWE415_Double_Free__malloc_free_struct_67b_badSink(CWE415_Double_Free__malloc_free_struct_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_67b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_67b_goodG2BSink(CWE415_Double_Free__malloc_free_struct_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_67b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_67b_goodB2GSink(CWE415_Double_Free__malloc_free_struct_67_structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_struct_68_bad	void CWE415_Double_Free__malloc_free_struct_68_bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_68_badData = data;     CWE415_Double_Free__malloc_free_struct_68b_badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_68_goodG2BData = data;     CWE415_Double_Free__malloc_free_struct_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_68_goodB2GData = data;     CWE415_Double_Free__malloc_free_struct_68b_goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_struct_68_good	void CWE415_Double_Free__malloc_free_struct_68_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_struct_68b_badSink	void CWE415_Double_Free__malloc_free_struct_68b_badSink() {     twoIntsStruct * data = CWE415_Double_Free__malloc_free_struct_68_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_68b_goodG2BSink	void CWE415_Double_Free__malloc_free_struct_68b_goodG2BSink() {     twoIntsStruct * data = CWE415_Double_Free__malloc_free_struct_68_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_68b_goodB2GSink	void CWE415_Double_Free__malloc_free_struct_68b_goodB2GSink() {     twoIntsStruct * data = CWE415_Double_Free__malloc_free_struct_68_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_struct_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_struct_81_goodB2G::action(twoIntsStruct * data) const {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_struct_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_struct_81_base& baseObject = CWE415_Double_Free__malloc_free_struct_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     const CWE415_Double_Free__malloc_free_struct_81_base& baseObject = CWE415_Double_Free__malloc_free_struct_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_struct_81_base& baseObject = CWE415_Double_Free__malloc_free_struct_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__malloc_free_struct_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_struct_82_goodB2G::action(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_struct_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_82_base* baseObject = new CWE415_Double_Free__malloc_free_struct_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_struct_82_base* baseObject = new CWE415_Double_Free__malloc_free_struct_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_struct_82_base* baseObject = new CWE415_Double_Free__malloc_free_struct_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__malloc_free_struct_83_bad	CWE415_Double_Free__malloc_free_struct_83_bad::CWE415_Double_Free__malloc_free_struct_83_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_struct_83_bad	CWE415_Double_Free__malloc_free_struct_83_bad::~CWE415_Double_Free__malloc_free_struct_83_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_83_goodB2G	CWE415_Double_Free__malloc_free_struct_83_goodB2G::CWE415_Double_Free__malloc_free_struct_83_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_struct_83_goodB2G	CWE415_Double_Free__malloc_free_struct_83_goodB2G::~CWE415_Double_Free__malloc_free_struct_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_struct_83_goodG2B	CWE415_Double_Free__malloc_free_struct_83_goodG2B::CWE415_Double_Free__malloc_free_struct_83_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_struct_83_goodG2B	CWE415_Double_Free__malloc_free_struct_83_goodG2B::~CWE415_Double_Free__malloc_free_struct_83_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_struct_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_struct_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_struct_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__malloc_free_struct_84_bad	CWE415_Double_Free__malloc_free_struct_84_bad::CWE415_Double_Free__malloc_free_struct_84_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_struct_84_bad	CWE415_Double_Free__malloc_free_struct_84_bad::~CWE415_Double_Free__malloc_free_struct_84_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_struct_84_goodB2G	CWE415_Double_Free__malloc_free_struct_84_goodB2G::CWE415_Double_Free__malloc_free_struct_84_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_struct_84_goodB2G	CWE415_Double_Free__malloc_free_struct_84_goodB2G::~CWE415_Double_Free__malloc_free_struct_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_struct_84_goodG2B	CWE415_Double_Free__malloc_free_struct_84_goodG2B::CWE415_Double_Free__malloc_free_struct_84_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_struct_84_goodG2B	CWE415_Double_Free__malloc_free_struct_84_goodG2B::~CWE415_Double_Free__malloc_free_struct_84_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_struct_84_bad * badObject = new CWE415_Double_Free__malloc_free_struct_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_struct_84_goodG2B * goodG2BObject = new CWE415_Double_Free__malloc_free_struct_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_struct_84_goodB2G * goodB2GObject = new CWE415_Double_Free__malloc_free_struct_84_goodB2G(data);     delete goodB2GObject; }
1	CWE415_Double_Free__malloc_free_wchar_t_01_bad	void CWE415_Double_Free__malloc_free_wchar_t_01_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_wchar_t_01_good	void CWE415_Double_Free__malloc_free_wchar_t_01_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_02_bad	void CWE415_Double_Free__malloc_free_wchar_t_02_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_02_good	void CWE415_Double_Free__malloc_free_wchar_t_02_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_03_bad	void CWE415_Double_Free__malloc_free_wchar_t_03_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_03_good	void CWE415_Double_Free__malloc_free_wchar_t_03_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_04_bad	void CWE415_Double_Free__malloc_free_wchar_t_04_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_04_good	void CWE415_Double_Free__malloc_free_wchar_t_04_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_05_bad	void CWE415_Double_Free__malloc_free_wchar_t_05_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_05_good	void CWE415_Double_Free__malloc_free_wchar_t_05_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_06_bad	void CWE415_Double_Free__malloc_free_wchar_t_06_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_06_good	void CWE415_Double_Free__malloc_free_wchar_t_06_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_07_bad	void CWE415_Double_Free__malloc_free_wchar_t_07_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_07_good	void CWE415_Double_Free__malloc_free_wchar_t_07_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_08_bad	void CWE415_Double_Free__malloc_free_wchar_t_08_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_08_good	void CWE415_Double_Free__malloc_free_wchar_t_08_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_09_bad	void CWE415_Double_Free__malloc_free_wchar_t_09_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_09_good	void CWE415_Double_Free__malloc_free_wchar_t_09_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_10_bad	void CWE415_Double_Free__malloc_free_wchar_t_10_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_10_good	void CWE415_Double_Free__malloc_free_wchar_t_10_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_11_bad	void CWE415_Double_Free__malloc_free_wchar_t_11_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_11_good	void CWE415_Double_Free__malloc_free_wchar_t_11_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_12_bad	void CWE415_Double_Free__malloc_free_wchar_t_12_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     }     else     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_12_good	void CWE415_Double_Free__malloc_free_wchar_t_12_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_wchar_t_13_bad	void CWE415_Double_Free__malloc_free_wchar_t_13_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_13_good	void CWE415_Double_Free__malloc_free_wchar_t_13_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_14_bad	void CWE415_Double_Free__malloc_free_wchar_t_14_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_14_good	void CWE415_Double_Free__malloc_free_wchar_t_14_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_15_bad	void CWE415_Double_Free__malloc_free_wchar_t_15_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE415_Double_Free__malloc_free_wchar_t_15_good	void CWE415_Double_Free__malloc_free_wchar_t_15_good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	CWE415_Double_Free__malloc_free_wchar_t_16_bad	void CWE415_Double_Free__malloc_free_wchar_t_16_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);         break;     } }
0	CWE415_Double_Free__malloc_free_wchar_t_16_good	void CWE415_Double_Free__malloc_free_wchar_t_16_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_wchar_t_17_bad	void CWE415_Double_Free__malloc_free_wchar_t_17_bad() {     int i,j;     wchar_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_17_good	void CWE415_Double_Free__malloc_free_wchar_t_17_good() {     goodB2G();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_wchar_t_18_bad	void CWE415_Double_Free__malloc_free_wchar_t_18_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_18_good	void CWE415_Double_Free__malloc_free_wchar_t_18_good() {     goodB2G();     goodG2B(); }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_wchar_t_21_bad	void CWE415_Double_Free__malloc_free_wchar_t_21_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2BStatic)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BStatic = 1; /* true */     goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_21_good	void CWE415_Double_Free__malloc_free_wchar_t_21_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_wchar_t_22_bad	void CWE415_Double_Free__malloc_free_wchar_t_22_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_22_badGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_wchar_t_22_badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G1Global = 0; /* false */     CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G2Global = 1; /* true */     CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G2Sink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_22_goodG2BGlobal = 1; /* true */     CWE415_Double_Free__malloc_free_wchar_t_22_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_22_good	void CWE415_Double_Free__malloc_free_wchar_t_22_good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	CWE415_Double_Free__malloc_free_wchar_t_22_badSink	void CWE415_Double_Free__malloc_free_wchar_t_22_badSink(wchar_t * data) {     if(CWE415_Double_Free__malloc_free_wchar_t_22_badGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G1Sink	void CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G1Sink(wchar_t * data) {     if(CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G2Sink	void CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G2Sink(wchar_t * data) {     if(CWE415_Double_Free__malloc_free_wchar_t_22_goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_wchar_t_22_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_22_goodG2BSink(wchar_t * data) {     if(CWE415_Double_Free__malloc_free_wchar_t_22_goodG2BGlobal)     {         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
1	CWE415_Double_Free__malloc_free_wchar_t_31_bad	void CWE415_Double_Free__malloc_free_wchar_t_31_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_wchar_t_31_good	void CWE415_Double_Free__malloc_free_wchar_t_31_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_32_bad	void CWE415_Double_Free__malloc_free_wchar_t_32_bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* FIX: Do NOT free data in the source - the bad sink frees data */         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = (wchar_t *)malloc(100*sizeof(wchar_t));         if (data == NULL) {exit(-1);}         /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */         free(data);         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_wchar_t_32_good	void CWE415_Double_Free__malloc_free_wchar_t_32_good() {     goodG2B();     goodB2G(); }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     {         wchar_t * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
1	CWE415_Double_Free__malloc_free_wchar_t_34_bad	void CWE415_Double_Free__malloc_free_wchar_t_34_bad() {     wchar_t * data;     CWE415_Double_Free__malloc_free_wchar_t_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE415_Double_Free__malloc_free_wchar_t_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly freeing memory twice */         free(data);     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE415_Double_Free__malloc_free_wchar_t_34_unionType myUnion;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to free the memory */         ; /* empty statement needed for some flow variants */     } }
0	CWE415_Double_Free__malloc_free_wchar_t_34_good	void CWE415_Double_Free__malloc_free_wchar_t_34_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_41_bad	void CWE415_Double_Free__malloc_free_wchar_t_41_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_41_good	void CWE415_Double_Free__malloc_free_wchar_t_41_good() {     goodB2G();     goodG2B(); }
1	badSource	static wchar_t * badSource(wchar_t * data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	CWE415_Double_Free__malloc_free_wchar_t_42_bad	void CWE415_Double_Free__malloc_free_wchar_t_42_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static wchar_t * goodB2GSource(wchar_t * data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_wchar_t_42_good	void CWE415_Double_Free__malloc_free_wchar_t_42_good() {     goodB2G();     goodG2B(); }
1	badSource	static void badSource(wchar_t * &data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSource	static void goodG2BSource(wchar_t * &data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSource	static void goodB2GSource(wchar_t * &data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_44_bad	void CWE415_Double_Free__malloc_free_wchar_t_44_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_44_good	void CWE415_Double_Free__malloc_free_wchar_t_44_good() {     goodG2B();     goodB2G(); }
1	badSink	static void badSink() {     wchar_t * data = CWE415_Double_Free__malloc_free_wchar_t_45_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_45_bad	void CWE415_Double_Free__malloc_free_wchar_t_45_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_45_badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = CWE415_Double_Free__malloc_free_wchar_t_45_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_45_goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = CWE415_Double_Free__malloc_free_wchar_t_45_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_45_goodB2GData = data;     goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_wchar_t_45_good	void CWE415_Double_Free__malloc_free_wchar_t_45_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_51_bad	void CWE415_Double_Free__malloc_free_wchar_t_51_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_51b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_51b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_51b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_51_good	void CWE415_Double_Free__malloc_free_wchar_t_51_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_51b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_51b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_51b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_51b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_51b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_51b_goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_52_bad	void CWE415_Double_Free__malloc_free_wchar_t_52_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_52b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_52b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_52b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_52_good	void CWE415_Double_Free__malloc_free_wchar_t_52_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_52b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_52b_badSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_52c_badSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_52b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_52b_goodG2BSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_52c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_52b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_52b_goodB2GSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_52c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_52c_badSink	void CWE415_Double_Free__malloc_free_wchar_t_52c_badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_52c_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_52c_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_52c_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_52c_goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_53_bad	void CWE415_Double_Free__malloc_free_wchar_t_53_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_53b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_53b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_53b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_53_good	void CWE415_Double_Free__malloc_free_wchar_t_53_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_53b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_53b_badSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_53c_badSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_53b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_53b_goodG2BSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_53c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_53b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_53b_goodB2GSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_53c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_53c_badSink	void CWE415_Double_Free__malloc_free_wchar_t_53c_badSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_53d_badSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_53c_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_53c_goodG2BSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_53d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_53c_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_53c_goodB2GSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_53d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_53d_badSink	void CWE415_Double_Free__malloc_free_wchar_t_53d_badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_53d_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_53d_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_53d_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_53d_goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_54_bad	void CWE415_Double_Free__malloc_free_wchar_t_54_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_54b_badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_54b_goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_54b_goodB2GSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54_good	void CWE415_Double_Free__malloc_free_wchar_t_54_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_54b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_54b_badSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54c_badSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_54b_goodG2BSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54c_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_54b_goodB2GSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54c_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_54c_badSink	void CWE415_Double_Free__malloc_free_wchar_t_54c_badSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54d_badSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54c_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_54c_goodG2BSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54d_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54c_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_54c_goodB2GSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54d_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_54d_badSink	void CWE415_Double_Free__malloc_free_wchar_t_54d_badSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54e_badSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54d_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_54d_goodG2BSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54e_goodG2BSink(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54d_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_54d_goodB2GSink(wchar_t * data) {     CWE415_Double_Free__malloc_free_wchar_t_54e_goodB2GSink(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_54e_badSink	void CWE415_Double_Free__malloc_free_wchar_t_54e_badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54e_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_54e_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_54e_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_54e_goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_61_bad	void CWE415_Double_Free__malloc_free_wchar_t_61_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_wchar_t_61b_badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_wchar_t_61b_goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = CWE415_Double_Free__malloc_free_wchar_t_61b_goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_wchar_t_61_good	void CWE415_Double_Free__malloc_free_wchar_t_61_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_61b_badSource	wchar_t * CWE415_Double_Free__malloc_free_wchar_t_61b_badSource(wchar_t * data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
0	CWE415_Double_Free__malloc_free_wchar_t_61b_goodG2BSource	wchar_t * CWE415_Double_Free__malloc_free_wchar_t_61b_goodG2BSource(wchar_t * data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     return data; }
0	CWE415_Double_Free__malloc_free_wchar_t_61b_goodB2GSource	wchar_t * CWE415_Double_Free__malloc_free_wchar_t_61b_goodB2GSource(wchar_t * data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     return data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(wchar_t * &data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	goodG2BSource	void goodG2BSource(wchar_t * &data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	goodB2GSource	void goodB2GSource(wchar_t * &data) {     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_63_bad	void CWE415_Double_Free__malloc_free_wchar_t_63_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_63b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_63b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_63b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_wchar_t_63_good	void CWE415_Double_Free__malloc_free_wchar_t_63_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_63b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_63b_badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_63b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_63b_goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_63b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_63b_goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_64_bad	void CWE415_Double_Free__malloc_free_wchar_t_64_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_64b_badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_64b_goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_64b_goodB2GSink(&data); }
0	CWE415_Double_Free__malloc_free_wchar_t_64_good	void CWE415_Double_Free__malloc_free_wchar_t_64_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_64b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_64b_badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_64b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_64b_goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_64b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_64b_goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_65_bad	void CWE415_Double_Free__malloc_free_wchar_t_65_bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = CWE415_Double_Free__malloc_free_wchar_t_65b_badSink;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE415_Double_Free__malloc_free_wchar_t_65b_goodG2BSink;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = CWE415_Double_Free__malloc_free_wchar_t_65b_goodB2GSink;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     funcPtr(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_65_good	void CWE415_Double_Free__malloc_free_wchar_t_65_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_65b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_65b_badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_65b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_65b_goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_65b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_65b_goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_66_bad	void CWE415_Double_Free__malloc_free_wchar_t_66_bad() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* put data in array */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_wchar_t_66b_badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     dataArray[2] = data;     CWE415_Double_Free__malloc_free_wchar_t_66b_goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataArray[2] = data;     CWE415_Double_Free__malloc_free_wchar_t_66b_goodB2GSink(dataArray); }
0	CWE415_Double_Free__malloc_free_wchar_t_66_good	void CWE415_Double_Free__malloc_free_wchar_t_66_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_66b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_66b_badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_66b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_66b_goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_66b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_66b_goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_67_bad	void CWE415_Double_Free__malloc_free_wchar_t_67_bad() {     wchar_t * data;     CWE415_Double_Free__malloc_free_wchar_t_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_wchar_t_67b_badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     CWE415_Double_Free__malloc_free_wchar_t_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_wchar_t_67b_goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     CWE415_Double_Free__malloc_free_wchar_t_67_structType myStruct;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     myStruct.structFirst = data;     CWE415_Double_Free__malloc_free_wchar_t_67b_goodB2GSink(myStruct); }
0	CWE415_Double_Free__malloc_free_wchar_t_67_good	void CWE415_Double_Free__malloc_free_wchar_t_67_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_67b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_67b_badSink(CWE415_Double_Free__malloc_free_wchar_t_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_67b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_67b_goodG2BSink(CWE415_Double_Free__malloc_free_wchar_t_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_67b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_67b_goodB2GSink(CWE415_Double_Free__malloc_free_wchar_t_67_structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	CWE415_Double_Free__malloc_free_wchar_t_68_bad	void CWE415_Double_Free__malloc_free_wchar_t_68_bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_68_badData = data;     CWE415_Double_Free__malloc_free_wchar_t_68b_badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_68_goodG2BData = data;     CWE415_Double_Free__malloc_free_wchar_t_68b_goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_68_goodB2GData = data;     CWE415_Double_Free__malloc_free_wchar_t_68b_goodB2GSink(); }
0	CWE415_Double_Free__malloc_free_wchar_t_68_good	void CWE415_Double_Free__malloc_free_wchar_t_68_good() {     goodG2B();     goodB2G(); }
1	CWE415_Double_Free__malloc_free_wchar_t_68b_badSink	void CWE415_Double_Free__malloc_free_wchar_t_68b_badSink() {     wchar_t * data = CWE415_Double_Free__malloc_free_wchar_t_68_badData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_68b_goodG2BSink	void CWE415_Double_Free__malloc_free_wchar_t_68b_goodG2BSink() {     wchar_t * data = CWE415_Double_Free__malloc_free_wchar_t_68_goodG2BData;     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_68b_goodB2GSink	void CWE415_Double_Free__malloc_free_wchar_t_68b_goodB2GSink() {     wchar_t * data = CWE415_Double_Free__malloc_free_wchar_t_68_goodB2GData;     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_wchar_t_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_wchar_t_81_goodB2G::action(wchar_t * data) const {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_wchar_t_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_wchar_t_81_base& baseObject = CWE415_Double_Free__malloc_free_wchar_t_81_bad();     baseObject.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     const CWE415_Double_Free__malloc_free_wchar_t_81_base& baseObject = CWE415_Double_Free__malloc_free_wchar_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     const CWE415_Double_Free__malloc_free_wchar_t_81_base& baseObject = CWE415_Double_Free__malloc_free_wchar_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__malloc_free_wchar_t_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	action	void CWE415_Double_Free__malloc_free_wchar_t_82_goodB2G::action(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__malloc_free_wchar_t_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_82_base* baseObject = new CWE415_Double_Free__malloc_free_wchar_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */     CWE415_Double_Free__malloc_free_wchar_t_82_base* baseObject = new CWE415_Double_Free__malloc_free_wchar_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data);     CWE415_Double_Free__malloc_free_wchar_t_82_base* baseObject = new CWE415_Double_Free__malloc_free_wchar_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__malloc_free_wchar_t_83_bad	CWE415_Double_Free__malloc_free_wchar_t_83_bad::CWE415_Double_Free__malloc_free_wchar_t_83_bad(wchar_t * dataCopy) {     data = dataCopy;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_wchar_t_83_bad	CWE415_Double_Free__malloc_free_wchar_t_83_bad::~CWE415_Double_Free__malloc_free_wchar_t_83_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_83_goodB2G	CWE415_Double_Free__malloc_free_wchar_t_83_goodB2G::CWE415_Double_Free__malloc_free_wchar_t_83_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_wchar_t_83_goodB2G	CWE415_Double_Free__malloc_free_wchar_t_83_goodB2G::~CWE415_Double_Free__malloc_free_wchar_t_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_wchar_t_83_goodG2B	CWE415_Double_Free__malloc_free_wchar_t_83_goodG2B::CWE415_Double_Free__malloc_free_wchar_t_83_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_wchar_t_83_goodG2B	CWE415_Double_Free__malloc_free_wchar_t_83_goodG2B::~CWE415_Double_Free__malloc_free_wchar_t_83_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_wchar_t_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_wchar_t_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_wchar_t_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__malloc_free_wchar_t_84_bad	CWE415_Double_Free__malloc_free_wchar_t_84_bad::CWE415_Double_Free__malloc_free_wchar_t_84_bad(wchar_t * dataCopy) {     data = dataCopy;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
1	~CWE415_Double_Free__malloc_free_wchar_t_84_bad	CWE415_Double_Free__malloc_free_wchar_t_84_bad::~CWE415_Double_Free__malloc_free_wchar_t_84_bad() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
0	CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G	CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G::CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* POTENTIAL FLAW: Free data in the source - the bad sink frees data as well */     free(data); }
0	~CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G	CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G::~CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to free the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B	CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B::CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     data = (wchar_t *)malloc(100*sizeof(wchar_t));     if (data == NULL) {exit(-1);}     /* FIX: Do NOT free data in the source - the bad sink frees data */ }
0	~CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B	CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B::~CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B() {     /* POTENTIAL FLAW: Possibly freeing memory twice */     free(data); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_wchar_t_84_bad * badObject = new CWE415_Double_Free__malloc_free_wchar_t_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B * goodG2BObject = new CWE415_Double_Free__malloc_free_wchar_t_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G * goodB2GObject = new CWE415_Double_Free__malloc_free_wchar_t_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
1	bad	void bad() {     int i,j;     char * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(char * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1Sink	void goodB2G1Sink(char * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(char * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(char * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         char * dataCopy = data;         char * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = new char[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = new char[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         char * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         char * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         char * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     char * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     char * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSource	static char * badSource(char * data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static char * goodG2BSource(char * data) {     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static char * goodB2GSource(char * data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(char * &data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static void goodG2BSource(char * &data) {     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static void goodB2GSource(char * &data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	static void badSink() {     char * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_e	void goodG2BSink_e(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_e	void goodB2GSink_e(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	char * badSource(char * data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodG2BSource	char * goodG2BSource(char * data) {     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodB2GSource	char * goodB2GSource(char * data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(char * &data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodG2BSource	void goodG2BSource(char * &data) {     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodB2GSource	void goodB2GSource(char * &data) {     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     char * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     char * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink() {     char * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_char_81_bad::action(char * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_char_81_goodB2G::action(char * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_char_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_char_81_base& o = CWE415_Double_Free__new_delete_array_char_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     const CWE415_Double_Free__new_delete_array_char_81_base& baseObject = CWE415_Double_Free__new_delete_array_char_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_char_81_base& baseObject = CWE415_Double_Free__new_delete_array_char_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_array_char_82_bad::action(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_char_82_goodB2G::action(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_char_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_char_82_base* baseObject = new CWE415_Double_Free__new_delete_array_char_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     CWE415_Double_Free__new_delete_array_char_82_base* baseObject = new CWE415_Double_Free__new_delete_array_char_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_char_82_base* baseObject = new CWE415_Double_Free__new_delete_array_char_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_array_char_83_bad	CWE415_Double_Free__new_delete_array_char_83_bad::CWE415_Double_Free__new_delete_array_char_83_bad(char * dataCopy) {     data = dataCopy;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_char_83_bad	CWE415_Double_Free__new_delete_array_char_83_bad::~CWE415_Double_Free__new_delete_array_char_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_char_83_goodB2G	CWE415_Double_Free__new_delete_array_char_83_goodB2G::CWE415_Double_Free__new_delete_array_char_83_goodB2G(char * dataCopy) {     data = dataCopy;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_char_83_goodB2G	CWE415_Double_Free__new_delete_array_char_83_goodB2G::~CWE415_Double_Free__new_delete_array_char_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_char_83_goodG2B	CWE415_Double_Free__new_delete_array_char_83_goodG2B::CWE415_Double_Free__new_delete_array_char_83_goodG2B(char * dataCopy) {     data = dataCopy;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_char_83_goodG2B	CWE415_Double_Free__new_delete_array_char_83_goodG2B::~CWE415_Double_Free__new_delete_array_char_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_char_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_char_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_char_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_array_char_84_bad	CWE415_Double_Free__new_delete_array_char_84_bad::CWE415_Double_Free__new_delete_array_char_84_bad(char * dataCopy) {     data = dataCopy;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_char_84_bad	CWE415_Double_Free__new_delete_array_char_84_bad::~CWE415_Double_Free__new_delete_array_char_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_char_84_goodB2G	CWE415_Double_Free__new_delete_array_char_84_goodB2G::CWE415_Double_Free__new_delete_array_char_84_goodB2G(char * dataCopy) {     data = dataCopy;     data = new char[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_char_84_goodB2G	CWE415_Double_Free__new_delete_array_char_84_goodB2G::~CWE415_Double_Free__new_delete_array_char_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_char_84_goodG2B	CWE415_Double_Free__new_delete_array_char_84_goodG2B::CWE415_Double_Free__new_delete_array_char_84_goodG2B(char * dataCopy) {     data = dataCopy;     data = new char[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_char_84_goodG2B	CWE415_Double_Free__new_delete_array_char_84_goodG2B::~CWE415_Double_Free__new_delete_array_char_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_char_84_bad * badObject = new CWE415_Double_Free__new_delete_array_char_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_char_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_array_char_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_char_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_array_char_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
1	bad	void bad() {     int i,j;     TwoIntsClass * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     TwoIntsClass * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     TwoIntsClass * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	badSink	static void badSink(TwoIntsClass * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(TwoIntsClass * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1Sink	void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(TwoIntsClass * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         data = new TwoIntsClass[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         data = new TwoIntsClass[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         TwoIntsClass * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSource	static TwoIntsClass * badSource(TwoIntsClass * data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static TwoIntsClass * goodG2BSource(TwoIntsClass * data) {     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static TwoIntsClass * goodB2GSource(TwoIntsClass * data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(TwoIntsClass * &data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static void goodG2BSource(TwoIntsClass * &data) {     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static void goodB2GSource(TwoIntsClass * &data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	static void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_e	void goodG2BSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_e	void goodB2GSink_e(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	TwoIntsClass * badSource(TwoIntsClass * data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodG2BSource	TwoIntsClass * goodG2BSource(TwoIntsClass * data) {     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodB2GSource	TwoIntsClass * goodB2GSource(TwoIntsClass * data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(TwoIntsClass * &data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodG2BSource	void goodG2BSource(TwoIntsClass * &data) {     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodB2GSource	void goodB2GSource(TwoIntsClass * &data) {     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(TwoIntsClass * dataArray[]) {     /* copy data out of dataArray */     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<TwoIntsClass *> dataVector) {     /* copy data out of dataVector */     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<TwoIntsClass *> dataList) {     /* copy data out of dataList */     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, TwoIntsClass *> dataMap) {     /* copy data out of dataMap */     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_class_81_bad::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_class_81_goodB2G::action(TwoIntsClass * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_class_81_goodG2B::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_class_81_base& o = CWE415_Double_Free__new_delete_array_class_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     const CWE415_Double_Free__new_delete_array_class_81_base& baseObject = CWE415_Double_Free__new_delete_array_class_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_class_81_base& baseObject = CWE415_Double_Free__new_delete_array_class_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_array_class_82_bad::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_class_82_goodB2G::action(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_class_82_goodG2B::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_class_82_base* baseObject = new CWE415_Double_Free__new_delete_array_class_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     CWE415_Double_Free__new_delete_array_class_82_base* baseObject = new CWE415_Double_Free__new_delete_array_class_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_class_82_base* baseObject = new CWE415_Double_Free__new_delete_array_class_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_array_class_83_bad	CWE415_Double_Free__new_delete_array_class_83_bad::CWE415_Double_Free__new_delete_array_class_83_bad(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_class_83_bad	CWE415_Double_Free__new_delete_array_class_83_bad::~CWE415_Double_Free__new_delete_array_class_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_class_83_goodB2G	CWE415_Double_Free__new_delete_array_class_83_goodB2G::CWE415_Double_Free__new_delete_array_class_83_goodB2G(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_class_83_goodB2G	CWE415_Double_Free__new_delete_array_class_83_goodB2G::~CWE415_Double_Free__new_delete_array_class_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_class_83_goodG2B	CWE415_Double_Free__new_delete_array_class_83_goodG2B::CWE415_Double_Free__new_delete_array_class_83_goodG2B(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_class_83_goodG2B	CWE415_Double_Free__new_delete_array_class_83_goodG2B::~CWE415_Double_Free__new_delete_array_class_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_class_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_class_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_class_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_array_class_84_bad	CWE415_Double_Free__new_delete_array_class_84_bad::CWE415_Double_Free__new_delete_array_class_84_bad(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_class_84_bad	CWE415_Double_Free__new_delete_array_class_84_bad::~CWE415_Double_Free__new_delete_array_class_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_class_84_goodB2G	CWE415_Double_Free__new_delete_array_class_84_goodB2G::CWE415_Double_Free__new_delete_array_class_84_goodB2G(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_class_84_goodB2G	CWE415_Double_Free__new_delete_array_class_84_goodB2G::~CWE415_Double_Free__new_delete_array_class_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_class_84_goodG2B	CWE415_Double_Free__new_delete_array_class_84_goodG2B::CWE415_Double_Free__new_delete_array_class_84_goodG2B(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_class_84_goodG2B	CWE415_Double_Free__new_delete_array_class_84_goodG2B::~CWE415_Double_Free__new_delete_array_class_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_class_84_bad * badObject = new CWE415_Double_Free__new_delete_array_class_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_class_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_array_class_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_class_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_array_class_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
1	bad	void bad() {     int i,j;     int64_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int64_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1Sink	void goodB2G1Sink(int64_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(int64_t * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(int64_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = new int64_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = new int64_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int64_t * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSource	static int64_t * badSource(int64_t * data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static int64_t * goodG2BSource(int64_t * data) {     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static int64_t * goodB2GSource(int64_t * data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int64_t * &data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static void goodG2BSource(int64_t * &data) {     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static void goodB2GSource(int64_t * &data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	static void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_e	void goodG2BSink_e(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_e	void goodB2GSink_e(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	int64_t * badSource(int64_t * data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodG2BSource	int64_t * goodG2BSource(int64_t * data) {     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodB2GSource	int64_t * goodB2GSource(int64_t * data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int64_t * &data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodG2BSource	void goodG2BSource(int64_t * &data) {     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodB2GSource	void goodB2GSource(int64_t * &data) {     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink() {     int64_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_int64_t_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_int64_t_81_goodB2G::action(int64_t * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_int64_t_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_int64_t_81_base& o = CWE415_Double_Free__new_delete_array_int64_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     const CWE415_Double_Free__new_delete_array_int64_t_81_base& baseObject = CWE415_Double_Free__new_delete_array_int64_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_int64_t_81_base& baseObject = CWE415_Double_Free__new_delete_array_int64_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_array_int64_t_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_int64_t_82_goodB2G::action(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_int64_t_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_int64_t_82_base* baseObject = new CWE415_Double_Free__new_delete_array_int64_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     CWE415_Double_Free__new_delete_array_int64_t_82_base* baseObject = new CWE415_Double_Free__new_delete_array_int64_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_int64_t_82_base* baseObject = new CWE415_Double_Free__new_delete_array_int64_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_array_int64_t_83_bad	CWE415_Double_Free__new_delete_array_int64_t_83_bad::CWE415_Double_Free__new_delete_array_int64_t_83_bad(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_int64_t_83_bad	CWE415_Double_Free__new_delete_array_int64_t_83_bad::~CWE415_Double_Free__new_delete_array_int64_t_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_int64_t_83_goodB2G	CWE415_Double_Free__new_delete_array_int64_t_83_goodB2G::CWE415_Double_Free__new_delete_array_int64_t_83_goodB2G(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_int64_t_83_goodB2G	CWE415_Double_Free__new_delete_array_int64_t_83_goodB2G::~CWE415_Double_Free__new_delete_array_int64_t_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_int64_t_83_goodG2B	CWE415_Double_Free__new_delete_array_int64_t_83_goodG2B::CWE415_Double_Free__new_delete_array_int64_t_83_goodG2B(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_int64_t_83_goodG2B	CWE415_Double_Free__new_delete_array_int64_t_83_goodG2B::~CWE415_Double_Free__new_delete_array_int64_t_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int64_t_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int64_t_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int64_t_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_array_int64_t_84_bad	CWE415_Double_Free__new_delete_array_int64_t_84_bad::CWE415_Double_Free__new_delete_array_int64_t_84_bad(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_int64_t_84_bad	CWE415_Double_Free__new_delete_array_int64_t_84_bad::~CWE415_Double_Free__new_delete_array_int64_t_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G	CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G::CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G	CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G::~CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B	CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B::CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B	CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B::~CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int64_t_84_bad * badObject = new CWE415_Double_Free__new_delete_array_int64_t_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_array_int64_t_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_array_int64_t_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
1	bad	void bad() {     int i,j;     int * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1Sink	void goodB2G1Sink(int * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(int * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(int * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int * dataCopy = data;         int * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = new int[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = new int[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         int * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         int * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     int * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSource	static int * badSource(int * data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static int * goodG2BSource(int * data) {     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static int * goodB2GSource(int * data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int * &data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static void goodG2BSource(int * &data) {     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static void goodB2GSource(int * &data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	static void badSink() {     int * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_e	void goodG2BSink_e(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_e	void goodB2GSink_e(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	int * badSource(int * data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodG2BSource	int * goodG2BSource(int * data) {     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodB2GSource	int * goodB2GSource(int * data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int * &data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodG2BSource	void goodG2BSource(int * &data) {     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodB2GSource	void goodB2GSource(int * &data) {     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink() {     int * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_int_81_bad::action(int * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_int_81_goodB2G::action(int * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_int_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_int_81_base& o = CWE415_Double_Free__new_delete_array_int_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     const CWE415_Double_Free__new_delete_array_int_81_base& baseObject = CWE415_Double_Free__new_delete_array_int_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_int_81_base& baseObject = CWE415_Double_Free__new_delete_array_int_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_array_int_82_bad::action(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_int_82_goodB2G::action(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_int_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_int_82_base* baseObject = new CWE415_Double_Free__new_delete_array_int_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     CWE415_Double_Free__new_delete_array_int_82_base* baseObject = new CWE415_Double_Free__new_delete_array_int_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_int_82_base* baseObject = new CWE415_Double_Free__new_delete_array_int_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_array_int_83_bad	CWE415_Double_Free__new_delete_array_int_83_bad::CWE415_Double_Free__new_delete_array_int_83_bad(int * dataCopy) {     data = dataCopy;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_int_83_bad	CWE415_Double_Free__new_delete_array_int_83_bad::~CWE415_Double_Free__new_delete_array_int_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_int_83_goodB2G	CWE415_Double_Free__new_delete_array_int_83_goodB2G::CWE415_Double_Free__new_delete_array_int_83_goodB2G(int * dataCopy) {     data = dataCopy;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_int_83_goodB2G	CWE415_Double_Free__new_delete_array_int_83_goodB2G::~CWE415_Double_Free__new_delete_array_int_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_int_83_goodG2B	CWE415_Double_Free__new_delete_array_int_83_goodG2B::CWE415_Double_Free__new_delete_array_int_83_goodG2B(int * dataCopy) {     data = dataCopy;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_int_83_goodG2B	CWE415_Double_Free__new_delete_array_int_83_goodG2B::~CWE415_Double_Free__new_delete_array_int_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_array_int_84_bad	CWE415_Double_Free__new_delete_array_int_84_bad::CWE415_Double_Free__new_delete_array_int_84_bad(int * dataCopy) {     data = dataCopy;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_int_84_bad	CWE415_Double_Free__new_delete_array_int_84_bad::~CWE415_Double_Free__new_delete_array_int_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_int_84_goodB2G	CWE415_Double_Free__new_delete_array_int_84_goodB2G::CWE415_Double_Free__new_delete_array_int_84_goodB2G(int * dataCopy) {     data = dataCopy;     data = new int[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_int_84_goodB2G	CWE415_Double_Free__new_delete_array_int_84_goodB2G::~CWE415_Double_Free__new_delete_array_int_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_int_84_goodG2B	CWE415_Double_Free__new_delete_array_int_84_goodG2B::CWE415_Double_Free__new_delete_array_int_84_goodG2B(int * dataCopy) {     data = dataCopy;     data = new int[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_int_84_goodG2B	CWE415_Double_Free__new_delete_array_int_84_goodG2B::~CWE415_Double_Free__new_delete_array_int_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int_84_bad * badObject = new CWE415_Double_Free__new_delete_array_int_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_array_int_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_int_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_array_int_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
1	bad	void bad() {     int i,j;     long * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     long * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     long * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	badSink	static void badSink(long * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(long * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(long * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(long * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1Sink	void goodB2G1Sink(long * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(long * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(long * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         long * dataCopy = data;         long * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         long * dataCopy = data;         long * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         long * dataCopy = data;         long * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = new long[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = new long[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         long * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         long * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         long * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     long * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     long * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     long * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSource	static long * badSource(long * data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static long * goodG2BSource(long * data) {     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static long * goodB2GSource(long * data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(long * &data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static void goodG2BSource(long * &data) {     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static void goodB2GSource(long * &data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     long * data;     /* define a function pointer */     void (*funcPtr) (long *) = badSink;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     long * data;     void (*funcPtr) (long *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     void (*funcPtr) (long *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	static void badSink() {     long * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     long * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     long * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSink	void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(long * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(long * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(long * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_c	void goodG2BSink_c(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_c	void goodB2GSink_c(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(long * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(long * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(long * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(long * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(long * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(long * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_d	void goodG2BSink_d(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_d	void goodB2GSink_d(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(long * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(long * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(long * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(long * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(long * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(long * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(long * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(long * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(long * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_e	void goodG2BSink_e(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_e	void goodB2GSink_e(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	long * badSource(long * data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodG2BSource	long * goodG2BSource(long * data) {     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodB2GSource	long * goodB2GSource(long * data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(long * &data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodG2BSource	void goodG2BSource(long * &data) {     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodB2GSource	void goodB2GSource(long * &data) {     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(long * * dataPtr) {     long * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(long * * dataPtr) {     long * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(long * * dataPtr) {     long * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* define a function pointer */     void (*funcPtr) (long *) = badSink;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     long * data;     void (*funcPtr) (long *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     long * data;     void (*funcPtr) (long *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(long * dataArray[]) {     /* copy data out of dataArray */     long * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(long * dataArray[]) {     long * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(long * dataArray[]) {     long * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     long * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     long * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     long * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     long * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     long * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     long * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink() {     long * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink() {     long * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<long *> dataVector) {     /* copy data out of dataVector */     long * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(vector<long *> dataVector) {     long * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(vector<long *> dataVector) {     long * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<long *> dataList) {     /* copy data out of dataList */     long * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(list<long *> dataList) {     long * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(list<long *> dataList) {     long * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, long *> dataMap) {     /* copy data out of dataMap */     long * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(map<int, long *> dataMap) {     long * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(map<int, long *> dataMap) {     long * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_long_81_bad::action(long * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_long_81_goodB2G::action(long * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_long_81_goodG2B::action(long * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_long_81_base& o = CWE415_Double_Free__new_delete_array_long_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     const CWE415_Double_Free__new_delete_array_long_81_base& baseObject = CWE415_Double_Free__new_delete_array_long_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_long_81_base& baseObject = CWE415_Double_Free__new_delete_array_long_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_array_long_82_bad::action(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_long_82_goodB2G::action(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_long_82_goodG2B::action(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_long_82_base* baseObject = new CWE415_Double_Free__new_delete_array_long_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     CWE415_Double_Free__new_delete_array_long_82_base* baseObject = new CWE415_Double_Free__new_delete_array_long_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_long_82_base* baseObject = new CWE415_Double_Free__new_delete_array_long_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_array_long_83_bad	CWE415_Double_Free__new_delete_array_long_83_bad::CWE415_Double_Free__new_delete_array_long_83_bad(long * dataCopy) {     data = dataCopy;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_long_83_bad	CWE415_Double_Free__new_delete_array_long_83_bad::~CWE415_Double_Free__new_delete_array_long_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_long_83_goodB2G	CWE415_Double_Free__new_delete_array_long_83_goodB2G::CWE415_Double_Free__new_delete_array_long_83_goodB2G(long * dataCopy) {     data = dataCopy;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_long_83_goodB2G	CWE415_Double_Free__new_delete_array_long_83_goodB2G::~CWE415_Double_Free__new_delete_array_long_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_long_83_goodG2B	CWE415_Double_Free__new_delete_array_long_83_goodG2B::CWE415_Double_Free__new_delete_array_long_83_goodG2B(long * dataCopy) {     data = dataCopy;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_long_83_goodG2B	CWE415_Double_Free__new_delete_array_long_83_goodG2B::~CWE415_Double_Free__new_delete_array_long_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_long_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_long_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_long_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_array_long_84_bad	CWE415_Double_Free__new_delete_array_long_84_bad::CWE415_Double_Free__new_delete_array_long_84_bad(long * dataCopy) {     data = dataCopy;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_long_84_bad	CWE415_Double_Free__new_delete_array_long_84_bad::~CWE415_Double_Free__new_delete_array_long_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_long_84_goodB2G	CWE415_Double_Free__new_delete_array_long_84_goodB2G::CWE415_Double_Free__new_delete_array_long_84_goodB2G(long * dataCopy) {     data = dataCopy;     data = new long[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_long_84_goodB2G	CWE415_Double_Free__new_delete_array_long_84_goodB2G::~CWE415_Double_Free__new_delete_array_long_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_long_84_goodG2B	CWE415_Double_Free__new_delete_array_long_84_goodG2B::CWE415_Double_Free__new_delete_array_long_84_goodG2B(long * dataCopy) {     data = dataCopy;     data = new long[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_long_84_goodG2B	CWE415_Double_Free__new_delete_array_long_84_goodG2B::~CWE415_Double_Free__new_delete_array_long_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_long_84_bad * badObject = new CWE415_Double_Free__new_delete_array_long_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_long_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_array_long_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_long_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_array_long_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
1	bad	void bad() {     int i,j;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(twoIntsStruct * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1Sink	void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(twoIntsStruct * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = new twoIntsStruct[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = new twoIntsStruct[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         twoIntsStruct * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSource	static twoIntsStruct * badSource(twoIntsStruct * data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(twoIntsStruct * &data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static void goodG2BSource(twoIntsStruct * &data) {     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static void goodB2GSource(twoIntsStruct * &data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	static void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_e	void goodG2BSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_e	void goodB2GSink_e(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	twoIntsStruct * badSource(twoIntsStruct * data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodG2BSource	twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodB2GSource	twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(twoIntsStruct * &data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodG2BSource	void goodG2BSource(twoIntsStruct * &data) {     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodB2GSource	void goodB2GSource(twoIntsStruct * &data) {     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_struct_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_struct_81_goodB2G::action(twoIntsStruct * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_struct_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_struct_81_base& o = CWE415_Double_Free__new_delete_array_struct_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     const CWE415_Double_Free__new_delete_array_struct_81_base& baseObject = CWE415_Double_Free__new_delete_array_struct_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_struct_81_base& baseObject = CWE415_Double_Free__new_delete_array_struct_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_array_struct_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_struct_82_goodB2G::action(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_struct_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_struct_82_base* baseObject = new CWE415_Double_Free__new_delete_array_struct_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     CWE415_Double_Free__new_delete_array_struct_82_base* baseObject = new CWE415_Double_Free__new_delete_array_struct_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_struct_82_base* baseObject = new CWE415_Double_Free__new_delete_array_struct_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_array_struct_83_bad	CWE415_Double_Free__new_delete_array_struct_83_bad::CWE415_Double_Free__new_delete_array_struct_83_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_struct_83_bad	CWE415_Double_Free__new_delete_array_struct_83_bad::~CWE415_Double_Free__new_delete_array_struct_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_struct_83_goodB2G	CWE415_Double_Free__new_delete_array_struct_83_goodB2G::CWE415_Double_Free__new_delete_array_struct_83_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_struct_83_goodB2G	CWE415_Double_Free__new_delete_array_struct_83_goodB2G::~CWE415_Double_Free__new_delete_array_struct_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_struct_83_goodG2B	CWE415_Double_Free__new_delete_array_struct_83_goodG2B::CWE415_Double_Free__new_delete_array_struct_83_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_struct_83_goodG2B	CWE415_Double_Free__new_delete_array_struct_83_goodG2B::~CWE415_Double_Free__new_delete_array_struct_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_struct_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_struct_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_struct_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_array_struct_84_bad	CWE415_Double_Free__new_delete_array_struct_84_bad::CWE415_Double_Free__new_delete_array_struct_84_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_struct_84_bad	CWE415_Double_Free__new_delete_array_struct_84_bad::~CWE415_Double_Free__new_delete_array_struct_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_struct_84_goodB2G	CWE415_Double_Free__new_delete_array_struct_84_goodB2G::CWE415_Double_Free__new_delete_array_struct_84_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_struct_84_goodB2G	CWE415_Double_Free__new_delete_array_struct_84_goodB2G::~CWE415_Double_Free__new_delete_array_struct_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_struct_84_goodG2B	CWE415_Double_Free__new_delete_array_struct_84_goodG2B::CWE415_Double_Free__new_delete_array_struct_84_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_struct_84_goodG2B	CWE415_Double_Free__new_delete_array_struct_84_goodG2B::~CWE415_Double_Free__new_delete_array_struct_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_struct_84_bad * badObject = new CWE415_Double_Free__new_delete_array_struct_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_struct_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_array_struct_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_struct_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_array_struct_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     else     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;         break;     } }
1	bad	void bad() {     int i,j;     wchar_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(wchar_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G1Sink	void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(wchar_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = new wchar_t[100];         /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = new wchar_t[100];         /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */         delete [] data;         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     {         wchar_t * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete [] data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSource	static wchar_t * badSource(wchar_t * data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * data) {     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static wchar_t * goodB2GSource(wchar_t * data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(wchar_t * &data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSource	static void goodG2BSource(wchar_t * &data) {     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSource	static void goodB2GSource(wchar_t * &data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	static void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink_e	void goodG2BSink_e(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink_e	void goodB2GSink_e(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	wchar_t * badSource(wchar_t * data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
0	goodG2BSource	wchar_t * goodG2BSource(wchar_t * data) {     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     return data; }
0	goodB2GSource	wchar_t * goodB2GSource(wchar_t * data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     return data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(wchar_t * &data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	goodG2BSource	void goodG2BSource(wchar_t * &data) {     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	goodB2GSource	void goodB2GSource(wchar_t * &data) {     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     funcPtr(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink() {     wchar_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_wchar_t_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_wchar_t_81_goodB2G::action(wchar_t * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_wchar_t_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_wchar_t_81_base& o = CWE415_Double_Free__new_delete_array_wchar_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     const CWE415_Double_Free__new_delete_array_wchar_t_81_base& baseObject = CWE415_Double_Free__new_delete_array_wchar_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     const CWE415_Double_Free__new_delete_array_wchar_t_81_base& baseObject = CWE415_Double_Free__new_delete_array_wchar_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_array_wchar_t_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	action	void CWE415_Double_Free__new_delete_array_wchar_t_82_goodB2G::action(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_array_wchar_t_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_wchar_t_82_base* baseObject = new CWE415_Double_Free__new_delete_array_wchar_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */     CWE415_Double_Free__new_delete_array_wchar_t_82_base* baseObject = new CWE415_Double_Free__new_delete_array_wchar_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data;     CWE415_Double_Free__new_delete_array_wchar_t_82_base* baseObject = new CWE415_Double_Free__new_delete_array_wchar_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_array_wchar_t_83_bad	CWE415_Double_Free__new_delete_array_wchar_t_83_bad::CWE415_Double_Free__new_delete_array_wchar_t_83_bad(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_wchar_t_83_bad	CWE415_Double_Free__new_delete_array_wchar_t_83_bad::~CWE415_Double_Free__new_delete_array_wchar_t_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_wchar_t_83_goodB2G	CWE415_Double_Free__new_delete_array_wchar_t_83_goodB2G::CWE415_Double_Free__new_delete_array_wchar_t_83_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_wchar_t_83_goodB2G	CWE415_Double_Free__new_delete_array_wchar_t_83_goodB2G::~CWE415_Double_Free__new_delete_array_wchar_t_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_wchar_t_83_goodG2B	CWE415_Double_Free__new_delete_array_wchar_t_83_goodG2B::CWE415_Double_Free__new_delete_array_wchar_t_83_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_wchar_t_83_goodG2B	CWE415_Double_Free__new_delete_array_wchar_t_83_goodG2B::~CWE415_Double_Free__new_delete_array_wchar_t_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_wchar_t_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_wchar_t_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_wchar_t_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_array_wchar_t_84_bad	CWE415_Double_Free__new_delete_array_wchar_t_84_bad::CWE415_Double_Free__new_delete_array_wchar_t_84_bad(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
1	~CWE415_Double_Free__new_delete_array_wchar_t_84_bad	CWE415_Double_Free__new_delete_array_wchar_t_84_bad::~CWE415_Double_Free__new_delete_array_wchar_t_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
0	CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G	CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G::CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t[100];     /* POTENTIAL FLAW: delete the array data in the source - the bad sink deletes the array data as well */     delete [] data; }
0	~CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G	CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G::~CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B	CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B::CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t[100];     /* FIX: Do NOT delete the array data in the source - the bad sink deletes the array data */ }
0	~CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B	CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B::~CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete [] data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_wchar_t_84_bad * badObject = new CWE415_Double_Free__new_delete_array_wchar_t_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_array_wchar_t_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_array_wchar_t_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     char * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
1	bad	void bad() {     int i,j;     char * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     char * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     char * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	badSink	static void badSink(char * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(char * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(char * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(char * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1Sink	void goodB2G1Sink(char * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(char * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(char * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         char * dataCopy = data;         char * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         char * dataCopy = data;         char * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = new char;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     char * data;     char * *dataPtr1 = &data;     char * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         char * data = *dataPtr1;         data = new char;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         char * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         char * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         char * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     char * data;     char * &dataRef = data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         char * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     char * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     char * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     char * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         char * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSource	static char * badSource(char * data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static char * goodG2BSource(char * data) {     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static char * goodB2GSource(char * data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(char * &data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static void goodG2BSource(char * &data) {     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static void goodB2GSource(char * &data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	static void badSink() {     char * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     char * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(char * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(char * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(char * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(char * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(char * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(char * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(char * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(char * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(char * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_e	void goodG2BSink_e(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_e	void goodB2GSink_e(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	char * badSource(char * data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodG2BSource	char * goodG2BSource(char * data) {     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodB2GSource	char * goodB2GSource(char * data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(char * &data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodG2BSource	void goodG2BSource(char * &data) {     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodB2GSource	void goodB2GSource(char * &data) {     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(char * * dataPtr) {     char * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(char * * dataPtr) {     char * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     char * * dataPtr = (char * *)dataVoidPtr;     /* dereference dataPtr into data */     char * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* define a function pointer */     void (*funcPtr) (char *) = badSink;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     char * data;     void (*funcPtr) (char *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     char * data;     void (*funcPtr) (char *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	void badSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     char * data;     char * dataArray[5];     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(char * dataArray[]) {     /* copy data out of dataArray */     char * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(char * dataArray[]) {     char * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(char * dataArray[]) {     char * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     char * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     char * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     char * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     char * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     char * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink() {     char * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink() {     char * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     char * data;     vector<char *> dataVector;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<char *> dataVector) {     /* copy data out of dataVector */     char * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(vector<char *> dataVector) {     char * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     char * data;     list<char *> dataList;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<char *> dataList) {     /* copy data out of dataList */     char * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(list<char *> dataList) {     char * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(list<char *> dataList) {     char * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     char * data;     map<int, char *> dataMap;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, char *> dataMap) {     /* copy data out of dataMap */     char * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(map<int, char *> dataMap) {     char * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_char_81_bad::action(char * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_char_81_goodB2G::action(char * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_char_81_goodG2B::action(char * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_char_81_base& o = CWE415_Double_Free__new_delete_char_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     const CWE415_Double_Free__new_delete_char_81_base& baseObject = CWE415_Double_Free__new_delete_char_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_char_81_base& baseObject = CWE415_Double_Free__new_delete_char_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_char_82_bad::action(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_char_82_goodB2G::action(char * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_char_82_goodG2B::action(char * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_char_82_base* baseObject = new CWE415_Double_Free__new_delete_char_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     CWE415_Double_Free__new_delete_char_82_base* baseObject = new CWE415_Double_Free__new_delete_char_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_char_82_base* baseObject = new CWE415_Double_Free__new_delete_char_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_char_83_bad	CWE415_Double_Free__new_delete_char_83_bad::CWE415_Double_Free__new_delete_char_83_bad(char * dataCopy) {     data = dataCopy;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_char_83_bad	CWE415_Double_Free__new_delete_char_83_bad::~CWE415_Double_Free__new_delete_char_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_char_83_goodB2G	CWE415_Double_Free__new_delete_char_83_goodB2G::CWE415_Double_Free__new_delete_char_83_goodB2G(char * dataCopy) {     data = dataCopy;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_char_83_goodB2G	CWE415_Double_Free__new_delete_char_83_goodB2G::~CWE415_Double_Free__new_delete_char_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_char_83_goodG2B	CWE415_Double_Free__new_delete_char_83_goodG2B::CWE415_Double_Free__new_delete_char_83_goodG2B(char * dataCopy) {     data = dataCopy;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_char_83_goodG2B	CWE415_Double_Free__new_delete_char_83_goodG2B::~CWE415_Double_Free__new_delete_char_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_char_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_char_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_char_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_char_84_bad	CWE415_Double_Free__new_delete_char_84_bad::CWE415_Double_Free__new_delete_char_84_bad(char * dataCopy) {     data = dataCopy;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_char_84_bad	CWE415_Double_Free__new_delete_char_84_bad::~CWE415_Double_Free__new_delete_char_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_char_84_goodB2G	CWE415_Double_Free__new_delete_char_84_goodB2G::CWE415_Double_Free__new_delete_char_84_goodB2G(char * dataCopy) {     data = dataCopy;     data = new char;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_char_84_goodB2G	CWE415_Double_Free__new_delete_char_84_goodB2G::~CWE415_Double_Free__new_delete_char_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_char_84_goodG2B	CWE415_Double_Free__new_delete_char_84_goodG2B::CWE415_Double_Free__new_delete_char_84_goodG2B(char * dataCopy) {     data = dataCopy;     data = new char;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_char_84_goodG2B	CWE415_Double_Free__new_delete_char_84_goodG2B::~CWE415_Double_Free__new_delete_char_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_char_84_bad * badObject = new CWE415_Double_Free__new_delete_char_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_char_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_char_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     char * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_char_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_char_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
1	bad	void bad() {     int i,j;     TwoIntsClass * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     TwoIntsClass * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     TwoIntsClass * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	badSink	static void badSink(TwoIntsClass * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(TwoIntsClass * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1Sink	void goodB2G1Sink(TwoIntsClass * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(TwoIntsClass * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(TwoIntsClass * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         TwoIntsClass * dataCopy = data;         TwoIntsClass * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         data = new TwoIntsClass;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * *dataPtr1 = &data;     TwoIntsClass * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         TwoIntsClass * data = *dataPtr1;         data = new TwoIntsClass;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         TwoIntsClass * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         TwoIntsClass * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * &dataRef = data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         TwoIntsClass * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     TwoIntsClass * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         TwoIntsClass * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSource	static TwoIntsClass * badSource(TwoIntsClass * data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static TwoIntsClass * goodG2BSource(TwoIntsClass * data) {     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static TwoIntsClass * goodB2GSource(TwoIntsClass * data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(TwoIntsClass * &data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static void goodG2BSource(TwoIntsClass * &data) {     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static void goodB2GSource(TwoIntsClass * &data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	static void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(TwoIntsClass * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(TwoIntsClass * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(TwoIntsClass * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(TwoIntsClass * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(TwoIntsClass * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(TwoIntsClass * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(TwoIntsClass * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(TwoIntsClass * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(TwoIntsClass * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_e	void goodG2BSink_e(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_e	void goodB2GSink_e(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	TwoIntsClass * badSource(TwoIntsClass * data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodG2BSource	TwoIntsClass * goodG2BSource(TwoIntsClass * data) {     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodB2GSource	TwoIntsClass * goodB2GSource(TwoIntsClass * data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(TwoIntsClass * &data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodG2BSource	void goodG2BSource(TwoIntsClass * &data) {     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodB2GSource	void goodB2GSource(TwoIntsClass * &data) {     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * * dataPtr) {     TwoIntsClass * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;     /* dereference dataPtr into data */     TwoIntsClass * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* define a function pointer */     void (*funcPtr) (TwoIntsClass *) = badSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     void (*funcPtr) (TwoIntsClass *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	void badSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     TwoIntsClass * dataArray[5];     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(TwoIntsClass * dataArray[]) {     /* copy data out of dataArray */     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(TwoIntsClass * dataArray[]) {     TwoIntsClass * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     TwoIntsClass * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     TwoIntsClass * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink() {     TwoIntsClass * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink() {     TwoIntsClass * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     vector<TwoIntsClass *> dataVector;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<TwoIntsClass *> dataVector) {     /* copy data out of dataVector */     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(vector<TwoIntsClass *> dataVector) {     TwoIntsClass * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     list<TwoIntsClass *> dataList;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<TwoIntsClass *> dataList) {     /* copy data out of dataList */     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(list<TwoIntsClass *> dataList) {     TwoIntsClass * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     map<int, TwoIntsClass *> dataMap;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, TwoIntsClass *> dataMap) {     /* copy data out of dataMap */     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(map<int, TwoIntsClass *> dataMap) {     TwoIntsClass * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_class_81_bad::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_class_81_goodB2G::action(TwoIntsClass * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_class_81_goodG2B::action(TwoIntsClass * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_class_81_base& o = CWE415_Double_Free__new_delete_class_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     const CWE415_Double_Free__new_delete_class_81_base& baseObject = CWE415_Double_Free__new_delete_class_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_class_81_base& baseObject = CWE415_Double_Free__new_delete_class_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_class_82_bad::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_class_82_goodB2G::action(TwoIntsClass * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_class_82_goodG2B::action(TwoIntsClass * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_class_82_base* baseObject = new CWE415_Double_Free__new_delete_class_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     CWE415_Double_Free__new_delete_class_82_base* baseObject = new CWE415_Double_Free__new_delete_class_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_class_82_base* baseObject = new CWE415_Double_Free__new_delete_class_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_class_83_bad	CWE415_Double_Free__new_delete_class_83_bad::CWE415_Double_Free__new_delete_class_83_bad(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_class_83_bad	CWE415_Double_Free__new_delete_class_83_bad::~CWE415_Double_Free__new_delete_class_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_class_83_goodB2G	CWE415_Double_Free__new_delete_class_83_goodB2G::CWE415_Double_Free__new_delete_class_83_goodB2G(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_class_83_goodB2G	CWE415_Double_Free__new_delete_class_83_goodB2G::~CWE415_Double_Free__new_delete_class_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_class_83_goodG2B	CWE415_Double_Free__new_delete_class_83_goodG2B::CWE415_Double_Free__new_delete_class_83_goodG2B(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_class_83_goodG2B	CWE415_Double_Free__new_delete_class_83_goodG2B::~CWE415_Double_Free__new_delete_class_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_class_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_class_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_class_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_class_84_bad	CWE415_Double_Free__new_delete_class_84_bad::CWE415_Double_Free__new_delete_class_84_bad(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_class_84_bad	CWE415_Double_Free__new_delete_class_84_bad::~CWE415_Double_Free__new_delete_class_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_class_84_goodB2G	CWE415_Double_Free__new_delete_class_84_goodB2G::CWE415_Double_Free__new_delete_class_84_goodB2G(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_class_84_goodB2G	CWE415_Double_Free__new_delete_class_84_goodB2G::~CWE415_Double_Free__new_delete_class_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_class_84_goodG2B	CWE415_Double_Free__new_delete_class_84_goodG2B::CWE415_Double_Free__new_delete_class_84_goodG2B(TwoIntsClass * dataCopy) {     data = dataCopy;     data = new TwoIntsClass;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_class_84_goodG2B	CWE415_Double_Free__new_delete_class_84_goodG2B::~CWE415_Double_Free__new_delete_class_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_class_84_bad * badObject = new CWE415_Double_Free__new_delete_class_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_class_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_class_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     TwoIntsClass * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_class_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_class_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int64_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
1	bad	void bad() {     int i,j;     int64_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     int64_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     int64_t * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	badSink	static void badSink(int64_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int64_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int64_t * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int64_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1Sink	void goodB2G1Sink(int64_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(int64_t * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(int64_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int64_t * dataCopy = data;         int64_t * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = new int64_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * *dataPtr1 = &data;     int64_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int64_t * data = *dataPtr1;         data = new int64_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         int64_t * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         int64_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int64_t * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int64_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int64_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int64_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         int64_t * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSource	static int64_t * badSource(int64_t * data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static int64_t * goodG2BSource(int64_t * data) {     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static int64_t * goodB2GSource(int64_t * data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int64_t * &data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static void goodG2BSource(int64_t * &data) {     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static void goodB2GSource(int64_t * &data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	static void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int64_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int64_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int64_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int64_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int64_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int64_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int64_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int64_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int64_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int64_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_e	void goodG2BSink_e(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_e	void goodB2GSink_e(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	int64_t * badSource(int64_t * data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodG2BSource	int64_t * goodG2BSource(int64_t * data) {     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodB2GSource	int64_t * goodB2GSource(int64_t * data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int64_t * &data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodG2BSource	void goodG2BSource(int64_t * &data) {     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodB2GSource	void goodB2GSource(int64_t * &data) {     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int64_t * * dataPtr) {     int64_t * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int64_t * * dataPtr = (int64_t * *)dataVoidPtr;     /* dereference dataPtr into data */     int64_t * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* define a function pointer */     void (*funcPtr) (int64_t *) = badSink;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     void (*funcPtr) (int64_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	void badSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int64_t * data;     int64_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int64_t * dataArray[]) {     /* copy data out of dataArray */     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int64_t * dataArray[]) {     int64_t * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int64_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int64_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int64_t * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int64_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink() {     int64_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink() {     int64_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int64_t * data;     vector<int64_t *> dataVector;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int64_t *> dataVector) {     /* copy data out of dataVector */     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(vector<int64_t *> dataVector) {     int64_t * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int64_t * data;     list<int64_t *> dataList;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int64_t *> dataList) {     /* copy data out of dataList */     int64_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(list<int64_t *> dataList) {     int64_t * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int64_t * data;     map<int, int64_t *> dataMap;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int64_t *> dataMap) {     /* copy data out of dataMap */     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(map<int, int64_t *> dataMap) {     int64_t * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_int64_t_81_bad::action(int64_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_int64_t_81_goodB2G::action(int64_t * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_int64_t_81_goodG2B::action(int64_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_int64_t_81_base& o = CWE415_Double_Free__new_delete_int64_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     const CWE415_Double_Free__new_delete_int64_t_81_base& baseObject = CWE415_Double_Free__new_delete_int64_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_int64_t_81_base& baseObject = CWE415_Double_Free__new_delete_int64_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_int64_t_82_bad::action(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_int64_t_82_goodB2G::action(int64_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_int64_t_82_goodG2B::action(int64_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_int64_t_82_base* baseObject = new CWE415_Double_Free__new_delete_int64_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     CWE415_Double_Free__new_delete_int64_t_82_base* baseObject = new CWE415_Double_Free__new_delete_int64_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_int64_t_82_base* baseObject = new CWE415_Double_Free__new_delete_int64_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_int64_t_83_bad	CWE415_Double_Free__new_delete_int64_t_83_bad::CWE415_Double_Free__new_delete_int64_t_83_bad(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_int64_t_83_bad	CWE415_Double_Free__new_delete_int64_t_83_bad::~CWE415_Double_Free__new_delete_int64_t_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_int64_t_83_goodB2G	CWE415_Double_Free__new_delete_int64_t_83_goodB2G::CWE415_Double_Free__new_delete_int64_t_83_goodB2G(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_int64_t_83_goodB2G	CWE415_Double_Free__new_delete_int64_t_83_goodB2G::~CWE415_Double_Free__new_delete_int64_t_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_int64_t_83_goodG2B	CWE415_Double_Free__new_delete_int64_t_83_goodG2B::CWE415_Double_Free__new_delete_int64_t_83_goodG2B(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_int64_t_83_goodG2B	CWE415_Double_Free__new_delete_int64_t_83_goodG2B::~CWE415_Double_Free__new_delete_int64_t_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int64_t_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int64_t_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int64_t_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_int64_t_84_bad	CWE415_Double_Free__new_delete_int64_t_84_bad::CWE415_Double_Free__new_delete_int64_t_84_bad(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_int64_t_84_bad	CWE415_Double_Free__new_delete_int64_t_84_bad::~CWE415_Double_Free__new_delete_int64_t_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_int64_t_84_goodB2G	CWE415_Double_Free__new_delete_int64_t_84_goodB2G::CWE415_Double_Free__new_delete_int64_t_84_goodB2G(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_int64_t_84_goodB2G	CWE415_Double_Free__new_delete_int64_t_84_goodB2G::~CWE415_Double_Free__new_delete_int64_t_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_int64_t_84_goodG2B	CWE415_Double_Free__new_delete_int64_t_84_goodG2B::CWE415_Double_Free__new_delete_int64_t_84_goodG2B(int64_t * dataCopy) {     data = dataCopy;     data = new int64_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_int64_t_84_goodG2B	CWE415_Double_Free__new_delete_int64_t_84_goodG2B::~CWE415_Double_Free__new_delete_int64_t_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int64_t_84_bad * badObject = new CWE415_Double_Free__new_delete_int64_t_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int64_t_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_int64_t_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int64_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int64_t_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_int64_t_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     int * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
1	bad	void bad() {     int i,j;     int * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     int * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     int * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	badSink	static void badSink(int * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(int * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(int * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(int * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1Sink	void goodB2G1Sink(int * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(int * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(int * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         int * dataCopy = data;         int * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int * dataCopy = data;         int * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = new int;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int * data;     int * *dataPtr1 = &data;     int * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         int * data = *dataPtr1;         data = new int;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         int * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         int * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int * data;     int * &dataRef = data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         int * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     int * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     int * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         int * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSource	static int * badSource(int * data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static int * goodG2BSource(int * data) {     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static int * goodB2GSource(int * data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int * &data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static void goodG2BSource(int * &data) {     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static void goodB2GSource(int * &data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	static void badSink() {     int * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     int * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(int * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(int * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(int * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(int * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(int * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(int * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(int * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(int * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(int * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_e	void goodG2BSink_e(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_e	void goodB2GSink_e(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	int * badSource(int * data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodG2BSource	int * goodG2BSource(int * data) {     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodB2GSource	int * goodB2GSource(int * data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(int * &data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodG2BSource	void goodG2BSource(int * &data) {     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodB2GSource	void goodB2GSource(int * &data) {     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int * * dataPtr) {     int * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int * * dataPtr) {     int * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     int * * dataPtr = (int * *)dataVoidPtr;     /* dereference dataPtr into data */     int * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* define a function pointer */     void (*funcPtr) (int *) = badSink;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     int * data;     void (*funcPtr) (int *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     int * data;     void (*funcPtr) (int *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	void badSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     int * data;     int * dataArray[5];     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(int * dataArray[]) {     /* copy data out of dataArray */     int * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(int * dataArray[]) {     int * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(int * dataArray[]) {     int * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     int * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     int * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     int * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     int * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     int * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink() {     int * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink() {     int * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     int * data;     vector<int *> dataVector;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<int *> dataVector) {     /* copy data out of dataVector */     int * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(vector<int *> dataVector) {     int * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     int * data;     list<int *> dataList;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<int *> dataList) {     /* copy data out of dataList */     int * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(list<int *> dataList) {     int * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(list<int *> dataList) {     int * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     int * data;     map<int, int *> dataMap;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, int *> dataMap) {     /* copy data out of dataMap */     int * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(map<int, int *> dataMap) {     int * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_int_81_bad::action(int * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_int_81_goodB2G::action(int * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_int_81_goodG2B::action(int * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_int_81_base& o = CWE415_Double_Free__new_delete_int_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     const CWE415_Double_Free__new_delete_int_81_base& baseObject = CWE415_Double_Free__new_delete_int_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_int_81_base& baseObject = CWE415_Double_Free__new_delete_int_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_int_82_bad::action(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_int_82_goodB2G::action(int * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_int_82_goodG2B::action(int * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_int_82_base* baseObject = new CWE415_Double_Free__new_delete_int_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     CWE415_Double_Free__new_delete_int_82_base* baseObject = new CWE415_Double_Free__new_delete_int_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_int_82_base* baseObject = new CWE415_Double_Free__new_delete_int_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_int_83_bad	CWE415_Double_Free__new_delete_int_83_bad::CWE415_Double_Free__new_delete_int_83_bad(int * dataCopy) {     data = dataCopy;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_int_83_bad	CWE415_Double_Free__new_delete_int_83_bad::~CWE415_Double_Free__new_delete_int_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_int_83_goodB2G	CWE415_Double_Free__new_delete_int_83_goodB2G::CWE415_Double_Free__new_delete_int_83_goodB2G(int * dataCopy) {     data = dataCopy;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_int_83_goodB2G	CWE415_Double_Free__new_delete_int_83_goodB2G::~CWE415_Double_Free__new_delete_int_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_int_83_goodG2B	CWE415_Double_Free__new_delete_int_83_goodG2B::CWE415_Double_Free__new_delete_int_83_goodG2B(int * dataCopy) {     data = dataCopy;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_int_83_goodG2B	CWE415_Double_Free__new_delete_int_83_goodG2B::~CWE415_Double_Free__new_delete_int_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_int_84_bad	CWE415_Double_Free__new_delete_int_84_bad::CWE415_Double_Free__new_delete_int_84_bad(int * dataCopy) {     data = dataCopy;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_int_84_bad	CWE415_Double_Free__new_delete_int_84_bad::~CWE415_Double_Free__new_delete_int_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_int_84_goodB2G	CWE415_Double_Free__new_delete_int_84_goodB2G::CWE415_Double_Free__new_delete_int_84_goodB2G(int * dataCopy) {     data = dataCopy;     data = new int;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_int_84_goodB2G	CWE415_Double_Free__new_delete_int_84_goodB2G::~CWE415_Double_Free__new_delete_int_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_int_84_goodG2B	CWE415_Double_Free__new_delete_int_84_goodG2B::CWE415_Double_Free__new_delete_int_84_goodG2B(int * dataCopy) {     data = dataCopy;     data = new int;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_int_84_goodG2B	CWE415_Double_Free__new_delete_int_84_goodG2B::~CWE415_Double_Free__new_delete_int_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int_84_bad * badObject = new CWE415_Double_Free__new_delete_int_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_int_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     int * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_int_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_int_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     long * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
1	bad	void bad() {     int i,j;     long * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     long * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     long * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	badSink	static void badSink(long * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(long * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(long * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(long * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1Sink	void goodB2G1Sink(long * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(long * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(long * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         long * dataCopy = data;         long * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         long * dataCopy = data;         long * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         long * dataCopy = data;         long * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = new long;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     long * data;     long * *dataPtr1 = &data;     long * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         long * data = *dataPtr1;         data = new long;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         long * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         long * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         long * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     long * data;     long * &dataRef = data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         long * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     long * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     long * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     long * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         long * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSource	static long * badSource(long * data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static long * goodG2BSource(long * data) {     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static long * goodB2GSource(long * data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(long * &data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static void goodG2BSource(long * &data) {     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static void goodB2GSource(long * &data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     long * data;     /* define a function pointer */     void (*funcPtr) (long *) = badSink;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     long * data;     void (*funcPtr) (long *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     void (*funcPtr) (long *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	static void badSink() {     long * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     long * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     long * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSink	void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(long * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(long * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(long * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_c	void goodG2BSink_c(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_c	void goodB2GSink_c(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(long * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(long * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(long * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(long * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(long * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(long * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_d	void goodG2BSink_d(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_d	void goodB2GSink_d(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(long * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(long * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(long * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(long * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(long * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(long * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(long * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(long * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(long * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_e	void goodG2BSink_e(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_e	void goodB2GSink_e(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	long * badSource(long * data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodG2BSource	long * goodG2BSource(long * data) {     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodB2GSource	long * goodB2GSource(long * data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(long * &data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodG2BSource	void goodG2BSource(long * &data) {     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodB2GSource	void goodB2GSource(long * &data) {     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(long * * dataPtr) {     long * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(long * * dataPtr) {     long * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(long * * dataPtr) {     long * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     long * * dataPtr = (long * *)dataVoidPtr;     /* dereference dataPtr into data */     long * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* define a function pointer */     void (*funcPtr) (long *) = badSink;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     long * data;     void (*funcPtr) (long *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     long * data;     void (*funcPtr) (long *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	void badSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     long * data;     long * dataArray[5];     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(long * dataArray[]) {     /* copy data out of dataArray */     long * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(long * dataArray[]) {     long * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(long * dataArray[]) {     long * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     long * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     long * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     long * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     long * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     long * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     long * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink() {     long * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink() {     long * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     long * data;     vector<long *> dataVector;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<long *> dataVector) {     /* copy data out of dataVector */     long * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(vector<long *> dataVector) {     long * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(vector<long *> dataVector) {     long * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     long * data;     list<long *> dataList;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<long *> dataList) {     /* copy data out of dataList */     long * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(list<long *> dataList) {     long * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(list<long *> dataList) {     long * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     long * data;     map<int, long *> dataMap;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, long *> dataMap) {     /* copy data out of dataMap */     long * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(map<int, long *> dataMap) {     long * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(map<int, long *> dataMap) {     long * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_long_81_bad::action(long * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_long_81_goodB2G::action(long * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_long_81_goodG2B::action(long * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_long_81_base& o = CWE415_Double_Free__new_delete_long_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     const CWE415_Double_Free__new_delete_long_81_base& baseObject = CWE415_Double_Free__new_delete_long_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_long_81_base& baseObject = CWE415_Double_Free__new_delete_long_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_long_82_bad::action(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_long_82_goodB2G::action(long * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_long_82_goodG2B::action(long * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_long_82_base* baseObject = new CWE415_Double_Free__new_delete_long_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     CWE415_Double_Free__new_delete_long_82_base* baseObject = new CWE415_Double_Free__new_delete_long_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_long_82_base* baseObject = new CWE415_Double_Free__new_delete_long_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_long_83_bad	CWE415_Double_Free__new_delete_long_83_bad::CWE415_Double_Free__new_delete_long_83_bad(long * dataCopy) {     data = dataCopy;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_long_83_bad	CWE415_Double_Free__new_delete_long_83_bad::~CWE415_Double_Free__new_delete_long_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_long_83_goodB2G	CWE415_Double_Free__new_delete_long_83_goodB2G::CWE415_Double_Free__new_delete_long_83_goodB2G(long * dataCopy) {     data = dataCopy;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_long_83_goodB2G	CWE415_Double_Free__new_delete_long_83_goodB2G::~CWE415_Double_Free__new_delete_long_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_long_83_goodG2B	CWE415_Double_Free__new_delete_long_83_goodG2B::CWE415_Double_Free__new_delete_long_83_goodG2B(long * dataCopy) {     data = dataCopy;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_long_83_goodG2B	CWE415_Double_Free__new_delete_long_83_goodG2B::~CWE415_Double_Free__new_delete_long_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_long_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_long_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_long_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_long_84_bad	CWE415_Double_Free__new_delete_long_84_bad::CWE415_Double_Free__new_delete_long_84_bad(long * dataCopy) {     data = dataCopy;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_long_84_bad	CWE415_Double_Free__new_delete_long_84_bad::~CWE415_Double_Free__new_delete_long_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_long_84_goodB2G	CWE415_Double_Free__new_delete_long_84_goodB2G::CWE415_Double_Free__new_delete_long_84_goodB2G(long * dataCopy) {     data = dataCopy;     data = new long;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_long_84_goodB2G	CWE415_Double_Free__new_delete_long_84_goodB2G::~CWE415_Double_Free__new_delete_long_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_long_84_goodG2B	CWE415_Double_Free__new_delete_long_84_goodG2B::CWE415_Double_Free__new_delete_long_84_goodG2B(long * dataCopy) {     data = dataCopy;     data = new long;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_long_84_goodG2B	CWE415_Double_Free__new_delete_long_84_goodG2B::~CWE415_Double_Free__new_delete_long_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_long_84_bad * badObject = new CWE415_Double_Free__new_delete_long_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_long_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_long_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     long * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_long_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_long_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
1	bad	void bad() {     int i,j;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     twoIntsStruct * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	badSink	static void badSink(twoIntsStruct * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(twoIntsStruct * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1Sink	void goodB2G1Sink(twoIntsStruct * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(twoIntsStruct * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(twoIntsStruct * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         twoIntsStruct * dataCopy = data;         twoIntsStruct * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = new twoIntsStruct;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * *dataPtr1 = &data;     twoIntsStruct * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         twoIntsStruct * data = *dataPtr1;         data = new twoIntsStruct;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         twoIntsStruct * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         twoIntsStruct * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * &dataRef = data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         twoIntsStruct * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     twoIntsStruct * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         twoIntsStruct * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSource	static twoIntsStruct * badSource(twoIntsStruct * data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(twoIntsStruct * &data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static void goodG2BSource(twoIntsStruct * &data) {     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static void goodB2GSource(twoIntsStruct * &data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	static void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(twoIntsStruct * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(twoIntsStruct * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(twoIntsStruct * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(twoIntsStruct * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(twoIntsStruct * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(twoIntsStruct * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(twoIntsStruct * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(twoIntsStruct * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(twoIntsStruct * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_e	void goodG2BSink_e(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_e	void goodB2GSink_e(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	twoIntsStruct * badSource(twoIntsStruct * data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodG2BSource	twoIntsStruct * goodG2BSource(twoIntsStruct * data) {     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodB2GSource	twoIntsStruct * goodB2GSource(twoIntsStruct * data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(twoIntsStruct * &data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodG2BSource	void goodG2BSource(twoIntsStruct * &data) {     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodB2GSource	void goodB2GSource(twoIntsStruct * &data) {     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * * dataPtr) {     twoIntsStruct * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr;     /* dereference dataPtr into data */     twoIntsStruct * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* define a function pointer */     void (*funcPtr) (twoIntsStruct *) = badSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     void (*funcPtr) (twoIntsStruct *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	void badSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     twoIntsStruct * dataArray[5];     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(twoIntsStruct * dataArray[]) {     /* copy data out of dataArray */     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(twoIntsStruct * dataArray[]) {     twoIntsStruct * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     twoIntsStruct * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     twoIntsStruct * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink() {     twoIntsStruct * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink() {     twoIntsStruct * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     vector<twoIntsStruct *> dataVector;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<twoIntsStruct *> dataVector) {     /* copy data out of dataVector */     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(vector<twoIntsStruct *> dataVector) {     twoIntsStruct * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     list<twoIntsStruct *> dataList;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<twoIntsStruct *> dataList) {     /* copy data out of dataList */     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(list<twoIntsStruct *> dataList) {     twoIntsStruct * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     map<int, twoIntsStruct *> dataMap;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, twoIntsStruct *> dataMap) {     /* copy data out of dataMap */     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(map<int, twoIntsStruct *> dataMap) {     twoIntsStruct * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_struct_81_bad::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_struct_81_goodB2G::action(twoIntsStruct * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_struct_81_goodG2B::action(twoIntsStruct * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_struct_81_base& o = CWE415_Double_Free__new_delete_struct_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     const CWE415_Double_Free__new_delete_struct_81_base& baseObject = CWE415_Double_Free__new_delete_struct_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_struct_81_base& baseObject = CWE415_Double_Free__new_delete_struct_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_struct_82_bad::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_struct_82_goodB2G::action(twoIntsStruct * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_struct_82_goodG2B::action(twoIntsStruct * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_struct_82_base* baseObject = new CWE415_Double_Free__new_delete_struct_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     CWE415_Double_Free__new_delete_struct_82_base* baseObject = new CWE415_Double_Free__new_delete_struct_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_struct_82_base* baseObject = new CWE415_Double_Free__new_delete_struct_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_struct_83_bad	CWE415_Double_Free__new_delete_struct_83_bad::CWE415_Double_Free__new_delete_struct_83_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_struct_83_bad	CWE415_Double_Free__new_delete_struct_83_bad::~CWE415_Double_Free__new_delete_struct_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_struct_83_goodB2G	CWE415_Double_Free__new_delete_struct_83_goodB2G::CWE415_Double_Free__new_delete_struct_83_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_struct_83_goodB2G	CWE415_Double_Free__new_delete_struct_83_goodB2G::~CWE415_Double_Free__new_delete_struct_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_struct_83_goodG2B	CWE415_Double_Free__new_delete_struct_83_goodG2B::CWE415_Double_Free__new_delete_struct_83_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_struct_83_goodG2B	CWE415_Double_Free__new_delete_struct_83_goodG2B::~CWE415_Double_Free__new_delete_struct_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_struct_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_struct_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_struct_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_struct_84_bad	CWE415_Double_Free__new_delete_struct_84_bad::CWE415_Double_Free__new_delete_struct_84_bad(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_struct_84_bad	CWE415_Double_Free__new_delete_struct_84_bad::~CWE415_Double_Free__new_delete_struct_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_struct_84_goodB2G	CWE415_Double_Free__new_delete_struct_84_goodB2G::CWE415_Double_Free__new_delete_struct_84_goodB2G(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_struct_84_goodB2G	CWE415_Double_Free__new_delete_struct_84_goodB2G::~CWE415_Double_Free__new_delete_struct_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_struct_84_goodG2B	CWE415_Double_Free__new_delete_struct_84_goodG2B::CWE415_Double_Free__new_delete_struct_84_goodG2B(twoIntsStruct * dataCopy) {     data = dataCopy;     data = new twoIntsStruct;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_struct_84_goodG2B	CWE415_Double_Free__new_delete_struct_84_goodG2B::~CWE415_Double_Free__new_delete_struct_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_struct_84_bad * badObject = new CWE415_Double_Free__new_delete_struct_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_struct_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_struct_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     twoIntsStruct * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_struct_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_struct_84_goodB2G(data);     delete goodB2GObject; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(1)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(5==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(5==5)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(5==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_TRUE)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticTrue)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(STATIC_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(STATIC_CONST_FIVE==5)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(STATIC_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticFive==5)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(staticReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(staticReturnsTrue())     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(staticReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_TRUE)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_TRUE)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_TRUE)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalTrue)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalTrue)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalTrue)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrue())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrue())     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrue())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     else     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalReturnsTrueOrFalse())     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalReturnsTrueOrFalse())     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalReturnsTrueOrFalse())     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     }     else     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(GLOBAL_CONST_FIVE==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(GLOBAL_CONST_FIVE==5)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(GLOBAL_CONST_FIVE==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     if(globalFive==5)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     if(globalFive==5)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     if(globalFive==5)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(8)     {     case 7:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	goodG2B2	static void goodG2B2() {     wchar_t * data;     /* Initialize data */     data = NULL;     switch(6)     {     case 6:         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     }     switch(7)     {     case 7:         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1();     goodG2B2(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         break;     }     while(1)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */         break;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     while(1)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         break;     }     while(1)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;         break;     } }
1	bad	void bad() {     int i,j;     wchar_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     int i,k;     wchar_t * data;     /* Initialize data */     data = NULL;     for(i = 0; i < 1; i++)     {         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;     }     for(k = 0; k < 1; k++)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B	static void goodG2B() {     int h,j;     wchar_t * data;     /* Initialize data */     data = NULL;     for(h = 0; h < 1; h++)     {         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */     }     for(j = 0; j < 1; j++)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goto sink; sink:     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goto source; source:     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goto sink; sink:     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	badSink	static void badSink(wchar_t * data) {     if(badStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badStatic = 1; /* true */     badSink(data); }
0	goodB2G1Sink	static void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Static)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Static = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2Sink	static void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Static)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Static = 1; /* true */     goodB2G2Sink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     if(goodG2bStatic)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2bStatic = 1; /* true */     goodG2BSink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badGlobal = 1; /* true */     badSink(data); }
0	goodB2G1	static void goodB2G1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G1Global = 0; /* false */     goodB2G1Sink(data); }
0	goodB2G2	static void goodB2G2() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2G2Global = 1; /* true */     goodB2G2Sink(data); }
0	goodG2B1	static void goodG2B1() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2B1Global = 1; /* true */     goodG2B1Sink(data); }
0	good	void good() {     goodB2G1();     goodB2G2();     goodG2B1(); }
1	badSink	void badSink(wchar_t * data) {     if(badGlobal)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G1Sink	void goodB2G1Sink(wchar_t * data) {     if(goodB2G1Global)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodB2G2Sink	void goodB2G2Sink(wchar_t * data) {     if(goodB2G2Global)     {         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
0	goodG2B1Sink	void goodG2B1Sink(wchar_t * data) {     if(goodG2B1Global)     {         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         wchar_t * dataCopy = data;         wchar_t * data = dataCopy;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = new wchar_t;         /* FIX: Do NOT delete data in the source - the bad sink deletes data */         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * *dataPtr1 = &data;     wchar_t * *dataPtr2 = &data;     /* Initialize data */     data = NULL;     {         wchar_t * data = *dataPtr1;         data = new wchar_t;         /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */         delete data;         *dataPtr1 = data;     }     {         wchar_t * data = *dataPtr2;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     {         wchar_t * data = dataRef;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * &dataRef = data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     {         wchar_t * data = dataRef;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	bad	void bad() {     wchar_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodG2B	static void goodG2B() {     wchar_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* POTENTIAL FLAW: Possibly deleting memory twice */         delete data;     } }
0	goodB2G	static void goodB2G() {     wchar_t * data;     unionType myUnion;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myUnion.unionFirst = data;     {         wchar_t * data = myUnion.unionSecond;         /* do nothing */         /* FIX: Don't attempt to delete the memory */         ; /* empty statement needed for some flow variants */     } }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSource	static wchar_t * badSource(wchar_t * data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static wchar_t * goodG2BSource(wchar_t * data) {     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static wchar_t * goodB2GSource(wchar_t * data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(wchar_t * &data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSource	static void goodG2BSource(wchar_t * &data) {     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSource	static void goodB2GSource(wchar_t * &data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSink	static void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2BSink	static void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2GSink	static void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	static void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2BSink	static void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2GSink	static void goodB2GSink() {     wchar_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink_b(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink_b(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink_b(data); }
1	badSink_b	void badSink_b(wchar_t * data) {     badSink_c(data); }
0	goodG2BSink_b	void goodG2BSink_b(wchar_t * data) {     goodG2BSink_c(data); }
0	goodB2GSink_b	void goodB2GSink_b(wchar_t * data) {     goodB2GSink_c(data); }
1	badSink_c	void badSink_c(wchar_t * data) {     badSink_d(data); }
0	goodG2BSink_c	void goodG2BSink_c(wchar_t * data) {     goodG2BSink_d(data); }
0	goodB2GSink_c	void goodB2GSink_c(wchar_t * data) {     goodB2GSink_d(data); }
1	badSink_d	void badSink_d(wchar_t * data) {     badSink_e(data); }
0	goodG2BSink_d	void goodG2BSink_d(wchar_t * data) {     goodG2BSink_e(data); }
0	goodB2GSink_d	void goodB2GSink_d(wchar_t * data) {     goodB2GSink_e(data); }
1	badSink_e	void badSink_e(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink_e	void goodG2BSink_e(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink_e	void goodB2GSink_e(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	wchar_t * badSource(wchar_t * data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
0	goodG2BSource	wchar_t * goodG2BSource(wchar_t * data) {     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     return data; }
0	goodB2GSource	wchar_t * goodB2GSource(wchar_t * data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     return data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     badSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodG2BSource(data);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     goodB2GSource(data);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	badSource	void badSource(wchar_t * &data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	goodG2BSource	void goodG2BSource(wchar_t * &data) {     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	goodB2GSource	void goodB2GSource(wchar_t * &data) {     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(wchar_t * * dataPtr) {     wchar_t * data = *dataPtr;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badSink(&data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BSink(&data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GSink(&data); }
1	badSink	void badSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(void * dataVoidPtr) {     /* cast void pointer to a pointer of the appropriate type */     wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;     /* dereference dataPtr into data */     wchar_t * data = (*dataPtr);     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* define a function pointer */     void (*funcPtr) (wchar_t *) = badSink;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* use the function pointer */     funcPtr(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodG2BSink;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     funcPtr(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     void (*funcPtr) (wchar_t *) = goodB2GSink;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     funcPtr(data); }
1	badSink	void badSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* put data in array */     dataArray[2] = data;     badSink(dataArray); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     dataArray[2] = data;     goodG2BSink(dataArray); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     wchar_t * dataArray[5];     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataArray[2] = data;     goodB2GSink(dataArray); }
1	badSink	void badSink(wchar_t * dataArray[]) {     /* copy data out of dataArray */     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(wchar_t * dataArray[]) {     wchar_t * data = dataArray[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     badSink(myStruct); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     myStruct.structFirst = data;     goodG2BSink(myStruct); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     structType myStruct;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     myStruct.structFirst = data;     goodB2GSink(myStruct); }
1	badSink	void badSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(structType myStruct) {     wchar_t * data = myStruct.structFirst;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     badData = data;     badSink(); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     goodG2BData = data;     goodG2BSink(); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     goodB2GData = data;     goodB2GSink(); }
1	badSink	void badSink() {     wchar_t * data = badData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink() {     wchar_t * data = goodG2BData;     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink() {     wchar_t * data = goodB2GData;     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     badSink(dataVector); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a vector */     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodG2BSink(dataVector); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     vector<wchar_t *> dataVector;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     dataVector.insert(dataVector.end(), 1, data);     goodB2GSink(dataVector); }
1	badSink	void badSink(vector<wchar_t *> dataVector) {     /* copy data out of dataVector */     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(vector<wchar_t *> dataVector) {     wchar_t * data = dataVector[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     badSink(dataList); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a list */     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodG2BSink(dataList); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     list<wchar_t *> dataList;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataList.push_back(data);     dataList.push_back(data);     dataList.push_back(data);     goodB2GSink(dataList); }
1	badSink	void badSink(list<wchar_t *> dataList) {     /* copy data out of dataList */     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(list<wchar_t *> dataList) {     wchar_t * data = dataList.back();     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
1	bad	void bad() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     badSink(dataMap); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     /* Put data in a map */     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodG2BSink(dataMap); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     map<int, wchar_t *> dataMap;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     dataMap[0] = data;     dataMap[1] = data;     dataMap[2] = data;     goodB2GSink(dataMap); }
1	badSink	void badSink(map<int, wchar_t *> dataMap) {     /* copy data out of dataMap */     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodG2BSink	void goodG2BSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	goodB2GSink	void goodB2GSink(map<int, wchar_t *> dataMap) {     wchar_t * data = dataMap[2];     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_wchar_t_81_bad::action(wchar_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_wchar_t_81_goodB2G::action(wchar_t * data) const {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_wchar_t_81_goodG2B::action(wchar_t * data) const {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_wchar_t_81_base& o = CWE415_Double_Free__new_delete_wchar_t_81_bad();     o.action(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     const CWE415_Double_Free__new_delete_wchar_t_81_base& baseObject = CWE415_Double_Free__new_delete_wchar_t_81_goodG2B();     baseObject.action(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     const CWE415_Double_Free__new_delete_wchar_t_81_base& baseObject = CWE415_Double_Free__new_delete_wchar_t_81_goodB2G();     baseObject.action(data); }
0	action	void CWE415_Double_Free__new_delete_wchar_t_82_bad::action(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	action	void CWE415_Double_Free__new_delete_wchar_t_82_goodB2G::action(wchar_t * data) {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	action	void CWE415_Double_Free__new_delete_wchar_t_82_goodG2B::action(wchar_t * data) {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_wchar_t_82_base* baseObject = new CWE415_Double_Free__new_delete_wchar_t_82_bad;     baseObject->action(data);     delete baseObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */     CWE415_Double_Free__new_delete_wchar_t_82_base* baseObject = new CWE415_Double_Free__new_delete_wchar_t_82_goodG2B;     baseObject->action(data);     delete baseObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data;     CWE415_Double_Free__new_delete_wchar_t_82_base* baseObject = new CWE415_Double_Free__new_delete_wchar_t_82_goodB2G;     baseObject->action(data);     delete baseObject; }
1	CWE415_Double_Free__new_delete_wchar_t_83_bad	CWE415_Double_Free__new_delete_wchar_t_83_bad::CWE415_Double_Free__new_delete_wchar_t_83_bad(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_wchar_t_83_bad	CWE415_Double_Free__new_delete_wchar_t_83_bad::~CWE415_Double_Free__new_delete_wchar_t_83_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_wchar_t_83_goodB2G	CWE415_Double_Free__new_delete_wchar_t_83_goodB2G::CWE415_Double_Free__new_delete_wchar_t_83_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_wchar_t_83_goodB2G	CWE415_Double_Free__new_delete_wchar_t_83_goodB2G::~CWE415_Double_Free__new_delete_wchar_t_83_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_wchar_t_83_goodG2B	CWE415_Double_Free__new_delete_wchar_t_83_goodG2B::CWE415_Double_Free__new_delete_wchar_t_83_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_wchar_t_83_goodG2B	CWE415_Double_Free__new_delete_wchar_t_83_goodG2B::~CWE415_Double_Free__new_delete_wchar_t_83_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_wchar_t_83_bad badObject(data); }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_wchar_t_83_goodG2B goodG2BObject(data); }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_wchar_t_83_goodB2G goodB2GObject(data); }
1	CWE415_Double_Free__new_delete_wchar_t_84_bad	CWE415_Double_Free__new_delete_wchar_t_84_bad::CWE415_Double_Free__new_delete_wchar_t_84_bad(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
1	~CWE415_Double_Free__new_delete_wchar_t_84_bad	CWE415_Double_Free__new_delete_wchar_t_84_bad::~CWE415_Double_Free__new_delete_wchar_t_84_bad() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
0	CWE415_Double_Free__new_delete_wchar_t_84_goodB2G	CWE415_Double_Free__new_delete_wchar_t_84_goodB2G::CWE415_Double_Free__new_delete_wchar_t_84_goodB2G(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t;     /* POTENTIAL FLAW: delete data in the source - the bad sink deletes data as well */     delete data; }
0	~CWE415_Double_Free__new_delete_wchar_t_84_goodB2G	CWE415_Double_Free__new_delete_wchar_t_84_goodB2G::~CWE415_Double_Free__new_delete_wchar_t_84_goodB2G() {     /* do nothing */     /* FIX: Don't attempt to delete the memory */     ; /* empty statement needed for some flow variants */ }
0	CWE415_Double_Free__new_delete_wchar_t_84_goodG2B	CWE415_Double_Free__new_delete_wchar_t_84_goodG2B::CWE415_Double_Free__new_delete_wchar_t_84_goodG2B(wchar_t * dataCopy) {     data = dataCopy;     data = new wchar_t;     /* FIX: Do NOT delete data in the source - the bad sink deletes data */ }
0	~CWE415_Double_Free__new_delete_wchar_t_84_goodG2B	CWE415_Double_Free__new_delete_wchar_t_84_goodG2B::~CWE415_Double_Free__new_delete_wchar_t_84_goodG2B() {     /* POTENTIAL FLAW: Possibly deleting memory twice */     delete data; }
1	bad	void bad() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_wchar_t_84_bad * badObject = new CWE415_Double_Free__new_delete_wchar_t_84_bad(data);     delete badObject; }
0	goodG2B	static void goodG2B() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_wchar_t_84_goodG2B * goodG2BObject = new CWE415_Double_Free__new_delete_wchar_t_84_goodG2B(data);     delete goodG2BObject; }
0	goodB2G	static void goodB2G() {     wchar_t * data;     /* Initialize data */     data = NULL;     CWE415_Double_Free__new_delete_wchar_t_84_goodB2G * goodB2GObject = new CWE415_Double_Free__new_delete_wchar_t_84_goodB2G(data);     delete goodB2GObject; }
0	BadClass	BadClass(const char *data)         {             if (data)              {                 this->data = new char[strlen(data) + 1];                 strcpy(this->data, data);             }              else              {                 this->data = new char[1];                 *(this->data) = '\0';             }         }
0	~BadClass	~BadClass()         {             delete [] data;         }
0	printData	void printData()         {             printLine(data);         }
0	BadClass	BadClass(BadClass &badClassObject)         {              this->data = new char[strlen(badClassObject.data) + 1];             strcpy(this->data, badClassObject.data);          }
1	bad	void bad() {     BadClass badClassObject1("One"), badClassObject2("Two");      /* FLAW: There is no assignment operator in the class - this will cause a double free in the destructor */     badClassObject2 = badClassObject1;      badClassObject2.printData(); }
0	GoodClass	GoodClass(const char *data)         {             if (data)              {                 this->data = new char[strlen(data) + 1];                 strcpy(this->data, data);             }              else              {                 this->data = new char[1];                 *(this->data) = '\0';             }         }
0	~GoodClass	~GoodClass()         {             delete [] data;         }
0	printData	void printData()         {             printLine(data);         }
0	GoodClass	GoodClass(GoodClass &goodClassObject)         {              this->data = new char[strlen(goodClassObject.data) + 1];             strcpy(this->data, goodClassObject.data);         }
0	=	GoodClass& operator=(const GoodClass &goodClassObject)         {              if (&goodClassObject != this)              {                  this->data = new char[strlen(goodClassObject.data) + 1];                 strcpy(this->data, goodClassObject.data);             }              return *this;          }
0	good1	static void good1() {     GoodClass goodClassObject1("One"), goodClassObject2("Two");      /* FIX: There is an assignment operator defined in the class */     goodClassObject2 = goodClassObject1;      goodClassObject2.printData(); }
0	BadClass	BadClass(const char *data)         {             if (data)              {                 this->data = new char[strlen(data) + 1];                 strcpy(this->data, data);             }              else              {                 this->data = new char[1];                 *(this->data) = '\0';             }         }
0	~BadClass	~BadClass()         {             delete [] data;         }
0	printData	void printData()         {             printLine(data);         }
0	=	BadClass& operator=(const BadClass &badClassObject)          {              if (&badClassObject != this)              {                  this->data = new char[strlen(badClassObject.data) + 1];                 strcpy(this->data, badClassObject.data);             }              return *this;          }
1	bad	void bad() {     BadClass badClassObject("One");      /* FLAW: There is no copy constructor in the class - this will cause a double free in the destructor */     BadClass badClassObjectCopy(badClassObject);      badClassObjectCopy.printData(); }
0	GoodClass	GoodClass(const char *data)         {             if (data)              {                 this->data = new char[strlen(data) + 1];                 strcpy(this->data, data);             }              else              {                 this->data = new char[1];                 *(this->data) = '\0';             }         }
0	~GoodClass	~GoodClass()         {             delete [] data;         }
0	printData	void printData()         {             printLine(data);         }
0	GoodClass	GoodClass(GoodClass &goodClassObject)         {              this->data = new char[strlen(goodClassObject.data) + 1];             strcpy(this->data, goodClassObject.data);         }
0	=	GoodClass& operator=(const GoodClass &goodClassObject)          {              if (&goodClassObject != this)              {                  this->data = new char[strlen(goodClassObject.data) + 1];                 strcpy(this->data, goodClassObject.data);              }              return *this;          }
0	good1	static void good1() {     GoodClass goodClassObject("One");      /* FIX: There is a copy constructor defined in the class */     GoodClass goodClassObjectCopy(goodClassObject);      goodClassObjectCopy.printData(); }
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	goodG2BSource	twoIntsStruct * goodG2BSource(twoIntsStruct * data);
0	goodB2GSource	twoIntsStruct * goodB2GSource(twoIntsStruct * data);
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	action	virtual void action(twoIntsStruct * data) const = 0;
0	action	virtual void action(TwoIntsClass * data) const = 0;
0	goodB2GSource	twoIntsStruct * goodB2GSource(twoIntsStruct * data);
0	action	virtual void action(TwoIntsClass * data) const = 0;
0	goodG2BSource	twoIntsStruct * goodG2BSource(twoIntsStruct * data);