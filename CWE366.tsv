0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_01_bad	void CWE366_Race_Condition_Within_Thread__global_int_01_bad() {     {         stdThread threadA = NULL;         stdThread threadB = NULL;         gBadInt = 0;         if (!stdThreadCreate(helperBad, NULL, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperBad, NULL, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         printIntLine(gBadInt);     } }
0	good1	static void good1() {     {         stdThread threadA = NULL;         stdThread threadB = NULL;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, NULL, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, NULL, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(gGoodInt);     } }
0	CWE366_Race_Condition_Within_Thread__global_int_01_good	void CWE366_Race_Condition_Within_Thread__global_int_01_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_02_bad	void CWE366_Race_Condition_Within_Thread__global_int_02_bad() {     if(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_02_good	void CWE366_Race_Condition_Within_Thread__global_int_02_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_03_bad	void CWE366_Race_Condition_Within_Thread__global_int_03_bad() {     if(5==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(5==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_03_good	void CWE366_Race_Condition_Within_Thread__global_int_03_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_04_bad	void CWE366_Race_Condition_Within_Thread__global_int_04_bad() {     if(STATIC_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_04_good	void CWE366_Race_Condition_Within_Thread__global_int_04_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_05_bad	void CWE366_Race_Condition_Within_Thread__global_int_05_bad() {     if(staticTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(staticTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_05_good	void CWE366_Race_Condition_Within_Thread__global_int_05_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_06_bad	void CWE366_Race_Condition_Within_Thread__global_int_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_06_good	void CWE366_Race_Condition_Within_Thread__global_int_06_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_07_bad	void CWE366_Race_Condition_Within_Thread__global_int_07_bad() {     if(staticFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(staticFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_07_good	void CWE366_Race_Condition_Within_Thread__global_int_07_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_08_bad	void CWE366_Race_Condition_Within_Thread__global_int_08_bad() {     if(staticReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_08_good	void CWE366_Race_Condition_Within_Thread__global_int_08_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_09_bad	void CWE366_Race_Condition_Within_Thread__global_int_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_09_good	void CWE366_Race_Condition_Within_Thread__global_int_09_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_10_bad	void CWE366_Race_Condition_Within_Thread__global_int_10_bad() {     if(globalTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(globalTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_10_good	void CWE366_Race_Condition_Within_Thread__global_int_10_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_11_bad	void CWE366_Race_Condition_Within_Thread__global_int_11_bad() {     if(globalReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_11_good	void CWE366_Race_Condition_Within_Thread__global_int_11_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_12_bad	void CWE366_Race_Condition_Within_Thread__global_int_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGo...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))           ...
0	CWE366_Race_Condition_Within_Thread__global_int_12_good	void CWE366_Race_Condition_Within_Thread__global_int_12_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_13_bad	void CWE366_Race_Condition_Within_Thread__global_int_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_13_good	void CWE366_Race_Condition_Within_Thread__global_int_13_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_14_bad	void CWE366_Race_Condition_Within_Thread__global_int_14_bad() {     if(globalFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	good2	static void good2() {     if(globalFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_14_good	void CWE366_Race_Condition_Within_Thread__global_int_14_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_15_bad	void CWE366_Race_Condition_Within_Thread__global_int_15_bad() {     switch(6)     {     case 6:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         gBadInt = 0;         if (!stdThreadCreate(helperBad, NULL, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperBad, NULL, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         printIntLine(gBadInt);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, NULL, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, NULL, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(gGoodInt);     }     break;     } }
0	good2	static void good2() {     switch(6)     {     case 6:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, NULL, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, NULL, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(gGoodInt);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE366_Race_Condition_Within_Thread__global_int_15_good	void CWE366_Race_Condition_Within_Thread__global_int_15_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_16_bad	void CWE366_Race_Condition_Within_Thread__global_int_16_bad() {     while(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }         break;     } }
0	CWE366_Race_Condition_Within_Thread__global_int_16_good	void CWE366_Race_Condition_Within_Thread__global_int_16_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_17_bad	void CWE366_Race_Condition_Within_Thread__global_int_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             gBadInt = 0;             if (!stdThreadCreate(helperBad, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(gBadInt);         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, NULL, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, NULL, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(gGoodInt);         }     } }
0	CWE366_Race_Condition_Within_Thread__global_int_17_good	void CWE366_Race_Condition_Within_Thread__global_int_17_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     /* I'm going to risk going out on a limb here and making this slightly      * more complicated to illustrate the point: doing this in a loop a million      * times makes it much more "obvious" that something wrong might happen      * (you can even see it in action when you run the program)      */     for (i = 0; i < N_ITERS; i++)     {         gBadInt = gBadInt + 1;     } }
0	helperGood	static void helperGood(void *args) {     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         gGoodInt = gGoodInt + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__global_int_18_bad	void CWE366_Race_Condition_Within_Thread__global_int_18_bad() {     goto sink; sink:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         gBadInt = 0;         if (!stdThreadCreate(helperBad, NULL, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperBad, NULL, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         printIntLine(gBadInt);     } }
0	good1	static void good1() {     goto sink; sink:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, NULL, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, NULL, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(gGoodInt);     } }
0	CWE366_Race_Condition_Within_Thread__global_int_18_good	void CWE366_Race_Condition_Within_Thread__global_int_18_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_01_bad	void CWE366_Race_Condition_Within_Thread__int_byref_01_bad() {     {         stdThread threadA = NULL;         stdThread threadB = NULL;         int valBadSink;         valBadSink = 0;         if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         printIntLine(valBadSink);     } }
0	good1	static void good1() {     {         stdThread threadA = NULL;         stdThread threadB = NULL;         int valGoodSink;         valGoodSink = 0;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(valGoodSink);     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_01_good	void CWE366_Race_Condition_Within_Thread__int_byref_01_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_02_bad	void CWE366_Race_Condition_Within_Thread__int_byref_02_bad() {     if(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(0)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);            ...
0	good2	static void good2() {     if(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_02_good	void CWE366_Race_Condition_Within_Thread__int_byref_02_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_03_bad	void CWE366_Race_Condition_Within_Thread__int_byref_03_bad() {     if(5==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(5!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);         ...
0	good2	static void good2() {     if(5==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_03_good	void CWE366_Race_Condition_Within_Thread__int_byref_03_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_04_bad	void CWE366_Race_Condition_Within_Thread__int_byref_04_bad() {     if(STATIC_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodL...
0	good2	static void good2() {     if(STATIC_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_04_good	void CWE366_Race_Condition_Within_Thread__int_byref_04_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_05_bad	void CWE366_Race_Condition_Within_Thread__int_byref_05_bad() {     if(staticTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(staticFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);  ...
0	good2	static void good2() {     if(staticTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_05_good	void CWE366_Race_Condition_Within_Thread__int_byref_05_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_06_bad	void CWE366_Race_Condition_Within_Thread__int_byref_06_bad() {     if(STATIC_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(STATIC_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoo...
0	good2	static void good2() {     if(STATIC_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_06_good	void CWE366_Race_Condition_Within_Thread__int_byref_06_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_07_bad	void CWE366_Race_Condition_Within_Thread__int_byref_07_bad() {     if(staticFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(staticFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);...
0	good2	static void good2() {     if(staticFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_07_good	void CWE366_Race_Condition_Within_Thread__int_byref_07_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_08_bad	void CWE366_Race_Condition_Within_Thread__int_byref_08_bad() {     if(staticReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(staticReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoo...
0	good2	static void good2() {     if(staticReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_08_good	void CWE366_Race_Condition_Within_Thread__int_byref_08_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_09_bad	void CWE366_Race_Condition_Within_Thread__int_byref_09_bad() {     if(GLOBAL_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FALSE)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodL...
0	good2	static void good2() {     if(GLOBAL_CONST_TRUE)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_09_good	void CWE366_Race_Condition_Within_Thread__int_byref_09_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_10_bad	void CWE366_Race_Condition_Within_Thread__int_byref_10_bad() {     if(globalTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(globalFalse)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);  ...
0	good2	static void good2() {     if(globalTrue)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_10_good	void CWE366_Race_Condition_Within_Thread__int_byref_10_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_11_bad	void CWE366_Race_Condition_Within_Thread__int_byref_11_bad() {     if(globalReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(globalReturnsFalse())     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoo...
0	good2	static void good2() {     if(globalReturnsTrue())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_11_good	void CWE366_Race_Condition_Within_Thread__int_byref_11_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_12_bad	void CWE366_Race_Condition_Within_Thread__int_byref_12_bad() {     if(globalReturnsTrueOrFalse())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThre...
0	good1	static void good1() {     if(globalReturnsTrueOrFalse())     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     }     else     {         {             stdThread threadA = NULL;        ...
0	CWE366_Race_Condition_Within_Thread__int_byref_12_good	void CWE366_Race_Condition_Within_Thread__int_byref_12_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_13_bad	void CWE366_Race_Condition_Within_Thread__int_byref_13_bad() {     if(GLOBAL_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(GLOBAL_CONST_FIVE!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoo...
0	good2	static void good2() {     if(GLOBAL_CONST_FIVE==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_13_good	void CWE366_Race_Condition_Within_Thread__int_byref_13_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_14_bad	void CWE366_Race_Condition_Within_Thread__int_byref_14_bad() {     if(globalFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     if(globalFive!=5)     {         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");     }     else     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);...
0	good2	static void good2() {     if(globalFive==5)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_14_good	void CWE366_Race_Condition_Within_Thread__int_byref_14_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_15_bad	void CWE366_Race_Condition_Within_Thread__int_byref_15_bad() {     switch(6)     {     case 6:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         int valBadSink;         valBadSink = 0;         if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         printIntLine(valBadSink);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	good1	static void good1() {     switch(5)     {     case 6:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     default:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         int valGoodSink;         valGoodSink = 0;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(valGoodSink);     }     break;     } }
0	good2	static void good2() {     switch(6)     {     case 6:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         int valGoodSink;         valGoodSink = 0;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(valGoodSink);     }     break;     default:         /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */         printLine("Benign, fixed string");         break;     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_15_good	void CWE366_Race_Condition_Within_Thread__int_byref_15_good() {     good1();     good2(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_16_bad	void CWE366_Race_Condition_Within_Thread__int_byref_16_bad() {     while(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }         break;     } }
0	good1	static void good1() {     while(1)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }         break;     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_16_good	void CWE366_Race_Condition_Within_Thread__int_byref_16_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_17_bad	void CWE366_Race_Condition_Within_Thread__int_byref_17_bad() {     int j;     for(j = 0; j < 1; j++)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valBadSink;             valBadSink = 0;             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             printIntLine(valBadSink);         }     } }
0	good1	static void good1() {     int k;     for(k = 0; k < 1; k++)     {         {             stdThread threadA = NULL;             stdThread threadB = NULL;             int valGoodSink;             valGoodSink = 0;             if (!stdThreadLockCreate(&gGoodLock))             {                 return;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))             {                 threadA = NULL;             }             if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))             {                 threadB = NULL;             }             if (threadA && stdThreadJoin(threadA))             {                 stdThreadDestroy(threadA);             }             if (threadB && stdThreadJoin(threadB))             {                 stdThreadDestroy(threadB);             }             stdThreadLockDestroy(gGoodLock);             printIntLine(valGoodSink);         }     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_17_good	void CWE366_Race_Condition_Within_Thread__int_byref_17_good() {     good1(); }
0	helperBad	static void helperBad(void *args) {     int *pIntArgs = (int*)args;     int i;     /* FLAW: incrementing an integer is not guaranteed to occur atomically;      * therefore this operation may not function as intended in multi-threaded      * programs      */     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     } }
0	helperGood	static void helperGood(void *args) {     int *pIntArgs = (int *)args;     int i;     /* FIX: acquire a lock before conducting operations that need to occur      * atomically, and release afterwards      */     stdThreadLockAcquire(gGoodLock);     for (i = 0; i < N_ITERS; i++)     {         *pIntArgs = *pIntArgs + 1;     }     stdThreadLockRelease(gGoodLock); }
1	CWE366_Race_Condition_Within_Thread__int_byref_18_bad	void CWE366_Race_Condition_Within_Thread__int_byref_18_bad() {     goto sink; sink:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         int valBadSink;         valBadSink = 0;         if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperBad, (void*)&valBadSink, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         printIntLine(valBadSink);     } }
0	good1	static void good1() {     goto sink; sink:     {         stdThread threadA = NULL;         stdThread threadB = NULL;         int valGoodSink;         valGoodSink = 0;         if (!stdThreadLockCreate(&gGoodLock))         {             return;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadA))         {             threadA = NULL;         }         if (!stdThreadCreate(helperGood, (void*)&valGoodSink, &threadB))         {             threadB = NULL;         }         if (threadA && stdThreadJoin(threadA))         {             stdThreadDestroy(threadA);         }         if (threadB && stdThreadJoin(threadB))         {             stdThreadDestroy(threadB);         }         stdThreadLockDestroy(gGoodLock);         printIntLine(valGoodSink);     } }
0	CWE366_Race_Condition_Within_Thread__int_byref_18_good	void CWE366_Race_Condition_Within_Thread__int_byref_18_good() {     good1(); }